{"version":3,"file":"index.es5.js","sources":["src/base.js","src/decorators.js","src/tables/cmap.js","src/tables/head.js","src/tables/hhea.js","src/tables/hmtx.js","src/tables/maxp.js","src/encodings.js","src/tables/name.js","src/tables/OS2.js","src/tables/post.js","src/tables/cvt.js","src/tables/fpgm.js","src/tables/loca.js","src/tables/prep.js","src/tables/glyf.js","src/cff/CFFIndex.js","src/cff/CFFOperand.js","src/cff/CFFDict.js","src/cff/CFFPointer.js","src/cff/CFFPrivateDict.js","src/cff/CFFStandardStrings.js","src/cff/CFFEncodings.js","src/cff/CFFCharsets.js","src/tables/opentype.js","src/tables/variations.js","src/cff/CFFTop.js","src/cff/CFFFont.js","src/tables/VORG.js","src/tables/EBDT.js","src/tables/EBLC.js","src/tables/sbix.js","src/tables/COLR.js","src/tables/CPAL.js","src/tables/BASE.js","src/tables/GDEF.js","src/tables/GPOS.js","src/tables/GSUB.js","src/tables/JSTF.js","src/tables/HVAR.js","src/tables/DSIG.js","src/tables/gasp.js","src/tables/hdmx.js","src/tables/kern.js","src/tables/LTSH.js","src/tables/PCLT.js","src/tables/VDMX.js","src/tables/vhea.js","src/tables/vmtx.js","src/tables/avar.js","src/tables/aat.js","src/tables/bsln.js","src/tables/feat.js","src/tables/fvar.js","src/tables/gvar.js","src/tables/just.js","src/tables/morx.js","src/tables/opbd.js","src/tables/index.js","src/tables/directory.js","src/utils.js","src/CmapProcessor.js","src/layout/KernProcessor.js","src/layout/UnicodeLayoutEngine.js","src/glyph/BBox.js","src/layout/Script.js","src/layout/GlyphRun.js","src/layout/GlyphPosition.js","src/aat/AATFeatureMap.js","src/aat/AATLookupTable.js","src/aat/AATStateMachine.js","src/aat/AATMorxProcessor.js","src/aat/AATLayoutEngine.js","src/opentype/ShapingPlan.js","src/opentype/shapers/DefaultShaper.js","src/opentype/shapers/ArabicShaper.js","src/opentype/GlyphIterator.js","src/opentype/OTProcessor.js","src/opentype/GlyphInfo.js","src/opentype/shapers/HangulShaper.js","src/opentype/shapers/indic-data.js","src/opentype/shapers/IndicShaper.js","src/opentype/shapers/UniversalShaper.js","src/opentype/shapers/index.js","src/opentype/GSUBProcessor.js","src/opentype/GPOSProcessor.js","src/opentype/OTLayoutEngine.js","src/layout/LayoutEngine.js","src/glyph/Path.js","src/glyph/StandardNames.js","src/glyph/Glyph.js","src/glyph/TTFGlyph.js","src/glyph/CFFGlyph.js","src/glyph/SBIXGlyph.js","src/glyph/COLRGlyph.js","src/glyph/GlyphVariationProcessor.js","src/subset/Subset.js","src/glyph/TTFGlyphEncoder.js","src/subset/TTFSubset.js","src/subset/CFFSubset.js","src/TTFFont.js","src/tables/WOFFDirectory.js","src/WOFFFont.js","src/glyph/WOFF2Glyph.js","src/tables/WOFF2Directory.js","src/WOFF2Font.js","src/TrueTypeCollection.js","src/DFont.js","src/index.js"],"sourcesContent":["import r from '@foliojs-fork/restructure';\r\nconst fs = require('fs');\r\n\r\nvar fontkit = {};\r\nexport default fontkit;\r\n\r\nfontkit.logErrors = false;\r\n\r\nlet formats = [];\r\nfontkit.registerFormat = function(format) {\r\n  formats.push(format);\r\n};\r\n\r\nfontkit.openSync = function(filename, postscriptName) {\r\n  let buffer = fs.readFileSync(filename);\r\n  return fontkit.create(buffer, postscriptName);\r\n};\r\n\r\nfontkit.open = function(filename, postscriptName, callback) {\r\n  if (typeof postscriptName === 'function') {\r\n    callback = postscriptName;\r\n    postscriptName = null;\r\n  }\r\n\r\n  fs.readFile(filename, function(err, buffer) {\r\n    if (err) { return callback(err); }\r\n\r\n    try {\r\n      var font = fontkit.create(buffer, postscriptName);\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n\r\n    return callback(null, font);\r\n  });\r\n\r\n  return;\r\n};\r\n\r\nfontkit.create = function(buffer, postscriptName) {\r\n  for (let i = 0; i < formats.length; i++) {\r\n    let format = formats[i];\r\n    if (format.probe(buffer)) {\r\n      let font = new format(new r.DecodeStream(buffer));\r\n      if (postscriptName) {\r\n        return font.getFont(postscriptName);\r\n      }\r\n\r\n      return font;\r\n    }\r\n  }\r\n\r\n  throw new Error('Unknown font format');\r\n};\r\n\r\nfontkit.defaultLanguage = 'en';\r\nfontkit.setDefaultLanguage = function(lang = 'en') {\r\n  fontkit.defaultLanguage = lang;\r\n};","/**\r\n * This decorator caches the results of a getter or method such that\r\n * the results are lazily computed once, and then cached.\r\n * @private\r\n */\r\nexport function cache(target, key, descriptor) {\r\n  if (descriptor.get) {\r\n    let get = descriptor.get;\r\n    descriptor.get = function() {\r\n      let value = get.call(this);\r\n      Object.defineProperty(this, key, { value });\r\n      return value;\r\n    };\r\n  } else if (typeof descriptor.value === 'function') {\r\n    let fn = descriptor.value;\r\n\r\n    return {\r\n      get() {\r\n        let cache = new Map;\r\n        function memoized(...args) {\r\n          let key = args.length > 0 ? args[0] : 'value';\r\n          if (cache.has(key)) {\r\n            return cache.get(key);\r\n          }\r\n\r\n          let result = fn.apply(this, args);\r\n          cache.set(key, result);\r\n          return result;\r\n        };\r\n\r\n        Object.defineProperty(this, key, {value: memoized});\r\n        return memoized;\r\n      }\r\n    };\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet SubHeader = new r.Struct({\r\n  firstCode:      r.uint16,\r\n  entryCount:     r.uint16,\r\n  idDelta:        r.int16,\r\n  idRangeOffset:  r.uint16\r\n});\r\n\r\nlet CmapGroup = new r.Struct({\r\n  startCharCode:  r.uint32,\r\n  endCharCode:    r.uint32,\r\n  glyphID:        r.uint32\r\n});\r\n\r\nlet UnicodeValueRange = new r.Struct({\r\n  startUnicodeValue:  r.uint24,\r\n  additionalCount:    r.uint8\r\n});\r\n\r\nlet UVSMapping = new r.Struct({\r\n  unicodeValue: r.uint24,\r\n  glyphID:      r.uint16\r\n});\r\n\r\nlet DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);\r\nlet NonDefaultUVS = new r.Array(UVSMapping, r.uint32);\r\n\r\nlet VarSelectorRecord = new r.Struct({\r\n  varSelector:    r.uint24,\r\n  defaultUVS:     new r.Pointer(r.uint32, DefaultUVS, {type: 'parent'}),\r\n  nonDefaultUVS:  new r.Pointer(r.uint32, NonDefaultUVS, {type: 'parent'})\r\n});\r\n\r\nlet CmapSubtable = new r.VersionedStruct(r.uint16, {\r\n  0: { // Byte encoding\r\n    length:     r.uint16,   // Total table length in bytes (set to 262 for format 0)\r\n    language:   r.uint16,   // Language code for this encoding subtable, or zero if language-independent\r\n    codeMap:    new r.LazyArray(r.uint8, 256)\r\n  },\r\n\r\n  2: { // High-byte mapping (CJK)\r\n    length:           r.uint16,\r\n    language:         r.uint16,\r\n    subHeaderKeys:    new r.Array(r.uint16, 256),\r\n    subHeaderCount:   t => Math.max.apply(Math, t.subHeaderKeys),\r\n    subHeaders:       new r.LazyArray(SubHeader, 'subHeaderCount'),\r\n    glyphIndexArray:  new r.LazyArray(r.uint16, 'subHeaderCount')\r\n  },\r\n\r\n  4: { // Segment mapping to delta values\r\n    length:           r.uint16,              // Total table length in bytes\r\n    language:         r.uint16,              // Language code\r\n    segCountX2:       r.uint16,\r\n    segCount:         t => t.segCountX2 >> 1,\r\n    searchRange:      r.uint16,\r\n    entrySelector:    r.uint16,\r\n    rangeShift:       r.uint16,\r\n    endCode:          new r.LazyArray(r.uint16, 'segCount'),\r\n    reservedPad:      new r.Reserved(r.uint16),       // This value should be zero\r\n    startCode:        new r.LazyArray(r.uint16, 'segCount'),\r\n    idDelta:          new r.LazyArray(r.int16, 'segCount'),\r\n    idRangeOffset:    new r.LazyArray(r.uint16, 'segCount'),\r\n    glyphIndexArray:  new r.LazyArray(r.uint16, t => (t.length - t._currentOffset) / 2)\r\n  },\r\n\r\n  6: { // Trimmed table\r\n    length:         r.uint16,\r\n    language:       r.uint16,\r\n    firstCode:      r.uint16,\r\n    entryCount:     r.uint16,\r\n    glyphIndices:   new r.LazyArray(r.uint16, 'entryCount')\r\n  },\r\n\r\n  8: { // mixed 16-bit and 32-bit coverage\r\n    reserved: new r.Reserved(r.uint16),\r\n    length:   r.uint32,\r\n    language: r.uint16,\r\n    is32:     new r.LazyArray(r.uint8, 8192),\r\n    nGroups:  r.uint32,\r\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\r\n  },\r\n\r\n  10: { // Trimmed Array\r\n    reserved:       new r.Reserved(r.uint16),\r\n    length:         r.uint32,\r\n    language:       r.uint32,\r\n    firstCode:      r.uint32,\r\n    entryCount:     r.uint32,\r\n    glyphIndices:   new r.LazyArray(r.uint16, 'numChars')\r\n  },\r\n\r\n  12: { // Segmented coverage\r\n    reserved: new r.Reserved(r.uint16),\r\n    length:   r.uint32,\r\n    language: r.uint32,\r\n    nGroups:  r.uint32,\r\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\r\n  },\r\n\r\n  13: { // Many-to-one range mappings (same as 12 except for group.startGlyphID)\r\n    reserved: new r.Reserved(r.uint16),\r\n    length:   r.uint32,\r\n    language: r.uint32,\r\n    nGroups:  r.uint32,\r\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\r\n  },\r\n\r\n  14: { // Unicode Variation Sequences\r\n    length:       r.uint32,\r\n    numRecords:   r.uint32,\r\n    varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')\r\n  }\r\n});\r\n\r\nlet CmapEntry = new r.Struct({\r\n  platformID:  r.uint16,  // Platform identifier\r\n  encodingID:  r.uint16,  // Platform-specific encoding identifier\r\n  table:       new r.Pointer(r.uint32, CmapSubtable, {type: 'parent', lazy: true})\r\n});\r\n\r\n// character to glyph mapping\r\nexport default new r.Struct({\r\n  version:      r.uint16,\r\n  numSubtables: r.uint16,\r\n  tables:       new r.Array(CmapEntry, 'numSubtables')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// font header\r\nexport default new r.Struct({\r\n  version:            r.int32,                   // 0x00010000 (version 1.0)\r\n  revision:           r.int32,                   // set by font manufacturer\r\n  checkSumAdjustment: r.uint32,\r\n  magicNumber:        r.uint32,                  // set to 0x5F0F3CF5\r\n  flags:              r.uint16,\r\n  unitsPerEm:         r.uint16,                  // range from 64 to 16384\r\n  created:            new r.Array(r.int32, 2),\r\n  modified:           new r.Array(r.int32, 2),\r\n  xMin:               r.int16,                   // for all glyph bounding boxes\r\n  yMin:               r.int16,                   // for all glyph bounding boxes\r\n  xMax:               r.int16,                   // for all glyph bounding boxes\r\n  yMax:               r.int16,                   // for all glyph bounding boxes\r\n  macStyle:           new r.Bitfield(r.uint16, [\r\n    'bold', 'italic', 'underline', 'outline',\r\n    'shadow', 'condensed', 'extended'\r\n  ]),\r\n  lowestRecPPEM:      r.uint16,                  // smallest readable size in pixels\r\n  fontDirectionHint:  r.int16,\r\n  indexToLocFormat:   r.int16,                   // 0 for short offsets, 1 for long\r\n  glyphDataFormat:    r.int16                    // 0 for current format\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// horizontal header\r\nexport default new r.Struct({\r\n  version:              r.int32,\r\n  ascent:               r.int16,   // Distance from baseline of highest ascender\r\n  descent:              r.int16,   // Distance from baseline of lowest descender\r\n  lineGap:              r.int16,   // Typographic line gap\r\n  advanceWidthMax:      r.uint16,  // Maximum advance width value in 'hmtx' table\r\n  minLeftSideBearing:   r.int16,   // Maximum advance width value in 'hmtx' table\r\n  minRightSideBearing:  r.int16,   // Minimum right sidebearing value\r\n  xMaxExtent:           r.int16,\r\n  caretSlopeRise:       r.int16,   // Used to calculate the slope of the cursor (rise/run); 1 for vertical\r\n  caretSlopeRun:        r.int16,   // 0 for vertical\r\n  caretOffset:          r.int16,   // Set to 0 for non-slanted fonts\r\n  reserved:             new r.Reserved(r.int16, 4),\r\n  metricDataFormat:     r.int16,   // 0 for current format\r\n  numberOfMetrics:      r.uint16   // Number of advance widths in 'hmtx' table\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet HmtxEntry = new r.Struct({\r\n  advance: r.uint16,\r\n  bearing: r.int16\r\n});\r\n\r\nexport default new r.Struct({\r\n  metrics:    new r.LazyArray(HmtxEntry, t => t.parent.hhea.numberOfMetrics),\r\n  bearings:   new r.LazyArray(r.int16, t => t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// maxiumum profile\r\nexport default new r.Struct({\r\n  version:                r.int32,\r\n  numGlyphs:              r.uint16,  // The number of glyphs in the font\r\n  maxPoints:              r.uint16,  // Maximum points in a non-composite glyph\r\n  maxContours:            r.uint16,  // Maximum contours in a non-composite glyph\r\n  maxComponentPoints:     r.uint16,  // Maximum points in a composite glyph\r\n  maxComponentContours:   r.uint16,  // Maximum contours in a composite glyph\r\n  maxZones:               r.uint16,  // 1 if instructions do not use the twilight zone, 2 otherwise\r\n  maxTwilightPoints:      r.uint16,  // Maximum points used in Z0\r\n  maxStorage:             r.uint16,  // Number of Storage Area locations\r\n  maxFunctionDefs:        r.uint16,  // Number of FDEFs\r\n  maxInstructionDefs:     r.uint16,  // Number of IDEFs\r\n  maxStackElements:       r.uint16,  // Maximum stack depth\r\n  maxSizeOfInstructions:  r.uint16,  // Maximum byte count for glyph instructions\r\n  maxComponentElements:   r.uint16,  // Maximum number of components referenced at “top level” for any composite glyph\r\n  maxComponentDepth:      r.uint16   // Maximum levels of recursion; 1 for simple components\r\n});\r\n","/**\r\n * Gets an encoding name from platform, encoding, and language ids.\r\n * Returned encoding names can be used in iconv-lite to decode text.\r\n */\r\nexport function getEncoding(platformID, encodingID, languageID = 0) {\r\n  if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {\r\n    return MAC_LANGUAGE_ENCODINGS[languageID];\r\n  }\r\n  \r\n  return ENCODINGS[platformID][encodingID];\r\n}\r\n\r\n// Map of platform ids to encoding ids.\r\nexport const ENCODINGS = [\r\n  // unicode\r\n  ['utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be'],\r\n  \r\n  // macintosh\r\n  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/\r\n  // 0\tRoman                 17\tMalayalam\r\n  // 1\tJapanese\t            18\tSinhalese\r\n  // 2\tTraditional Chinese\t  19\tBurmese\r\n  // 3\tKorean\t              20\tKhmer\r\n  // 4\tArabic\t              21\tThai\r\n  // 5\tHebrew\t              22\tLaotian\r\n  // 6\tGreek\t                23\tGeorgian\r\n  // 7\tRussian\t              24\tArmenian\r\n  // 8\tRSymbol\t              25\tSimplified Chinese\r\n  // 9\tDevanagari\t          26\tTibetan\r\n  // 10\tGurmukhi\t            27\tMongolian\r\n  // 11\tGujarati\t            28\tGeez\r\n  // 12\tOriya\t                29\tSlavic\r\n  // 13\tBengali\t              30\tVietnamese\r\n  // 14\tTamil\t                31\tSindhi\r\n  // 15\tTelugu\t              32\t(Uninterpreted)\r\n  // 16\tKannada\r\n  ['macroman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8',\r\n   'macgreek', 'maccyrillic', 'symbol', 'Devanagari', 'Gurmukhi', 'Gujarati',\r\n   'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese',\r\n   'Burmese', 'Khmer', 'macthai', 'Laotian', 'Georgian', 'Armenian', 'gb-2312-80', \r\n   'Tibetan', 'Mongolian', 'Geez', 'maccenteuro', 'Vietnamese', 'Sindhi'],\r\n  \r\n  // ISO (deprecated)\r\n  ['ascii'],\r\n  \r\n  // windows\r\n  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx\r\n  ['symbol', 'utf16be', 'shift-jis', 'gb18030', 'big5', 'wansung', 'johab', null, null, null, 'utf16be']\r\n];\r\n\r\n// Overrides for Mac scripts by language id.\r\n// See http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\r\nexport const MAC_LANGUAGE_ENCODINGS = {\r\n  15: 'maciceland',\r\n  17: 'macturkish',\r\n  18: 'maccroatian',\r\n  24: 'maccenteuro',\r\n  25: 'maccenteuro',\r\n  26: 'maccenteuro',\r\n  27: 'maccenteuro',\r\n  28: 'maccenteuro',\r\n  30: 'maciceland',\r\n  37: 'macromania',\r\n  38: 'maccenteuro',\r\n  39: 'maccenteuro',\r\n  40: 'maccenteuro',\r\n  143: 'macinuit', // Unsupported by iconv-lite\r\n  146: 'macgaelic' // Unsupported by iconv-lite\r\n};\r\n\r\n// Map of platform ids to BCP-47 language codes.\r\nexport const LANGUAGES = [\r\n  // unicode\r\n  [],\r\n  \r\n  { // macintosh\r\n    0: 'en',        30: 'fo',       60: 'ks',       90: 'rw',\r\n    1: 'fr',        31: 'fa',       61: 'ku',       91: 'rn',\r\n    2: 'de',        32: 'ru',       62: 'sd',       92: 'ny',\r\n    3: 'it',        33: 'zh',       63: 'bo',       93: 'mg',\r\n    4: 'nl',        34: 'nl-BE',    64: 'ne',       94: 'eo',\r\n    5: 'sv',        35: 'ga',       65: 'sa',       128: 'cy',\r\n    6: 'es',        36: 'sq',       66: 'mr',       129: 'eu',\r\n    7: 'da',        37: 'ro',       67: 'bn',       130: 'ca',\r\n    8: 'pt',        38: 'cz',       68: 'as',       131: 'la',\r\n    9: 'no',        39: 'sk',       69: 'gu',       132: 'qu',\r\n    10: 'he',       40: 'si',       70: 'pa',       133: 'gn',\r\n    11: 'ja',       41: 'yi',       71: 'or',       134: 'ay',\r\n    12: 'ar',       42: 'sr',       72: 'ml',       135: 'tt',\r\n    13: 'fi',       43: 'mk',       73: 'kn',       136: 'ug',\r\n    14: 'el',       44: 'bg',       74: 'ta',       137: 'dz',\r\n    15: 'is',       45: 'uk',       75: 'te',       138: 'jv',\r\n    16: 'mt',       46: 'be',       76: 'si',       139: 'su',\r\n    17: 'tr',       47: 'uz',       77: 'my',       140: 'gl',\r\n    18: 'hr',       48: 'kk',       78: 'km',       141: 'af',\r\n    19: 'zh-Hant',  49: 'az-Cyrl',  79: 'lo',       142: 'br',\r\n    20: 'ur',       50: 'az-Arab',  80: 'vi',       143: 'iu',\r\n    21: 'hi',       51: 'hy',       81: 'id',       144: 'gd',\r\n    22: 'th',       52: 'ka',       82: 'tl',       145: 'gv',\r\n    23: 'ko',       53: 'mo',       83: 'ms',       146: 'ga',\r\n    24: 'lt',       54: 'ky',       84: 'ms-Arab',  147: 'to',\r\n    25: 'pl',       55: 'tg',       85: 'am',       148: 'el-polyton',\r\n    26: 'hu',       56: 'tk',       86: 'ti',       149: 'kl',\r\n    27: 'es',       57: 'mn-CN',    87: 'om',       150: 'az',\r\n    28: 'lv',       58: 'mn',       88: 'so',       151: 'nn',\r\n    29: 'se',       59: 'ps',       89: 'sw',\r\n  },\r\n  \r\n  // ISO (deprecated)\r\n  [],\r\n  \r\n  { // windows                                        \r\n    0x0436: 'af',       0x4009: 'en-IN',    0x0487: 'rw',          0x0432: 'tn',       \r\n    0x041C: 'sq',       0x1809: 'en-IE',    0x0441: 'sw',          0x045B: 'si',          \r\n    0x0484: 'gsw',      0x2009: 'en-JM',    0x0457: 'kok',         0x041B: 'sk',          \r\n    0x045E: 'am',       0x4409: 'en-MY',    0x0412: 'ko',          0x0424: 'sl',          \r\n    0x1401: 'ar-DZ',    0x1409: 'en-NZ',    0x0440: 'ky',          0x2C0A: 'es-AR',       \r\n    0x3C01: 'ar-BH',    0x3409: 'en-PH',    0x0454: 'lo',          0x400A: 'es-BO',       \r\n    0x0C01: 'ar',       0x4809: 'en-SG',    0x0426: 'lv',          0x340A: 'es-CL',       \r\n    0x0801: 'ar-IQ',    0x1C09: 'en-ZA',    0x0427: 'lt',          0x240A: 'es-CO',       \r\n    0x2C01: 'ar-JO',    0x2C09: 'en-TT',    0x082E: 'dsb',         0x140A: 'es-CR',       \r\n    0x3401: 'ar-KW',    0x0809: 'en-GB',    0x046E: 'lb',          0x1C0A: 'es-DO',       \r\n    0x3001: 'ar-LB',    0x0409: 'en',       0x042F: 'mk',          0x300A: 'es-EC',       \r\n    0x1001: 'ar-LY',    0x3009: 'en-ZW',    0x083E: 'ms-BN',       0x440A: 'es-SV',       \r\n    0x1801: 'ary',      0x0425: 'et',       0x043E: 'ms',          0x100A: 'es-GT',       \r\n    0x2001: 'ar-OM',    0x0438: 'fo',       0x044C: 'ml',          0x480A: 'es-HN',       \r\n    0x4001: 'ar-QA',    0x0464: 'fil',      0x043A: 'mt',          0x080A: 'es-MX',       \r\n    0x0401: 'ar-SA',    0x040B: 'fi',       0x0481: 'mi',          0x4C0A: 'es-NI',       \r\n    0x2801: 'ar-SY',    0x080C: 'fr-BE',    0x047A: 'arn',         0x180A: 'es-PA',       \r\n    0x1C01: 'aeb',      0x0C0C: 'fr-CA',    0x044E: 'mr',          0x3C0A: 'es-PY',       \r\n    0x3801: 'ar-AE',    0x040C: 'fr',       0x047C: 'moh',         0x280A: 'es-PE',       \r\n    0x2401: 'ar-YE',    0x140C: 'fr-LU',    0x0450: 'mn',          0x500A: 'es-PR',       \r\n    0x042B: 'hy',       0x180C: 'fr-MC',    0x0850: 'mn-CN',       0x0C0A: 'es',          \r\n    0x044D: 'as',       0x100C: 'fr-CH',    0x0461: 'ne',          0x040A: 'es',          \r\n    0x082C: 'az-Cyrl',  0x0462: 'fy',       0x0414: 'nb',          0x540A: 'es-US',       \r\n    0x042C: 'az',       0x0456: 'gl',       0x0814: 'nn',          0x380A: 'es-UY',     \r\n    0x046D: 'ba',       0x0437: 'ka',       0x0482: 'oc',          0x200A: 'es-VE',       \r\n    0x042D: 'eu',       0x0C07: 'de-AT',    0x0448: 'or',          0x081D: 'sv-FI',       \r\n    0x0423: 'be',       0x0407: 'de',       0x0463: 'ps',          0x041D: 'sv',          \r\n    0x0845: 'bn',       0x1407: 'de-LI',    0x0415: 'pl',          0x045A: 'syr',         \r\n    0x0445: 'bn-IN',    0x1007: 'de-LU',    0x0416: 'pt',          0x0428: 'tg',          \r\n    0x201A: 'bs-Cyrl',  0x0807: 'de-CH',    0x0816: 'pt-PT',       0x085F: 'tzm',         \r\n    0x141A: 'bs',       0x0408: 'el',       0x0446: 'pa',          0x0449: 'ta',          \r\n    0x047E: 'br',       0x046F: 'kl',       0x046B: 'qu-BO',       0x0444: 'tt',          \r\n    0x0402: 'bg',       0x0447: 'gu',       0x086B: 'qu-EC',       0x044A: 'te',          \r\n    0x0403: 'ca',       0x0468: 'ha',       0x0C6B: 'qu',          0x041E: 'th',          \r\n    0x0C04: 'zh-HK',    0x040D: 'he',       0x0418: 'ro',          0x0451: 'bo',          \r\n    0x1404: 'zh-MO',    0x0439: 'hi',       0x0417: 'rm',          0x041F: 'tr',          \r\n    0x0804: 'zh',       0x040E: 'hu',       0x0419: 'ru',          0x0442: 'tk',          \r\n    0x1004: 'zh-SG',    0x040F: 'is',       0x243B: 'smn',         0x0480: 'ug',          \r\n    0x0404: 'zh-TW',    0x0470: 'ig',       0x103B: 'smj-NO',      0x0422: 'uk',          \r\n    0x0483: 'co',       0x0421: 'id',       0x143B: 'smj',         0x042E: 'hsb',         \r\n    0x041A: 'hr',       0x045D: 'iu',       0x0C3B: 'se-FI',       0x0420: 'ur',          \r\n    0x101A: 'hr-BA',    0x085D: 'iu-Latn',  0x043B: 'se',          0x0843: 'uz-Cyrl',     \r\n    0x0405: 'cs',       0x083C: 'ga',       0x083B: 'se-SE',       0x0443: 'uz',          \r\n    0x0406: 'da',       0x0434: 'xh',       0x203B: 'sms',         0x042A: 'vi',          \r\n    0x048C: 'prs',      0x0435: 'zu',       0x183B: 'sma-NO',      0x0452: 'cy',          \r\n    0x0465: 'dv',       0x0410: 'it',       0x1C3B: 'sms',         0x0488: 'wo',          \r\n    0x0813: 'nl-BE',    0x0810: 'it-CH',    0x044F: 'sa',          0x0485: 'sah',         \r\n    0x0413: 'nl',       0x0411: 'ja',       0x1C1A: 'sr-Cyrl-BA',  0x0478: 'ii',          \r\n    0x0C09: 'en-AU',    0x044B: 'kn',       0x0C1A: 'sr',          0x046A: 'yo',           \r\n    0x2809: 'en-BZ',    0x043F: 'kk',       0x181A: 'sr-Latn-BA',  \r\n    0x1009: 'en-CA',    0x0453: 'km',       0x081A: 'sr-Latn',     \r\n    0x2409: 'en-029',   0x0486: 'quc',      0x046C: 'nso',         \r\n  }\r\n];\r\n","import r from '@foliojs-fork/restructure';\r\nimport {getEncoding, LANGUAGES} from '../encodings';\r\n\r\nlet NameRecord = new r.Struct({\r\n  platformID: r.uint16,\r\n  encodingID: r.uint16,\r\n  languageID: r.uint16,\r\n  nameID:     r.uint16,\r\n  length:     r.uint16,\r\n  string:     new r.Pointer(r.uint16,\r\n    new r.String('length', t => getEncoding(t.platformID, t.encodingID, t.languageID)),\r\n    { type: 'parent', relativeTo: ctx => ctx.parent.stringOffset, allowNull: false }\r\n  )\r\n});\r\n\r\nlet LangTagRecord = new r.Struct({\r\n  length:  r.uint16,\r\n  tag:     new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {type: 'parent', relativeTo: ctx => ctx.stringOffset})\r\n});\r\n\r\nvar NameTable = new r.VersionedStruct(r.uint16, {\r\n  0: {\r\n    count:          r.uint16,\r\n    stringOffset:   r.uint16,\r\n    records:        new r.Array(NameRecord, 'count')\r\n  },\r\n  1: {\r\n    count:          r.uint16,\r\n    stringOffset:   r.uint16,\r\n    records:        new r.Array(NameRecord, 'count'),\r\n    langTagCount:   r.uint16,\r\n    langTags:       new r.Array(LangTagRecord, 'langTagCount')\r\n  }\r\n});\r\n\r\nexport default NameTable;\r\n\r\nconst NAMES = [\r\n  'copyright',\r\n  'fontFamily',\r\n  'fontSubfamily',\r\n  'uniqueSubfamily',\r\n  'fullName',\r\n  'version',\r\n  'postscriptName', // Note: A font may have only one PostScript name and that name must be ASCII.\r\n  'trademark',\r\n  'manufacturer',\r\n  'designer',\r\n  'description',\r\n  'vendorURL',\r\n  'designerURL',\r\n  'license',\r\n  'licenseURL',\r\n  null, // reserved\r\n  'preferredFamily',\r\n  'preferredSubfamily',\r\n  'compatibleFull',\r\n  'sampleText',\r\n  'postscriptCIDFontName',\r\n  'wwsFamilyName',\r\n  'wwsSubfamilyName'\r\n];\r\n\r\nNameTable.process = function(stream) {\r\n  var records = {};\r\n  for (let record of this.records) {\r\n    // find out what language this is for\r\n    let language = LANGUAGES[record.platformID][record.languageID];\r\n\r\n    if (language == null && this.langTags != null && record.languageID >= 0x8000) {\r\n      language = this.langTags[record.languageID - 0x8000].tag;\r\n    }\r\n\r\n    if (language == null) {\r\n      language = record.platformID + '-' + record.languageID;\r\n    }\r\n\r\n    // if the nameID is >= 256, it is a font feature record (AAT)\r\n    let key = record.nameID >= 256 ? 'fontFeatures' : (NAMES[record.nameID] || record.nameID);\r\n    if (records[key] == null) {\r\n      records[key] = {};\r\n    }\r\n\r\n    let obj = records[key];\r\n    if (record.nameID >= 256) {\r\n      obj = obj[record.nameID] || (obj[record.nameID] = {});\r\n    }\r\n\r\n    if (typeof record.string === 'string' || typeof obj[language] !== 'string') {\r\n      obj[language] = record.string;\r\n    }\r\n  }\r\n\r\n  this.records = records;\r\n};\r\n\r\nNameTable.preEncode = function() {\r\n  if (Array.isArray(this.records)) return;\r\n  this.version = 0;\r\n\r\n  let records = [];\r\n  for (let key in this.records) {\r\n    let val = this.records[key];\r\n    if (key === 'fontFeatures') continue;\r\n\r\n    records.push({\r\n      platformID: 3,\r\n      encodingID: 1,\r\n      languageID: 0x409,\r\n      nameID: NAMES.indexOf(key),\r\n      length: Buffer.byteLength(val.en, 'utf16le'),\r\n      string: val.en\r\n    });\r\n\r\n    if (key === 'postscriptName') {\r\n      records.push({\r\n        platformID: 1,\r\n        encodingID: 0,\r\n        languageID: 0,\r\n        nameID: NAMES.indexOf(key),\r\n        length: val.en.length,\r\n        string: val.en\r\n      });\r\n    }\r\n  }\r\n\r\n  this.records = records;\r\n  this.count = records.length;\r\n  this.stringOffset = NameTable.size(this, null, false);\r\n};\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nvar OS2 = new r.VersionedStruct(r.uint16, {\r\n  header: {\r\n    xAvgCharWidth:          r.int16,   // average weighted advance width of lower case letters and space\r\n    usWeightClass:          r.uint16,  // visual weight of stroke in glyphs\r\n    usWidthClass:           r.uint16,  // relative change from the normal aspect ratio (width to height ratio)\r\n    fsType:                 new r.Bitfield(r.uint16, [ // Indicates font embedding licensing rights\r\n      null, 'noEmbedding', 'viewOnly', 'editable', null,\r\n      null, null, null, 'noSubsetting', 'bitmapOnly'\r\n    ]),\r\n    ySubscriptXSize:        r.int16,   // recommended horizontal size in pixels for subscripts\r\n    ySubscriptYSize:        r.int16,   // recommended vertical size in pixels for subscripts\r\n    ySubscriptXOffset:      r.int16,   // recommended horizontal offset for subscripts\r\n    ySubscriptYOffset:      r.int16,   // recommended vertical offset form the baseline for subscripts\r\n    ySuperscriptXSize:      r.int16,   // recommended horizontal size in pixels for superscripts\r\n    ySuperscriptYSize:      r.int16,   // recommended vertical size in pixels for superscripts\r\n    ySuperscriptXOffset:    r.int16,   // recommended horizontal offset for superscripts\r\n    ySuperscriptYOffset:    r.int16,   // recommended vertical offset from the baseline for superscripts\r\n    yStrikeoutSize:         r.int16,   // width of the strikeout stroke\r\n    yStrikeoutPosition:     r.int16,   // position of the strikeout stroke relative to the baseline\r\n    sFamilyClass:           r.int16,   // classification of font-family design\r\n    panose:                 new r.Array(r.uint8, 10),   // describe the visual characteristics of a given typeface\r\n    ulCharRange:            new r.Array(r.uint32, 4),\r\n    vendorID:               new r.String(4),          // four character identifier for the font vendor\r\n    fsSelection:            new r.Bitfield(r.uint16, [  // bit field containing information about the font\r\n      'italic', 'underscore', 'negative', 'outlined', 'strikeout',\r\n      'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique'\r\n    ]),\r\n    usFirstCharIndex:       r.uint16,  // The minimum Unicode index in this font\r\n    usLastCharIndex:        r.uint16   // The maximum Unicode index in this font\r\n  },\r\n\r\n  // The Apple version of this table ends here, but the Microsoft one continues on...\r\n  0: {},\r\n\r\n  1: {\r\n    typoAscender:       r.int16,\r\n    typoDescender:      r.int16,\r\n    typoLineGap:        r.int16,\r\n    winAscent:          r.uint16,\r\n    winDescent:         r.uint16,\r\n    codePageRange:      new r.Array(r.uint32, 2)\r\n  },\r\n\r\n  2: {\r\n    // these should be common with version 1 somehow\r\n    typoAscender:       r.int16,\r\n    typoDescender:      r.int16,\r\n    typoLineGap:        r.int16,\r\n    winAscent:          r.uint16,\r\n    winDescent:         r.uint16,\r\n    codePageRange:      new r.Array(r.uint32, 2),\r\n\r\n    xHeight:            r.int16,\r\n    capHeight:          r.int16,\r\n    defaultChar:        r.uint16,\r\n    breakChar:          r.uint16,\r\n    maxContent:         r.uint16\r\n  },\r\n\r\n  5: {\r\n    typoAscender:       r.int16,\r\n    typoDescender:      r.int16,\r\n    typoLineGap:        r.int16,\r\n    winAscent:          r.uint16,\r\n    winDescent:         r.uint16,\r\n    codePageRange:      new r.Array(r.uint32, 2),\r\n\r\n    xHeight:            r.int16,\r\n    capHeight:          r.int16,\r\n    defaultChar:        r.uint16,\r\n    breakChar:          r.uint16,\r\n    maxContent:         r.uint16,\r\n\r\n    usLowerOpticalPointSize: r.uint16,\r\n    usUpperOpticalPointSize: r.uint16\r\n  }\r\n});\r\n\r\nlet versions = OS2.versions;\r\nversions[3] = versions[4] = versions[2];\r\n\r\nexport default OS2;\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// PostScript information\r\nexport default new r.VersionedStruct(r.fixed32, {\r\n  header: { // these fields exist at the top of all versions\r\n    italicAngle:        r.fixed32, // Italic angle in counter-clockwise degrees from the vertical.\r\n    underlinePosition:  r.int16,   // Suggested distance of the top of the underline from the baseline\r\n    underlineThickness: r.int16,   // Suggested values for the underline thickness\r\n    isFixedPitch:       r.uint32,  // Whether the font is monospaced\r\n    minMemType42:       r.uint32,  // Minimum memory usage when a TrueType font is downloaded as a Type 42 font\r\n    maxMemType42:       r.uint32,  // Maximum memory usage when a TrueType font is downloaded as a Type 42 font\r\n    minMemType1:        r.uint32,  // Minimum memory usage when a TrueType font is downloaded as a Type 1 font\r\n    maxMemType1:        r.uint32   // Maximum memory usage when a TrueType font is downloaded as a Type 1 font\r\n  },\r\n\r\n  1: {}, // version 1 has no additional fields\r\n\r\n  2: {\r\n    numberOfGlyphs: r.uint16,\r\n    glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),\r\n    names:          new r.Array(new r.String(r.uint8))\r\n  },\r\n\r\n  2.5: {\r\n    numberOfGlyphs: r.uint16,\r\n    offsets:        new r.Array(r.uint8, 'numberOfGlyphs')\r\n  },\r\n\r\n  3: {}, // version 3 has no additional fields\r\n\r\n  4: {\r\n    map: new r.Array(r.uint32, t => t.parent.maxp.numGlyphs)\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// An array of predefined values accessible by instructions\r\nexport default new r.Struct({\r\n  controlValues: new r.Array(r.int16)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// A list of instructions that are executed once when a font is first used.\r\n// These instructions are known as the font program. The main use of this table\r\n// is for the definition of functions that are used in many different glyph programs.\r\nexport default new r.Struct({\r\n  instructions: new r.Array(r.uint8)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet loca = new r.VersionedStruct('head.indexToLocFormat', {\r\n  0: {\r\n    offsets: new r.Array(r.uint16)\r\n  },\r\n  1: {\r\n    offsets: new r.Array(r.uint32)\r\n  }\r\n});\r\n\r\nloca.process = function() {\r\n  if (this.version === 0) {\r\n    for (let i = 0; i < this.offsets.length; i++) {\r\n      this.offsets[i] <<= 1;\r\n    }\r\n  }\r\n};\r\n\r\nloca.preEncode = function() {\r\n  if (this.version === 0) {\r\n    for (let i = 0; i < this.offsets.length; i++) {\r\n      this.offsets[i] >>>= 1;\r\n    }\r\n  }\r\n};\r\n\r\nexport default loca;\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// Set of instructions executed whenever the point size or font transformation change\r\nexport default new r.Struct({\r\n  controlValueProgram: new r.Array(r.uint8)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// only used for encoding\r\nexport default new r.Array(new r.Buffer);\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nexport default class CFFIndex {\r\n  constructor(type) {\r\n    this.type = type;\r\n  }\r\n\r\n  getCFFVersion(ctx) {\r\n    while (ctx && !ctx.hdrSize) {\r\n      ctx = ctx.parent;\r\n    }\r\n\r\n    return ctx ? ctx.version : -1;\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    let version = this.getCFFVersion(parent);\r\n    let count = version >= 2\r\n      ? stream.readUInt32BE()\r\n      : stream.readUInt16BE();\r\n\r\n    if (count === 0) {\r\n      return [];\r\n    }\r\n\r\n    let offSize = stream.readUInt8();\r\n    let offsetType;\r\n    if (offSize === 1) {\r\n      offsetType = r.uint8;\r\n    } else if (offSize === 2) {\r\n      offsetType = r.uint16;\r\n    } else if (offSize === 3) {\r\n      offsetType = r.uint24;\r\n    } else if (offSize === 4) {\r\n      offsetType = r.uint32;\r\n    } else {\r\n      throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream.pos}`);\r\n    }\r\n\r\n    let ret = [];\r\n    let startPos = stream.pos + ((count + 1) * offSize) - 1;\r\n\r\n    let start = offsetType.decode(stream);\r\n    for (let i = 0; i < count; i++) {\r\n      let end = offsetType.decode(stream);\r\n\r\n      if (this.type != null) {\r\n        let pos = stream.pos;\r\n        stream.pos = startPos + start;\r\n\r\n        parent.length = end - start;\r\n        ret.push(this.type.decode(stream, parent));\r\n        stream.pos = pos;\r\n      } else {\r\n        ret.push({\r\n          offset: startPos + start,\r\n          length: end - start\r\n        });\r\n      }\r\n\r\n      start = end;\r\n    }\r\n\r\n    stream.pos = startPos + start;\r\n    return ret;\r\n  }\r\n\r\n  size(arr, parent) {\r\n    let size = 2;\r\n    if (arr.length === 0) {\r\n      return size;\r\n    }\r\n\r\n    let type = this.type || new r.Buffer;\r\n\r\n    // find maximum offset to detminine offset type\r\n    let offset = 1;\r\n    for (let i = 0; i < arr.length; i++) {\r\n      let item = arr[i];\r\n      offset += type.size(item, parent);\r\n    }\r\n\r\n    let offsetType;\r\n    if (offset <= 0xff) {\r\n      offsetType = r.uint8;\r\n    } else if (offset <= 0xffff) {\r\n      offsetType = r.uint16;\r\n    } else if (offset <= 0xffffff) {\r\n      offsetType = r.uint24;\r\n    } else if (offset <= 0xffffffff) {\r\n      offsetType = r.uint32;\r\n    } else {\r\n      throw new Error(\"Bad offset in CFFIndex\");\r\n    }\r\n\r\n    size += 1 + offsetType.size() * (arr.length + 1);\r\n    size += offset - 1;\r\n\r\n    return size;\r\n  }\r\n\r\n  encode(stream, arr, parent) {\r\n    stream.writeUInt16BE(arr.length);\r\n    if (arr.length === 0) {\r\n      return;\r\n    }\r\n\r\n    let type = this.type || new r.Buffer;\r\n\r\n    // find maximum offset to detminine offset type\r\n    let sizes = [];\r\n    let offset = 1;\r\n    for (let item of arr) {\r\n      let s = type.size(item, parent);\r\n      sizes.push(s);\r\n      offset += s;\r\n    }\r\n\r\n    let offsetType;\r\n    if (offset <= 0xff) {\r\n      offsetType = r.uint8;\r\n    } else if (offset <= 0xffff) {\r\n      offsetType = r.uint16;\r\n    } else if (offset <= 0xffffff) {\r\n      offsetType = r.uint24;\r\n    } else if (offset <= 0xffffffff) {\r\n      offsetType = r.uint32;\r\n    } else {\r\n      throw new Error(\"Bad offset in CFFIndex\");\r\n    }\r\n\r\n    // write offset size\r\n    stream.writeUInt8(offsetType.size());\r\n\r\n    // write elements\r\n    offset = 1;\r\n    offsetType.encode(stream, offset);\r\n\r\n    for (let size of sizes) {\r\n      offset += size;\r\n      offsetType.encode(stream, offset);\r\n    }\r\n\r\n    for (let item of arr) {\r\n      type.encode(stream, item, parent);\r\n    }\r\n\r\n    return;\r\n  }\r\n}\r\n","const FLOAT_EOF = 0xf;\r\nconst FLOAT_LOOKUP = [\r\n  '0', '1', '2', '3', '4', '5', '6', '7',\r\n  '8', '9', '.', 'E', 'E-', null, '-'\r\n];\r\n\r\nconst FLOAT_ENCODE_LOOKUP = {\r\n  '.': 10,\r\n  'E': 11,\r\n  'E-': 12,\r\n  '-': 14\r\n};\r\n\r\nexport default class CFFOperand {\r\n  static decode(stream, value) {\r\n    if (32 <= value && value <= 246) {\r\n      return value - 139;\r\n    }\r\n\r\n    if (247 <= value && value <= 250) {\r\n      return (value - 247) * 256 + stream.readUInt8() + 108;\r\n    }\r\n\r\n    if (251 <= value && value <= 254) {\r\n      return -(value - 251) * 256 - stream.readUInt8() - 108;\r\n    }\r\n\r\n    if (value === 28) {\r\n      return stream.readInt16BE();\r\n    }\r\n\r\n    if (value === 29) {\r\n      return stream.readInt32BE();\r\n    }\r\n\r\n    if (value === 30) {\r\n      let str = '';\r\n      while (true) {\r\n        let b = stream.readUInt8();\r\n\r\n        let n1 = b >> 4;\r\n        if (n1 === FLOAT_EOF) { break; }\r\n        str += FLOAT_LOOKUP[n1];\r\n\r\n        let n2 = b & 15;\r\n        if (n2 === FLOAT_EOF) { break; }\r\n        str += FLOAT_LOOKUP[n2];\r\n      }\r\n\r\n      return parseFloat(str);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  static size(value) {\r\n    // if the value needs to be forced to the largest size (32 bit)\r\n    // e.g. for unknown pointers, set to 32768\r\n    if (value.forceLarge) {\r\n      value = 32768;\r\n    }\r\n\r\n    if ((value | 0) !== value) { // floating point\r\n      let str = '' + value;\r\n      return 1 + Math.ceil((str.length + 1) / 2);\r\n\r\n    } else if (-107 <= value && value <= 107) {\r\n      return 1;\r\n\r\n    } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {\r\n      return 2;\r\n\r\n    } else if (-32768 <= value && value <= 32767) {\r\n      return 3;\r\n\r\n    } else {\r\n      return 5;\r\n    }\r\n  }\r\n\r\n  static encode(stream, value) {\r\n    // if the value needs to be forced to the largest size (32 bit)\r\n    // e.g. for unknown pointers, save the old value and set to 32768\r\n    let val = Number(value);\r\n\r\n    if (value.forceLarge) {\r\n      stream.writeUInt8(29);\r\n      return stream.writeInt32BE(val);\r\n\r\n    } else if ((val | 0) !== val) { // floating point\r\n      stream.writeUInt8(30);\r\n\r\n      let str = '' + val;\r\n      for (let i = 0; i < str.length; i += 2) {\r\n        let c1 = str[i];\r\n        let n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;\r\n\r\n        if (i === str.length - 1) {\r\n          var n2 = FLOAT_EOF;\r\n        } else {\r\n          let c2 = str[i + 1];\r\n          var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;\r\n        }\r\n\r\n        stream.writeUInt8((n1 << 4) | (n2 & 15));\r\n      }\r\n\r\n      if (n2 !== FLOAT_EOF) {\r\n        return stream.writeUInt8((FLOAT_EOF << 4));\r\n      }\r\n\r\n    } else if (-107 <= val && val <= 107) {\r\n      return stream.writeUInt8(val + 139);\r\n\r\n    } else if (108 <= val && val <= 1131) {\r\n      val -= 108;\r\n      stream.writeUInt8((val >> 8) + 247);\r\n      return stream.writeUInt8(val & 0xff);\r\n\r\n    } else if (-1131 <= val && val <= -108) {\r\n      val = -val - 108;\r\n      stream.writeUInt8((val >> 8) + 251);\r\n      return stream.writeUInt8(val & 0xff);\r\n\r\n    } else if (-32768 <= val && val <= 32767) {\r\n      stream.writeUInt8(28);\r\n      return stream.writeInt16BE(val);\r\n\r\n    } else {\r\n      stream.writeUInt8(29);\r\n      return stream.writeInt32BE(val);\r\n    }\r\n  }\r\n}\r\n","import isEqual from 'deep-equal';\r\nimport r from '@foliojs-fork/restructure';\r\nimport CFFOperand from './CFFOperand';\r\nimport { PropertyDescriptor } from '@foliojs-fork/restructure/src/utils';\r\n\r\nexport default class CFFDict {\r\n  constructor(ops = []) {\r\n    this.ops = ops;\r\n    this.fields = {};\r\n    for (let field of ops) {\r\n      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];\r\n      this.fields[key] = field;\r\n    }\r\n  }\r\n\r\n  decodeOperands(type, stream, ret, operands) {\r\n    if (Array.isArray(type)) {\r\n      return operands.map((op, i) => this.decodeOperands(type[i], stream, ret, [op]));\r\n    } else if (type.decode != null) {\r\n      return type.decode(stream, ret, operands);\r\n    } else {\r\n      switch (type) {\r\n        case 'number':\r\n        case 'offset':\r\n        case 'sid':\r\n          return operands[0];\r\n        case 'boolean':\r\n          return !!operands[0];\r\n        default:\r\n          return operands;\r\n      }\r\n    }\r\n  }\r\n\r\n  encodeOperands(type, stream, ctx, operands) {\r\n    if (Array.isArray(type)) {\r\n      return operands.map((op, i) => this.encodeOperands(type[i], stream, ctx, op)[0]);\r\n    } else if (type.encode != null) {\r\n      return type.encode(stream, operands, ctx);\r\n    } else if (typeof operands === 'number') {\r\n      return [operands];\r\n    } else if (typeof operands === 'boolean') {\r\n      return [+operands];\r\n    } else if (Array.isArray(operands)) {\r\n      return operands;\r\n    } else {\r\n      return [operands];\r\n    }\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    let end = stream.pos + parent.length;\r\n    let ret = {};\r\n    let operands = [];\r\n\r\n    // define hidden properties\r\n    Object.defineProperties(ret, {\r\n      parent:         { value: parent },\r\n      _startOffset:   { value: stream.pos }\r\n    });\r\n\r\n    // fill in defaults\r\n    for (let key in this.fields) {\r\n      let field = this.fields[key];\r\n      ret[field[1]] = field[3];\r\n    }\r\n\r\n    while (stream.pos < end) {\r\n      let b = stream.readUInt8();\r\n      if (b < 28) {\r\n        if (b === 12) {\r\n          b = (b << 8) | stream.readUInt8();\r\n        }\r\n\r\n        let field = this.fields[b];\r\n        if (!field) {\r\n          throw new Error(`Unknown operator ${b}`);\r\n        }\r\n\r\n        let val = this.decodeOperands(field[2], stream, ret, operands);\r\n        if (val != null) {\r\n          if (val instanceof PropertyDescriptor) {\r\n            Object.defineProperty(ret, field[1], val);\r\n          } else {\r\n            ret[field[1]] = val;\r\n          }\r\n        }\r\n\r\n        operands = [];\r\n      } else {\r\n        operands.push(CFFOperand.decode(stream, b));\r\n      }\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  size(dict, parent, includePointers = true) {\r\n    let ctx = {\r\n      parent,\r\n      val: dict,\r\n      pointerSize: 0,\r\n      startOffset: parent.startOffset || 0\r\n    };\r\n\r\n    let len = 0;\r\n\r\n    for (let k in this.fields) {\r\n      let field = this.fields[k];\r\n      let val = dict[field[1]];\r\n      if (val == null || isEqual(val, field[3])) {\r\n        continue;\r\n      }\r\n\r\n      let operands = this.encodeOperands(field[2], null, ctx, val);\r\n      for (let op of operands) {\r\n        len += CFFOperand.size(op);\r\n      }\r\n\r\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\r\n      len += key.length;\r\n    }\r\n\r\n    if (includePointers) {\r\n      len += ctx.pointerSize;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n  encode(stream, dict, parent) {\r\n    let ctx = {\r\n      pointers: [],\r\n      startOffset: stream.pos,\r\n      parent,\r\n      val: dict,\r\n      pointerSize: 0\r\n    };\r\n\r\n    ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);\r\n\r\n    for (let field of this.ops) {\r\n      let val = dict[field[1]];\r\n      if (val == null || isEqual(val, field[3])) {\r\n        continue;\r\n      }\r\n\r\n      let operands = this.encodeOperands(field[2], stream, ctx, val);\r\n      for (let op of operands) {\r\n        CFFOperand.encode(stream, op);\r\n      }\r\n\r\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\r\n      for (let op of key) {\r\n        stream.writeUInt8(op);\r\n      }\r\n    }\r\n\r\n    let i = 0;\r\n    while (i < ctx.pointers.length) {\r\n      let ptr = ctx.pointers[i++];\r\n      ptr.type.encode(stream, ptr.val, ptr.parent);\r\n    }\r\n\r\n    return;\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nexport default class CFFPointer extends r.Pointer {\r\n  constructor(type, options = {}) {\r\n    if (options.type == null) {\r\n      options.type = 'global';\r\n    }\r\n\r\n    super(null, type, options);\r\n  }\r\n\r\n  decode(stream, parent, operands) {\r\n    this.offsetType = {\r\n      decode: () => operands[0]\r\n    };\r\n\r\n    return super.decode(stream, parent, operands);\r\n  }\r\n\r\n  encode(stream, value, ctx) {\r\n    if (!stream) {\r\n      // compute the size (so ctx.pointerSize is correct)\r\n      this.offsetType = {\r\n        size: () => 0\r\n      };\r\n\r\n      this.size(value, ctx);\r\n      return [new Ptr(0)];\r\n    }\r\n\r\n    let ptr = null;\r\n    this.offsetType = {\r\n      encode: (stream, val) => ptr = val\r\n    };\r\n\r\n    super.encode(stream, value, ctx);\r\n    return [new Ptr(ptr)];\r\n  }\r\n}\r\n\r\nclass Ptr {\r\n  constructor(val) {\r\n    this.val = val;\r\n    this.forceLarge = true;\r\n  }\r\n\r\n  valueOf() {\r\n    return this.val;\r\n  }\r\n}\r\n","import CFFDict from './CFFDict';\r\nimport CFFIndex from './CFFIndex';\r\nimport CFFPointer from './CFFPointer';\r\n\r\nclass CFFBlendOp {\r\n  static decode(stream, parent, operands) {\r\n    let numBlends = operands.pop();\r\n\r\n    // TODO: actually blend. For now just consume the deltas\r\n    // since we don't use any of the values anyway.\r\n    while (operands.length > numBlends) {\r\n      operands.pop();\r\n    }\r\n  }\r\n}\r\n\r\nexport default new CFFDict([\r\n  // key       name                    type                                          default\r\n  [6,         'BlueValues',           'delta',                                       null],\r\n  [7,         'OtherBlues',           'delta',                                       null],\r\n  [8,         'FamilyBlues',          'delta',                                       null],\r\n  [9,         'FamilyOtherBlues',     'delta',                                       null],\r\n  [[12, 9],   'BlueScale',            'number',                                      0.039625],\r\n  [[12, 10],  'BlueShift',            'number',                                      7],\r\n  [[12, 11],  'BlueFuzz',             'number',                                      1],\r\n  [10,        'StdHW',                'number',                                      null],\r\n  [11,        'StdVW',                'number',                                      null],\r\n  [[12, 12],  'StemSnapH',            'delta',                                       null],\r\n  [[12, 13],  'StemSnapV',            'delta',                                       null],\r\n  [[12, 14],  'ForceBold',            'boolean',                                     false],\r\n  [[12, 17],  'LanguageGroup',        'number',                                      0],\r\n  [[12, 18],  'ExpansionFactor',      'number',                                      0.06],\r\n  [[12, 19],  'initialRandomSeed',    'number',                                      0],\r\n  [20,        'defaultWidthX',        'number',                                      0],\r\n  [21,        'nominalWidthX',        'number',                                      0],\r\n  [22,        'vsindex',              'number',                                      0],\r\n  [23,        'blend',                CFFBlendOp,                                    null],\r\n  [19,        'Subrs',                new CFFPointer(new CFFIndex, {type: 'local'}), null]\r\n]);\r\n","// Automatically generated from Appendix A of the CFF specification; do\r\n// not edit. Length should be 391.\r\nexport default [\r\n  \".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\",\r\n  \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\",\r\n  \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\",\r\n  \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\",\r\n  \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\",\r\n  \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\",\r\n  \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\",\r\n  \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\",\r\n  \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\",\r\n  \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\",\r\n  \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\",\r\n  \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\",\r\n  \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\",\r\n  \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\",\r\n  \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\",\r\n  \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\",\r\n  \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\",\r\n  \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\",\r\n  \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\",\r\n  \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\",\r\n  \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\",\r\n  \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\",\r\n  \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\",\r\n  \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\",\r\n  \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\",\r\n  \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\",\r\n  \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\",\r\n  \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\",\r\n  \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\",\r\n  \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\",\r\n  \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\",\r\n  \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\",\r\n  \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\",\r\n  \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\",\r\n  \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\",\r\n  \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\",\r\n  \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\",\r\n  \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\",\r\n  \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\",\r\n  \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\",\r\n  \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\",\r\n  \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\",\r\n  \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\",\r\n  \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\",\r\n  \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\",\r\n  \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\",\r\n  \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\",\r\n  \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\",\r\n  \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\",\r\n  \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\",\r\n  \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\",\r\n  \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\",\r\n  \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\",\r\n  \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\",\r\n  \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\",\r\n  \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\",\r\n  \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\",\r\n  \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\",\r\n  \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\",\r\n  \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\",\r\n  \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\",\r\n  \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\",\r\n  \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\",\r\n  \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\",\r\n  \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\",\r\n  \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\",\r\n  \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"\r\n];\r\n","export let StandardEncoding = [\r\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\r\n  '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\r\n  'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\r\n  'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\r\n  'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\r\n  'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\r\n  'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\r\n  'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\r\n  'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\r\n  'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\r\n  'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\r\n  'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\r\n  'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\r\n  'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\r\n  '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\r\n  'lslash', 'oslash', 'oe', 'germandbls'\r\n];\r\n\r\nexport let ExpertEncoding = [\r\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\r\n  '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\r\n  'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\r\n  'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\r\n  'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\r\n  'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\r\n  'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\r\n  'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\r\n  'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\r\n  'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\r\n  'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\r\n  'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\r\n  'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\r\n  'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\r\n  '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\r\n  'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\r\n  '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\r\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\r\n  'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\r\n  'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\r\n  'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\r\n  'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\r\n  'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\r\n  'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\r\n  'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'\r\n];\r\n","export let ISOAdobeCharset = [\r\n  '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar',\r\n  'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright',\r\n  'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero',\r\n  'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',\r\n  'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question',\r\n  'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\r\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\r\n  'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\r\n  'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\r\n  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\r\n  'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent',\r\n  'sterling', 'fraction', 'yen', 'florin', 'section', 'currency',\r\n  'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft',\r\n  'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl',\r\n  'periodcentered', 'paragraph', 'bullet', 'quotesinglbase',\r\n  'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis',\r\n  'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde',\r\n  'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla',\r\n  'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine',\r\n  'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash',\r\n  'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\r\n  'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter',\r\n  'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior',\r\n  'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\r\n  'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde',\r\n  'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute',\r\n  'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\r\n  'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex',\r\n  'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute',\r\n  'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla',\r\n  'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex',\r\n  'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis',\r\n  'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis',\r\n  'ugrave', 'yacute', 'ydieresis', 'zcaron'\r\n];\r\n\r\nexport let ExpertCharset = [\r\n  '.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle',\r\n  'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior',\r\n  'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma',\r\n  'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle',\r\n  'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle',\r\n  'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle',\r\n  'colon', 'semicolon', 'commasuperior', 'threequartersemdash',\r\n  'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior',\r\n  'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\r\n  'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior',\r\n  'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior',\r\n  'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall',\r\n  'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall',\r\n  'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall',\r\n  'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall',\r\n  'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary',\r\n  'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle',\r\n  'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\r\n  'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall',\r\n  'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall',\r\n  'Cedillasmall', 'onequarter', 'onehalf', 'threequarters',\r\n  'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths',\r\n  'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior',\r\n  'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\r\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\r\n  'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior',\r\n  'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior',\r\n  'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior',\r\n  'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall',\r\n  'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall',\r\n  'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall',\r\n  'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\r\n  'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall',\r\n  'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall',\r\n  'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\r\n  'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall',\r\n  'Ydieresissmall'\r\n];\r\n\r\nexport let ExpertSubsetCharset = [\r\n  '.notdef', 'space', 'dollaroldstyle', 'dollarsuperior',\r\n  'parenleftsuperior', 'parenrightsuperior', 'twodotenleader',\r\n  'onedotenleader', 'comma', 'hyphen', 'period', 'fraction',\r\n  'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\r\n  'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle',\r\n  'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior',\r\n  'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior',\r\n  'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\r\n  'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior',\r\n  'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior',\r\n  'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted',\r\n  'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter',\r\n  'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths',\r\n  'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior',\r\n  'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\r\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\r\n  'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior',\r\n  'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior',\r\n  'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior',\r\n  'periodinferior', 'commainferior'\r\n];\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n//########################\r\n// Scripts and Languages #\r\n//########################\r\n\r\nlet LangSysTable = new r.Struct({\r\n  reserved:         new r.Reserved(r.uint16),\r\n  reqFeatureIndex:  r.uint16,\r\n  featureCount:     r.uint16,\r\n  featureIndexes:   new r.Array(r.uint16, 'featureCount')\r\n});\r\n\r\nlet LangSysRecord = new r.Struct({\r\n  tag:      new r.String(4),\r\n  langSys:  new r.Pointer(r.uint16, LangSysTable, { type: 'parent' })\r\n});\r\n\r\nlet Script = new r.Struct({\r\n  defaultLangSys: new r.Pointer(r.uint16, LangSysTable),\r\n  count:          r.uint16,\r\n  langSysRecords: new r.Array(LangSysRecord, 'count')\r\n});\r\n\r\nlet ScriptRecord = new r.Struct({\r\n  tag:    new r.String(4),\r\n  script: new r.Pointer(r.uint16, Script, { type: 'parent' })\r\n});\r\n\r\nexport let ScriptList = new r.Array(ScriptRecord, r.uint16);\r\n\r\n//#######################\r\n// Features and Lookups #\r\n//#######################\r\n\r\nexport let Feature = new r.Struct({\r\n  featureParams:      r.uint16, // pointer\r\n  lookupCount:        r.uint16,\r\n  lookupListIndexes:  new r.Array(r.uint16, 'lookupCount')\r\n});\r\n\r\nlet FeatureRecord = new r.Struct({\r\n  tag:      new r.String(4),\r\n  feature:  new r.Pointer(r.uint16, Feature, { type: 'parent' })\r\n});\r\n\r\nexport let FeatureList = new r.Array(FeatureRecord, r.uint16);\r\n\r\nlet LookupFlags = new r.Struct({\r\n  markAttachmentType: r.uint8,\r\n  flags: new r.Bitfield(r.uint8, [\r\n    'rightToLeft', 'ignoreBaseGlyphs', 'ignoreLigatures',\r\n    'ignoreMarks', 'useMarkFilteringSet'\r\n  ])\r\n});\r\n\r\nexport function LookupList(SubTable) {\r\n  let Lookup = new r.Struct({\r\n    lookupType:         r.uint16,\r\n    flags:              LookupFlags,\r\n    subTableCount:      r.uint16,\r\n    subTables:          new r.Array(new r.Pointer(r.uint16, SubTable), 'subTableCount'),\r\n    markFilteringSet:   new r.Optional(r.uint16, t => t.flags.flags.useMarkFilteringSet)\r\n  });\r\n\r\n  return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);\r\n}\r\n\r\n//#################\r\n// Coverage Table #\r\n//#################\r\n\r\nlet RangeRecord = new r.Struct({\r\n  start:              r.uint16,\r\n  end:                r.uint16,\r\n  startCoverageIndex: r.uint16\r\n});\r\n\r\nexport let Coverage = new r.VersionedStruct(r.uint16, {\r\n  1: {\r\n    glyphCount:   r.uint16,\r\n    glyphs:       new r.Array(r.uint16, 'glyphCount')\r\n  },\r\n  2: {\r\n    rangeCount:   r.uint16,\r\n    rangeRecords: new r.Array(RangeRecord, 'rangeCount')\r\n  }\r\n});\r\n\r\n//#########################\r\n// Class Definition Table #\r\n//#########################\r\n\r\nlet ClassRangeRecord = new r.Struct({\r\n  start:  r.uint16,\r\n  end:    r.uint16,\r\n  class:  r.uint16\r\n});\r\n\r\nexport let ClassDef = new r.VersionedStruct(r.uint16, {\r\n  1: { // Class array\r\n    startGlyph:       r.uint16,\r\n    glyphCount:       r.uint16,\r\n    classValueArray:  new r.Array(r.uint16, 'glyphCount')\r\n  },\r\n  2: { // Class ranges\r\n    classRangeCount:  r.uint16,\r\n    classRangeRecord: new r.Array(ClassRangeRecord, 'classRangeCount')\r\n  }\r\n});\r\n\r\n//###############\r\n// Device Table #\r\n//###############\r\n\r\nexport let Device = new r.Struct({\r\n  a: r.uint16, // startSize for hinting Device, outerIndex for VariationIndex\r\n  b: r.uint16, // endSize for Device, innerIndex for VariationIndex\r\n  deltaFormat: r.uint16\r\n});\r\n\r\n//#############################################\r\n// Contextual Substitution/Positioning Tables #\r\n//#############################################\r\n\r\nlet LookupRecord = new r.Struct({\r\n  sequenceIndex:      r.uint16,\r\n  lookupListIndex:    r.uint16\r\n});\r\n\r\nlet Rule = new r.Struct({\r\n  glyphCount:     r.uint16,\r\n  lookupCount:    r.uint16,\r\n  input:          new r.Array(r.uint16, t => t.glyphCount - 1),\r\n  lookupRecords:  new r.Array(LookupRecord, 'lookupCount')\r\n});\r\n\r\nlet RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);\r\n\r\nlet ClassRule = new r.Struct({\r\n  glyphCount:     r.uint16,\r\n  lookupCount:    r.uint16,\r\n  classes:        new r.Array(r.uint16, t => t.glyphCount - 1),\r\n  lookupRecords:  new r.Array(LookupRecord, 'lookupCount')\r\n});\r\n\r\nlet ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);\r\n\r\nexport let Context = new r.VersionedStruct(r.uint16, {\r\n  1: { // Simple context\r\n    coverage:      new r.Pointer(r.uint16, Coverage),\r\n    ruleSetCount:  r.uint16,\r\n    ruleSets:      new r.Array(new r.Pointer(r.uint16, RuleSet), 'ruleSetCount')\r\n  },\r\n  2: { // Class-based context\r\n    coverage:      new r.Pointer(r.uint16, Coverage),\r\n    classDef:      new r.Pointer(r.uint16, ClassDef),\r\n    classSetCnt:   r.uint16,\r\n    classSet:      new r.Array(new r.Pointer(r.uint16, ClassSet), 'classSetCnt')\r\n  },\r\n  3: {\r\n    glyphCount:    r.uint16,\r\n    lookupCount:   r.uint16,\r\n    coverages:     new r.Array(new r.Pointer(r.uint16, Coverage), 'glyphCount'),\r\n    lookupRecords: new r.Array(LookupRecord, 'lookupCount')\r\n  }\r\n});\r\n\r\n//######################################################\r\n// Chaining Contextual Substitution/Positioning Tables #\r\n//######################################################\r\n\r\nlet ChainRule = new r.Struct({\r\n  backtrackGlyphCount:  r.uint16,\r\n  backtrack:            new r.Array(r.uint16, 'backtrackGlyphCount'),\r\n  inputGlyphCount:      r.uint16,\r\n  input:                new r.Array(r.uint16, t => t.inputGlyphCount - 1),\r\n  lookaheadGlyphCount:  r.uint16,\r\n  lookahead:            new r.Array(r.uint16, 'lookaheadGlyphCount'),\r\n  lookupCount:          r.uint16,\r\n  lookupRecords:        new r.Array(LookupRecord, 'lookupCount')\r\n});\r\n\r\nlet ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);\r\n\r\nexport let ChainingContext = new r.VersionedStruct(r.uint16, {\r\n  1: { // Simple context glyph substitution\r\n    coverage:           new r.Pointer(r.uint16, Coverage),\r\n    chainCount:         r.uint16,\r\n    chainRuleSets:      new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\r\n  },\r\n\r\n  2: { // Class-based chaining context\r\n    coverage:           new r.Pointer(r.uint16, Coverage),\r\n    backtrackClassDef:  new r.Pointer(r.uint16, ClassDef),\r\n    inputClassDef:      new r.Pointer(r.uint16, ClassDef),\r\n    lookaheadClassDef:  new r.Pointer(r.uint16, ClassDef),\r\n    chainCount:         r.uint16,\r\n    chainClassSet:      new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\r\n  },\r\n\r\n  3: { // Coverage-based chaining context\r\n    backtrackGlyphCount:    r.uint16,\r\n    backtrackCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\r\n    inputGlyphCount:        r.uint16,\r\n    inputCoverage:          new r.Array(new r.Pointer(r.uint16, Coverage), 'inputGlyphCount'),\r\n    lookaheadGlyphCount:    r.uint16,\r\n    lookaheadCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\r\n    lookupCount:            r.uint16,\r\n    lookupRecords:          new r.Array(LookupRecord, 'lookupCount')\r\n  }\r\n});\r\n","import {Feature} from './opentype';\r\nimport r from '@foliojs-fork/restructure';\r\n\r\n/*******************\r\n * Variation Store *\r\n *******************/\r\n\r\nlet F2DOT14 = new r.Fixed(16, 'BE', 14);\r\nlet RegionAxisCoordinates = new r.Struct({\r\n  startCoord: F2DOT14,\r\n  peakCoord: F2DOT14,\r\n  endCoord: F2DOT14\r\n});\r\n\r\nlet VariationRegionList = new r.Struct({\r\n  axisCount: r.uint16,\r\n  regionCount: r.uint16,\r\n  variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, 'axisCount'), 'regionCount')\r\n});\r\n\r\nlet DeltaSet = new r.Struct({\r\n  shortDeltas: new r.Array(r.int16, t => t.parent.shortDeltaCount),\r\n  regionDeltas: new r.Array(r.int8, t => t.parent.regionIndexCount - t.parent.shortDeltaCount),\r\n  deltas: t => t.shortDeltas.concat(t.regionDeltas)\r\n});\r\n\r\nlet ItemVariationData = new r.Struct({\r\n  itemCount: r.uint16,\r\n  shortDeltaCount: r.uint16,\r\n  regionIndexCount: r.uint16,\r\n  regionIndexes: new r.Array(r.uint16, 'regionIndexCount'),\r\n  deltaSets: new r.Array(DeltaSet, 'itemCount')\r\n});\r\n\r\nexport let ItemVariationStore = new r.Struct({\r\n  format: r.uint16,\r\n  variationRegionList: new r.Pointer(r.uint32, VariationRegionList),\r\n  variationDataCount: r.uint16,\r\n  itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), 'variationDataCount')\r\n});\r\n\r\n/**********************\r\n * Feature Variations *\r\n **********************/\r\n\r\nlet ConditionTable = new r.VersionedStruct(r.uint16, {\r\n  1: {\r\n    axisIndex: r.uint16,\r\n    axisIndex: r.uint16,\r\n    filterRangeMinValue: F2DOT14,\r\n    filterRangeMaxValue: F2DOT14\r\n  }\r\n});\r\n\r\nlet ConditionSet = new r.Struct({\r\n  conditionCount: r.uint16,\r\n  conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), 'conditionCount')\r\n});\r\n\r\nlet FeatureTableSubstitutionRecord = new r.Struct({\r\n  featureIndex: r.uint16,\r\n  alternateFeatureTable: new r.Pointer(r.uint32, Feature, {type: 'parent'})\r\n});\r\n\r\nlet FeatureTableSubstitution = new r.Struct({\r\n  version: r.fixed32,\r\n  substitutionCount: r.uint16,\r\n  substitutions: new r.Array(FeatureTableSubstitutionRecord, 'substitutionCount')\r\n});\r\n\r\nlet FeatureVariationRecord = new r.Struct({\r\n  conditionSet: new r.Pointer(r.uint32, ConditionSet, {type: 'parent'}),\r\n  featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, {type: 'parent'})\r\n});\r\n\r\nexport let FeatureVariations = new r.Struct({\r\n  majorVersion: r.uint16,\r\n  minorVersion: r.uint16,\r\n  featureVariationRecordCount: r.uint32,\r\n  featureVariationRecords: new r.Array(FeatureVariationRecord, 'featureVariationRecordCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport { resolveLength } from '@foliojs-fork/restructure/src/utils';\r\nimport CFFDict from './CFFDict';\r\nimport CFFIndex from './CFFIndex';\r\nimport CFFPointer from './CFFPointer';\r\nimport CFFPrivateDict from './CFFPrivateDict';\r\nimport StandardStrings from './CFFStandardStrings';\r\nimport { StandardEncoding, ExpertEncoding } from './CFFEncodings';\r\nimport { ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset } from './CFFCharsets';\r\nimport { ItemVariationStore } from '../tables/variations';\r\n\r\n// Checks if an operand is an index of a predefined value,\r\n// otherwise delegates to the provided type.\r\nclass PredefinedOp {\r\n  constructor(predefinedOps, type) {\r\n    this.predefinedOps = predefinedOps;\r\n    this.type = type;\r\n  }\r\n\r\n  decode(stream, parent, operands) {\r\n    if (this.predefinedOps[operands[0]]) {\r\n      return this.predefinedOps[operands[0]];\r\n    }\r\n\r\n    return this.type.decode(stream, parent, operands);\r\n  }\r\n\r\n  size(value, ctx) {\r\n    return this.type.size(value, ctx);\r\n  }\r\n\r\n  encode(stream, value, ctx) {\r\n    let index = this.predefinedOps.indexOf(value);\r\n    if (index !== -1) {\r\n      return index;\r\n    }\r\n\r\n    return this.type.encode(stream, value, ctx);\r\n  }\r\n}\r\n\r\nclass CFFEncodingVersion extends r.Number {\r\n  constructor() {\r\n    super('UInt8');\r\n  }\r\n\r\n  decode(stream) {\r\n    return r.uint8.decode(stream) & 0x7f;\r\n  }\r\n}\r\n\r\nlet Range1 = new r.Struct({\r\n  first: r.uint16,\r\n  nLeft: r.uint8\r\n});\r\n\r\nlet Range2 = new r.Struct({\r\n  first: r.uint16,\r\n  nLeft: r.uint16\r\n});\r\n\r\nlet CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {\r\n  0: {\r\n    nCodes: r.uint8,\r\n    codes: new r.Array(r.uint8, 'nCodes')\r\n  },\r\n\r\n  1: {\r\n    nRanges: r.uint8,\r\n    ranges: new r.Array(Range1, 'nRanges')\r\n  }\r\n\r\n  // TODO: supplement?\r\n});\r\n\r\nlet CFFEncoding = new PredefinedOp([ StandardEncoding, ExpertEncoding ], new CFFPointer(CFFCustomEncoding, { lazy: true }));\r\n\r\n// Decodes an array of ranges until the total\r\n// length is equal to the provided length.\r\nclass RangeArray extends r.Array {\r\n  decode(stream, parent) {\r\n    let length = resolveLength(this.length, stream, parent);\r\n    let count = 0;\r\n    let res = [];\r\n    while (count < length) {\r\n      let range = this.type.decode(stream, parent);\r\n      range.offset = count;\r\n      count += range.nLeft + 1;\r\n      res.push(range);\r\n    }\r\n\r\n    return res;\r\n  }\r\n}\r\n\r\nlet CFFCustomCharset = new r.VersionedStruct(r.uint8, {\r\n  0: {\r\n    glyphs: new r.Array(r.uint16, t => t.parent.CharStrings.length - 1)\r\n  },\r\n\r\n  1: {\r\n    ranges: new RangeArray(Range1, t => t.parent.CharStrings.length - 1)\r\n  },\r\n\r\n  2: {\r\n    ranges: new RangeArray(Range2, t => t.parent.CharStrings.length - 1)\r\n  }\r\n});\r\n\r\nlet CFFCharset = new PredefinedOp([ ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset ], new CFFPointer(CFFCustomCharset, {lazy: true}));\r\n\r\nlet FDRange3 = new r.Struct({\r\n  first: r.uint16,\r\n  fd: r.uint8\r\n});\r\n\r\nlet FDRange4 = new r.Struct({\r\n  first: r.uint32,\r\n  fd: r.uint16\r\n});\r\n\r\nlet FDSelect = new r.VersionedStruct(r.uint8, {\r\n  0: {\r\n    fds: new r.Array(r.uint8, t => t.parent.CharStrings.length)\r\n  },\r\n\r\n  3: {\r\n    nRanges: r.uint16,\r\n    ranges: new r.Array(FDRange3, 'nRanges'),\r\n    sentinel: r.uint16\r\n  },\r\n\r\n  4: {\r\n    nRanges: r.uint32,\r\n    ranges: new r.Array(FDRange4, 'nRanges'),\r\n    sentinel: r.uint32\r\n  }\r\n});\r\n\r\nlet ptr = new CFFPointer(CFFPrivateDict);\r\nclass CFFPrivateOp {\r\n  decode(stream, parent, operands) {\r\n    parent.length = operands[0];\r\n    return ptr.decode(stream, parent, [operands[1]]);\r\n  }\r\n\r\n  size(dict, ctx) {\r\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]];\r\n  }\r\n\r\n  encode(stream, dict, ctx) {\r\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream, dict, ctx)[0]];\r\n  }\r\n}\r\n\r\nlet FontDict = new CFFDict([\r\n  // key       name                   type(s)                                 default\r\n  [18,        'Private',              new CFFPrivateOp,                       null],\r\n  [[12, 38],  'FontName',             'sid',                                  null],\r\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\r\n  [[12, 5],   'PaintType',            'number',                               0],\r\n]);\r\n\r\nlet CFFTopDict = new CFFDict([\r\n  // key       name                   type(s)                                 default\r\n  [[12, 30],  'ROS',                  ['sid', 'sid', 'number'],               null],\r\n\r\n  [0,         'version',              'sid',                                  null],\r\n  [1,         'Notice',               'sid',                                  null],\r\n  [[12, 0],   'Copyright',            'sid',                                  null],\r\n  [2,         'FullName',             'sid',                                  null],\r\n  [3,         'FamilyName',           'sid',                                  null],\r\n  [4,         'Weight',               'sid',                                  null],\r\n  [[12, 1],   'isFixedPitch',         'boolean',                              false],\r\n  [[12, 2],   'ItalicAngle',          'number',                               0],\r\n  [[12, 3],   'UnderlinePosition',    'number',                               -100],\r\n  [[12, 4],   'UnderlineThickness',   'number',                               50],\r\n  [[12, 5],   'PaintType',            'number',                               0],\r\n  [[12, 6],   'CharstringType',       'number',                               2],\r\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\r\n  [13,        'UniqueID',             'number',                               null],\r\n  [5,         'FontBBox',             'array',                                [0, 0, 0, 0]],\r\n  [[12, 8],   'StrokeWidth',          'number',                               0],\r\n  [14,        'XUID',                 'array',                                null],\r\n  [15,        'charset',              CFFCharset,                             ISOAdobeCharset],\r\n  [16,        'Encoding',             CFFEncoding,                            StandardEncoding],\r\n  [17,        'CharStrings',          new CFFPointer(new CFFIndex),           null],\r\n  [18,        'Private',              new CFFPrivateOp,                       null],\r\n  [[12, 20],  'SyntheticBase',        'number',                               null],\r\n  [[12, 21],  'PostScript',           'sid',                                  null],\r\n  [[12, 22],  'BaseFontName',         'sid',                                  null],\r\n  [[12, 23],  'BaseFontBlend',        'delta',                                null],\r\n\r\n  // CID font specific\r\n  [[12, 31],  'CIDFontVersion',       'number',                               0],\r\n  [[12, 32],  'CIDFontRevision',      'number',                               0],\r\n  [[12, 33],  'CIDFontType',          'number',                               0],\r\n  [[12, 34],  'CIDCount',             'number',                               8720],\r\n  [[12, 35],  'UIDBase',              'number',                               null],\r\n  [[12, 37],  'FDSelect',             new CFFPointer(FDSelect),               null],\r\n  [[12, 36],  'FDArray',              new CFFPointer(new CFFIndex(FontDict)), null],\r\n  [[12, 38],  'FontName',             'sid',                                  null]\r\n]);\r\n\r\nlet VariationStore = new r.Struct({\r\n  length: r.uint16,\r\n  itemVariationStore: ItemVariationStore\r\n})\r\n\r\nlet CFF2TopDict = new CFFDict([\r\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\r\n  [17,        'CharStrings',          new CFFPointer(new CFFIndex),           null],\r\n  [[12, 37],  'FDSelect',             new CFFPointer(FDSelect),               null],\r\n  [[12, 36],  'FDArray',              new CFFPointer(new CFFIndex(FontDict)), null],\r\n  [24,        'vstore',               new CFFPointer(VariationStore),         null],\r\n  [25,        'maxstack',             'number',                               193]\r\n]);\r\n\r\nlet CFFTop = new r.VersionedStruct(r.fixed16, {\r\n  1: {\r\n    hdrSize:            r.uint8,\r\n    offSize:            r.uint8,\r\n    nameIndex:          new CFFIndex(new r.String('length')),\r\n    topDictIndex:       new CFFIndex(CFFTopDict),\r\n    stringIndex:        new CFFIndex(new r.String('length')),\r\n    globalSubrIndex:    new CFFIndex\r\n  },\r\n\r\n  2: {\r\n    hdrSize:            r.uint8,\r\n    length:             r.uint16,\r\n    topDict:            CFF2TopDict,\r\n    globalSubrIndex:    new CFFIndex\r\n  }\r\n});\r\n\r\nexport default CFFTop;\r\n","import r from '@foliojs-fork/restructure';\r\nimport CFFIndex from './CFFIndex';\r\nimport CFFTop from './CFFTop';\r\nimport CFFPrivateDict from './CFFPrivateDict';\r\nimport standardStrings from './CFFStandardStrings';\r\n\r\nclass CFFFont {\r\n  constructor(stream) {\r\n    this.stream = stream;\r\n    this.decode();\r\n  }\r\n\r\n  static decode(stream) {\r\n    return new CFFFont(stream);\r\n  }\r\n\r\n  decode() {\r\n    let start = this.stream.pos;\r\n    let top = CFFTop.decode(this.stream);\r\n    for (let key in top) {\r\n      let val = top[key];\r\n      this[key] = val;\r\n    }\r\n\r\n    if (this.version < 2) {\r\n      if (this.topDictIndex.length !== 1) {\r\n        throw new Error(\"Only a single font is allowed in CFF\");\r\n      }\r\n\r\n      this.topDict = this.topDictIndex[0];\r\n    }\r\n\r\n    this.isCIDFont = this.topDict.ROS != null;\r\n    return this;\r\n  }\r\n\r\n  string(sid) {\r\n    if (this.version >= 2) {\r\n      return null;\r\n    }\r\n\r\n    if (sid < standardStrings.length) {\r\n      return standardStrings[sid];\r\n    }\r\n\r\n    return this.stringIndex[sid - standardStrings.length];\r\n  }\r\n\r\n  get postscriptName() {\r\n    if (this.version < 2) {\r\n      return this.nameIndex[0];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  get fullName() {\r\n    return this.string(this.topDict.FullName);\r\n  }\r\n\r\n  get familyName() {\r\n    return this.string(this.topDict.FamilyName);\r\n  }\r\n\r\n  getCharString(glyph) {\r\n    this.stream.pos = this.topDict.CharStrings[glyph].offset;\r\n    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);\r\n  }\r\n\r\n  getGlyphName(gid) {\r\n    // CFF2 glyph names are in the post table.\r\n    if (this.version >= 2) {\r\n      return null;\r\n    }\r\n\r\n    // CID-keyed fonts don't have glyph names\r\n    if (this.isCIDFont) {\r\n      return null;\r\n    }\r\n\r\n    let { charset } = this.topDict;\r\n    if (Array.isArray(charset)) {\r\n      return charset[gid];\r\n    }\r\n\r\n    if (gid === 0) {\r\n      return '.notdef';\r\n    }\r\n\r\n    gid -= 1;\r\n\r\n    switch (charset.version) {\r\n      case 0:\r\n        return this.string(charset.glyphs[gid]);\r\n\r\n      case 1:\r\n      case 2:\r\n        for (let i = 0; i < charset.ranges.length; i++) {\r\n          let range = charset.ranges[i];\r\n          if (range.offset <= gid && gid <= range.offset + range.nLeft) {\r\n            return this.string(range.first + (gid - range.offset));\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  fdForGlyph(gid) {\r\n    if (!this.topDict.FDSelect) {\r\n      return null;\r\n    }\r\n\r\n    switch (this.topDict.FDSelect.version) {\r\n      case 0:\r\n        return this.topDict.FDSelect.fds[gid];\r\n\r\n      case 3:\r\n      case 4:\r\n        let { ranges } = this.topDict.FDSelect;\r\n        let low = 0;\r\n        let high = ranges.length - 1;\r\n\r\n        while (low <= high) {\r\n          let mid = (low + high) >> 1;\r\n\r\n          if (gid < ranges[mid].first) {\r\n            high = mid - 1;\r\n          } else if (mid < high && gid >= ranges[mid + 1].first) {\r\n            low = mid + 1;\r\n          } else {\r\n            return ranges[mid].fd;\r\n          }\r\n        }\r\n      default:\r\n        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);\r\n    }\r\n  }\r\n\r\n  privateDictForGlyph(gid) {\r\n    if (this.topDict.FDSelect) {\r\n      let fd = this.fdForGlyph(gid);\r\n      if (this.topDict.FDArray[fd]) {\r\n        return this.topDict.FDArray[fd].Private;\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    if (this.version < 2) {\r\n      return this.topDict.Private;\r\n    }\r\n\r\n    return this.topDict.FDArray[0].Private;\r\n  }\r\n}\r\n\r\nexport default CFFFont;\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet VerticalOrigin = new r.Struct({\r\n  glyphIndex:   r.uint16,\r\n  vertOriginY:  r.int16\r\n});\r\n\r\nexport default new r.Struct({\r\n  majorVersion:           r.uint16,\r\n  minorVersion:           r.uint16,\r\n  defaultVertOriginY:     r.int16,\r\n  numVertOriginYMetrics:  r.uint16,\r\n  metrics:                new r.Array(VerticalOrigin, 'numVertOriginYMetrics')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nexport let BigMetrics = new r.Struct({\r\n  height: r.uint8,\r\n  width: r.uint8,\r\n  horiBearingX: r.int8,\r\n  horiBearingY: r.int8,\r\n  horiAdvance: r.uint8,\r\n  vertBearingX: r.int8,\r\n  vertBearingY: r.int8,\r\n  vertAdvance: r.uint8\r\n});\r\n\r\nexport let SmallMetrics = new r.Struct({\r\n  height: r.uint8,\r\n  width: r.uint8,\r\n  bearingX: r.int8,\r\n  bearingY: r.int8,\r\n  advance: r.uint8\r\n});\r\n\r\nlet EBDTComponent = new r.Struct({\r\n  glyph: r.uint16,\r\n  xOffset: r.int8,\r\n  yOffset: r.int8\r\n});\r\n\r\nclass ByteAligned {}\r\n\r\nclass BitAligned {}\r\n\r\nexport let glyph = new r.VersionedStruct('version', {\r\n  1: {\r\n    metrics: SmallMetrics,\r\n    data: ByteAligned\r\n  },\r\n\r\n  2: {\r\n    metrics: SmallMetrics,\r\n    data: BitAligned\r\n  },\r\n\r\n  // format 3 is deprecated\r\n  // format 4 is not supported by Microsoft\r\n\r\n  5: {\r\n    data: BitAligned\r\n  },\r\n\r\n  6: {\r\n    metrics: BigMetrics,\r\n    data: ByteAligned\r\n  },\r\n\r\n  7: {\r\n    metrics: BigMetrics,\r\n    data: BitAligned\r\n  },\r\n\r\n  8: {\r\n    metrics: SmallMetrics,\r\n    pad: new r.Reserved(r.uint8),\r\n    numComponents: r.uint16,\r\n    components: new r.Array(EBDTComponent, 'numComponents')\r\n  },\r\n\r\n  9: {\r\n    metrics: BigMetrics,\r\n    pad: new r.Reserved(r.uint8),\r\n    numComponents: r.uint16,\r\n    components: new r.Array(EBDTComponent, 'numComponents')\r\n  },\r\n\r\n  17: {\r\n    metrics: SmallMetrics,\r\n    dataLen: r.uint32,\r\n    data: new r.Buffer('dataLen')\r\n  },\r\n\r\n  18: {\r\n    metrics: BigMetrics,\r\n    dataLen: r.uint32,\r\n    data: new r.Buffer('dataLen')\r\n  },\r\n\r\n  19: {\r\n    dataLen: r.uint32,\r\n    data: new r.Buffer('dataLen')\r\n  }\r\n});\r\n\r\n","import r from '@foliojs-fork/restructure';\r\nimport {BigMetrics} from './EBDT';\r\n\r\nlet SBitLineMetrics = new r.Struct({\r\n  ascender: r.int8,\r\n  descender: r.int8,\r\n  widthMax: r.uint8,\r\n  caretSlopeNumerator: r.int8,\r\n  caretSlopeDenominator: r.int8,\r\n  caretOffset: r.int8,\r\n  minOriginSB: r.int8,\r\n  minAdvanceSB: r.int8,\r\n  maxBeforeBL: r.int8,\r\n  minAfterBL: r.int8,\r\n  pad: new r.Reserved(r.int8, 2)\r\n});\r\n\r\nlet CodeOffsetPair = new r.Struct({\r\n  glyphCode: r.uint16,\r\n  offset: r.uint16\r\n});\r\n\r\nlet IndexSubtable = new r.VersionedStruct(r.uint16, {\r\n  header: {\r\n    imageFormat: r.uint16,\r\n    imageDataOffset: r.uint32\r\n  },\r\n\r\n  1: {\r\n    offsetArray: new r.Array(r.uint32, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\r\n  },\r\n\r\n  2: {\r\n    imageSize: r.uint32,\r\n    bigMetrics: BigMetrics\r\n  },\r\n\r\n  3: {\r\n    offsetArray: new r.Array(r.uint16, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\r\n  },\r\n\r\n  4: {\r\n    numGlyphs: r.uint32,\r\n    glyphArray: new r.Array(CodeOffsetPair, t => t.numGlyphs + 1)\r\n  },\r\n\r\n  5: {\r\n    imageSize: r.uint32,\r\n    bigMetrics: BigMetrics,\r\n    numGlyphs: r.uint32,\r\n    glyphCodeArray: new r.Array(r.uint16, 'numGlyphs')\r\n  }\r\n});\r\n\r\nlet IndexSubtableArray = new r.Struct({\r\n  firstGlyphIndex: r.uint16,\r\n  lastGlyphIndex: r.uint16,\r\n  subtable: new r.Pointer(r.uint32, IndexSubtable)\r\n});\r\n\r\nlet BitmapSizeTable = new r.Struct({\r\n  indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), { type: 'parent' }),\r\n  indexTablesSize: r.uint32,\r\n  numberOfIndexSubTables: r.uint32,\r\n  colorRef: r.uint32,\r\n  hori: SBitLineMetrics,\r\n  vert: SBitLineMetrics,\r\n  startGlyphIndex: r.uint16,\r\n  endGlyphIndex: r.uint16,\r\n  ppemX: r.uint8,\r\n  ppemY: r.uint8,\r\n  bitDepth: r.uint8,\r\n  flags: new r.Bitfield(r.uint8, ['horizontal', 'vertical'])\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:  r.uint32, // 0x00020000\r\n  numSizes: r.uint32,\r\n  sizes:    new r.Array(BitmapSizeTable, 'numSizes')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet ImageTable = new r.Struct({\r\n  ppem: r.uint16,\r\n  resolution: r.uint16,\r\n  imageOffsets: new r.Array(new r.Pointer(r.uint32, 'void'), t => t.parent.parent.maxp.numGlyphs + 1)\r\n});\r\n\r\n// This is the Apple sbix table, used by the \"Apple Color Emoji\" font.\r\n// It includes several image tables with images for each bitmap glyph\r\n// of several different sizes.\r\nexport default new r.Struct({\r\n  version: r.uint16,\r\n  flags: new r.Bitfield(r.uint16, ['renderOutlines']),\r\n  numImgTables: r.uint32,\r\n  imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), 'numImgTables')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet LayerRecord = new r.Struct({\r\n  gid: r.uint16,          // Glyph ID of layer glyph (must be in z-order from bottom to top).\r\n  paletteIndex: r.uint16  // Index value to use in the appropriate palette. This value must\r\n});                       // be less than numPaletteEntries in the CPAL table, except for\r\n                          // the special case noted below. Each palette entry is 16 bits.\r\n                          // A palette index of 0xFFFF is a special case indicating that\r\n                          // the text foreground color should be used.\r\n\r\nlet BaseGlyphRecord = new r.Struct({\r\n  gid: r.uint16,             // Glyph ID of reference glyph. This glyph is for reference only\r\n                             // and is not rendered for color.\r\n  firstLayerIndex: r.uint16, // Index (from beginning of the Layer Records) to the layer record.\r\n                             // There will be numLayers consecutive entries for this base glyph.\r\n  numLayers: r.uint16\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.uint16,\r\n  numBaseGlyphRecords: r.uint16,\r\n  baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, 'numBaseGlyphRecords')),\r\n  layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, 'numLayerRecords'), { lazy: true }),\r\n  numLayerRecords: r.uint16\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet ColorRecord = new r.Struct({\r\n  blue: r.uint8,\r\n  green: r.uint8,\r\n  red: r.uint8,\r\n  alpha: r.uint8\r\n});\r\n\r\nexport default new r.VersionedStruct(r.uint16, {\r\n  header: {\r\n    numPaletteEntries: r.uint16,\r\n    numPalettes: r.uint16,\r\n    numColorRecords: r.uint16,\r\n    colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, 'numColorRecords')),\r\n    colorRecordIndices: new r.Array(r.uint16, 'numPalettes'),\r\n  },\r\n  0: {},\r\n  1: {\r\n    offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, 'numPalettes')),\r\n    offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPalettes')),\r\n    offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPaletteEntries'))\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device} from './opentype';\r\nimport {ItemVariationStore} from './variations';\r\n\r\nlet BaseCoord = new r.VersionedStruct(r.uint16, {\r\n  1: { // Design units only\r\n    coordinate:   r.int16 // X or Y value, in design units\r\n  },\r\n\r\n  2: { // Design units plus contour point\r\n    coordinate:     r.int16,   // X or Y value, in design units\r\n    referenceGlyph: r.uint16,  // GlyphID of control glyph\r\n    baseCoordPoint: r.uint16   // Index of contour point on the referenceGlyph\r\n  },\r\n\r\n  3: { // Design units plus Device table\r\n    coordinate:   r.int16,                         // X or Y value, in design units\r\n    deviceTable:  new r.Pointer(r.uint16, Device)  // Device table for X or Y value\r\n  }\r\n});\r\n\r\nlet BaseValues = new r.Struct({\r\n  defaultIndex:   r.uint16,  // Index of default baseline for this script-same index in the BaseTagList\r\n  baseCoordCount: r.uint16,\r\n  baseCoords:     new r.Array(new r.Pointer(r.uint16, BaseCoord), 'baseCoordCount')\r\n});\r\n\r\nlet FeatMinMaxRecord = new r.Struct({\r\n  tag:        new r.String(4),  // 4-byte feature identification tag-must match FeatureTag in FeatureList\r\n  minCoord:   new r.Pointer(r.uint16, BaseCoord, {type: 'parent'}), // May be NULL\r\n  maxCoord:   new r.Pointer(r.uint16, BaseCoord, {type: 'parent'})  // May be NULL\r\n});\r\n\r\nlet MinMax = new r.Struct({\r\n  minCoord:           new r.Pointer(r.uint16, BaseCoord),  // May be NULL\r\n  maxCoord:           new r.Pointer(r.uint16, BaseCoord),  // May be NULL\r\n  featMinMaxCount:    r.uint16,                            // May be 0\r\n  featMinMaxRecords:  new r.Array(FeatMinMaxRecord, 'featMinMaxCount') // In alphabetical order\r\n});\r\n\r\nlet BaseLangSysRecord = new r.Struct({\r\n  tag:    new r.String(4),  // 4-byte language system identification tag\r\n  minMax: new r.Pointer(r.uint16, MinMax, {type: 'parent'})\r\n});\r\n\r\nlet BaseScript = new r.Struct({\r\n  baseValues:         new r.Pointer(r.uint16, BaseValues), // May be NULL\r\n  defaultMinMax:      new r.Pointer(r.uint16, MinMax),     // May be NULL\r\n  baseLangSysCount:   r.uint16,                            // May be 0\r\n  baseLangSysRecords: new r.Array(BaseLangSysRecord, 'baseLangSysCount') // in alphabetical order by BaseLangSysTag\r\n});\r\n\r\nlet BaseScriptRecord = new r.Struct({\r\n  tag:      new r.String(4),  // 4-byte script identification tag\r\n  script:   new r.Pointer(r.uint16, BaseScript, {type: 'parent'})\r\n});\r\n\r\nlet BaseScriptList = new r.Array(BaseScriptRecord, r.uint16);\r\n\r\n// Array of 4-byte baseline identification tags-must be in alphabetical order\r\nlet BaseTagList = new r.Array(new r.String(4), r.uint16);\r\n\r\nlet Axis = new r.Struct({\r\n  baseTagList:    new r.Pointer(r.uint16, BaseTagList),  // May be NULL\r\n  baseScriptList: new r.Pointer(r.uint16, BaseScriptList)\r\n});\r\n\r\nexport default new r.VersionedStruct(r.uint32, {\r\n  header: {\r\n    horizAxis:    new r.Pointer(r.uint16, Axis),   // May be NULL\r\n    vertAxis:     new r.Pointer(r.uint16, Axis)    // May be NULL\r\n  },\r\n\r\n  0x00010000: {},\r\n  0x00010001: {\r\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device} from './opentype';\r\nimport {ItemVariationStore} from './variations';\r\n\r\nlet AttachPoint = new r.Array(r.uint16, r.uint16);\r\nlet AttachList = new r.Struct({\r\n  coverage:       new r.Pointer(r.uint16, Coverage),\r\n  glyphCount:     r.uint16,\r\n  attachPoints:   new r.Array(new r.Pointer(r.uint16, AttachPoint), 'glyphCount')\r\n});\r\n\r\nlet CaretValue = new r.VersionedStruct(r.uint16, {\r\n  1: { // Design units only\r\n    coordinate: r.int16\r\n  },\r\n\r\n  2: { // Contour point\r\n    caretValuePoint: r.uint16\r\n  },\r\n\r\n  3: { // Design units plus Device table\r\n    coordinate:     r.int16,\r\n    deviceTable:    new r.Pointer(r.uint16, Device)\r\n  }\r\n});\r\n\r\nlet LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);\r\n\r\nlet LigCaretList = new r.Struct({\r\n  coverage:       new r.Pointer(r.uint16, Coverage),\r\n  ligGlyphCount:  r.uint16,\r\n  ligGlyphs:      new r.Array(new r.Pointer(r.uint16, LigGlyph), 'ligGlyphCount')\r\n});\r\n\r\nlet MarkGlyphSetsDef = new r.Struct({\r\n  markSetTableFormat: r.uint16,\r\n  markSetCount:       r.uint16,\r\n  coverage:           new r.Array(new r.Pointer(r.uint32, Coverage), 'markSetCount')\r\n});\r\n\r\nexport default new r.VersionedStruct(r.uint32, {\r\n  header: {\r\n    glyphClassDef:      new r.Pointer(r.uint16, ClassDef),\r\n    attachList:         new r.Pointer(r.uint16, AttachList),\r\n    ligCaretList:       new r.Pointer(r.uint16, LigCaretList),\r\n    markAttachClassDef: new r.Pointer(r.uint16, ClassDef)\r\n  },\r\n\r\n  0x00010000: {},\r\n  0x00010002: {\r\n    markGlyphSetsDef:   new r.Pointer(r.uint16, MarkGlyphSetsDef)\r\n  },\r\n  0x00010003: {\r\n    markGlyphSetsDef:   new r.Pointer(r.uint16, MarkGlyphSetsDef),\r\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device, Context, ChainingContext} from './opentype';\r\nimport {FeatureVariations} from './variations';\r\n\r\nlet ValueFormat = new r.Bitfield(r.uint16, [\r\n  'xPlacement', 'yPlacement',\r\n  'xAdvance', 'yAdvance',\r\n  'xPlaDevice', 'yPlaDevice',\r\n  'xAdvDevice', 'yAdvDevice'\r\n]);\r\n\r\nlet types = {\r\n  xPlacement: r.int16,\r\n  yPlacement: r.int16,\r\n  xAdvance:   r.int16,\r\n  yAdvance:   r.int16,\r\n  xPlaDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\r\n  yPlaDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\r\n  xAdvDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\r\n  yAdvDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel })\r\n};\r\n\r\nclass ValueRecord {\r\n  constructor(key = 'valueFormat') {\r\n    this.key = key;\r\n  }\r\n\r\n  buildStruct(parent) {\r\n    let struct = parent;\r\n    while (!struct[this.key] && struct.parent) {\r\n      struct = struct.parent;\r\n    }\r\n\r\n    if (!struct[this.key]) return;\r\n\r\n    let fields = {};\r\n    fields.rel = () => struct._startOffset;\r\n\r\n    let format = struct[this.key];\r\n    for (let key in format) {\r\n      if (format[key]) {\r\n        fields[key] = types[key];\r\n      }\r\n    }\r\n\r\n    return new r.Struct(fields);\r\n  }\r\n\r\n  size(val, ctx) {\r\n    return this.buildStruct(ctx).size(val, ctx);\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    let res = this.buildStruct(parent).decode(stream, parent);\r\n    delete res.rel;\r\n    return res;\r\n  }\r\n}\r\n\r\nlet PairValueRecord = new r.Struct({\r\n  secondGlyph:    r.uint16,\r\n  value1:         new ValueRecord('valueFormat1'),\r\n  value2:         new ValueRecord('valueFormat2')\r\n});\r\n\r\nlet PairSet = new r.Array(PairValueRecord, r.uint16);\r\n\r\nlet Class2Record = new r.Struct({\r\n  value1: new ValueRecord('valueFormat1'),\r\n  value2: new ValueRecord('valueFormat2')\r\n});\r\n\r\nlet Anchor = new r.VersionedStruct(r.uint16, {\r\n  1: { // Design units only\r\n    xCoordinate:    r.int16,\r\n    yCoordinate:    r.int16\r\n  },\r\n\r\n  2: { // Design units plus contour point\r\n    xCoordinate:    r.int16,\r\n    yCoordinate:    r.int16,\r\n    anchorPoint:    r.uint16\r\n  },\r\n\r\n  3: { // Design units plus Device tables\r\n    xCoordinate:    r.int16,\r\n    yCoordinate:    r.int16,\r\n    xDeviceTable:   new r.Pointer(r.uint16, Device),\r\n    yDeviceTable:   new r.Pointer(r.uint16, Device)\r\n  }\r\n});\r\n\r\nlet EntryExitRecord = new r.Struct({\r\n  entryAnchor:    new r.Pointer(r.uint16, Anchor, {type: 'parent'}),\r\n  exitAnchor:     new r.Pointer(r.uint16, Anchor, {type: 'parent'})\r\n});\r\n\r\nlet MarkRecord = new r.Struct({\r\n  class:      r.uint16,\r\n  markAnchor: new r.Pointer(r.uint16, Anchor, {type: 'parent'})\r\n});\r\n\r\nlet MarkArray = new r.Array(MarkRecord, r.uint16);\r\n\r\nlet BaseRecord  = new r.Array(new r.Pointer(r.uint16, Anchor), t => t.parent.classCount);\r\nlet BaseArray   = new r.Array(BaseRecord, r.uint16);\r\n\r\nlet ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), t => t.parent.parent.classCount);\r\nlet LigatureAttach  = new r.Array(ComponentRecord, r.uint16);\r\nlet LigatureArray   = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);\r\n\r\nlet GPOSLookup = new r.VersionedStruct('lookupType', {\r\n  1: new r.VersionedStruct(r.uint16, { // Single Adjustment\r\n    1: { // Single positioning value\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      valueFormat:    ValueFormat,\r\n      value:          new ValueRecord()\r\n    },\r\n    2: {\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      valueFormat:    ValueFormat,\r\n      valueCount:     r.uint16,\r\n      values:         new r.LazyArray(new ValueRecord(), 'valueCount')\r\n    }\r\n  }),\r\n\r\n  2: new r.VersionedStruct(r.uint16, { // Pair Adjustment Positioning\r\n    1: { // Adjustments for glyph pairs\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      valueFormat1:   ValueFormat,\r\n      valueFormat2:   ValueFormat,\r\n      pairSetCount:   r.uint16,\r\n      pairSets:       new r.LazyArray(new r.Pointer(r.uint16, PairSet), 'pairSetCount')\r\n    },\r\n\r\n    2: { // Class pair adjustment\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      valueFormat1:   ValueFormat,\r\n      valueFormat2:   ValueFormat,\r\n      classDef1:      new r.Pointer(r.uint16, ClassDef),\r\n      classDef2:      new r.Pointer(r.uint16, ClassDef),\r\n      class1Count:    r.uint16,\r\n      class2Count:    r.uint16,\r\n      classRecords:   new r.LazyArray(new r.LazyArray(Class2Record, 'class2Count'), 'class1Count')\r\n    }\r\n  }),\r\n\r\n  3: { // Cursive Attachment Positioning\r\n    format:             r.uint16,\r\n    coverage:           new r.Pointer(r.uint16, Coverage),\r\n    entryExitCount:     r.uint16,\r\n    entryExitRecords:   new r.Array(EntryExitRecord, 'entryExitCount')\r\n  },\r\n\r\n  4: { // MarkToBase Attachment Positioning\r\n    format:             r.uint16,\r\n    markCoverage:       new r.Pointer(r.uint16, Coverage),\r\n    baseCoverage:       new r.Pointer(r.uint16, Coverage),\r\n    classCount:         r.uint16,\r\n    markArray:          new r.Pointer(r.uint16, MarkArray),\r\n    baseArray:          new r.Pointer(r.uint16, BaseArray)\r\n  },\r\n\r\n  5: { // MarkToLigature Attachment Positioning\r\n    format:             r.uint16,\r\n    markCoverage:       new r.Pointer(r.uint16, Coverage),\r\n    ligatureCoverage:   new r.Pointer(r.uint16, Coverage),\r\n    classCount:         r.uint16,\r\n    markArray:          new r.Pointer(r.uint16, MarkArray),\r\n    ligatureArray:      new r.Pointer(r.uint16, LigatureArray)\r\n  },\r\n\r\n  6: { // MarkToMark Attachment Positioning\r\n    format:             r.uint16,\r\n    mark1Coverage:      new r.Pointer(r.uint16, Coverage),\r\n    mark2Coverage:      new r.Pointer(r.uint16, Coverage),\r\n    classCount:         r.uint16,\r\n    mark1Array:         new r.Pointer(r.uint16, MarkArray),\r\n    mark2Array:         new r.Pointer(r.uint16, BaseArray)\r\n  },\r\n\r\n  7: Context,          // Contextual positioning\r\n  8: ChainingContext,  // Chaining contextual positioning\r\n\r\n  9: { // Extension Positioning\r\n    posFormat:   r.uint16,\r\n    lookupType:  r.uint16,   // cannot also be 9\r\n    extension:   new r.Pointer(r.uint32, GPOSLookup)\r\n  }\r\n});\r\n\r\n// Fix circular reference\r\nGPOSLookup.versions[9].extension.type = GPOSLookup;\r\n\r\nexport default new r.VersionedStruct(r.uint32, {\r\n  header: {\r\n    scriptList:     new r.Pointer(r.uint16, ScriptList),\r\n    featureList:    new r.Pointer(r.uint16, FeatureList),\r\n    lookupList:     new r.Pointer(r.uint16, new LookupList(GPOSLookup))\r\n  },\r\n\r\n  0x00010000: {},\r\n  0x00010001: {\r\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\r\n  }\r\n});\r\n\r\n// export GPOSLookup for JSTF table\r\nexport { GPOSLookup };\r\n","import r from '@foliojs-fork/restructure';\r\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device, Context, ChainingContext} from './opentype';\r\nimport {FeatureVariations} from './variations';\r\n\r\nlet Sequence = new r.Array(r.uint16, r.uint16);\r\nlet AlternateSet = Sequence;\r\n\r\nlet Ligature = new r.Struct({\r\n  glyph:      r.uint16,\r\n  compCount:  r.uint16,\r\n  components: new r.Array(r.uint16, t => t.compCount - 1)\r\n});\r\n\r\nlet LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);\r\n\r\nlet GSUBLookup = new r.VersionedStruct('lookupType', {\r\n  1: new r.VersionedStruct(r.uint16, {// Single Substitution\r\n    1: {\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      deltaGlyphID:   r.int16\r\n    },\r\n    2: {\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      glyphCount:     r.uint16,\r\n      substitute:     new r.LazyArray(r.uint16, 'glyphCount')\r\n    }\r\n  }),\r\n\r\n  2: { // Multiple Substitution\r\n    substFormat:    r.uint16,\r\n    coverage:       new r.Pointer(r.uint16, Coverage),\r\n    count:          r.uint16,\r\n    sequences:      new r.LazyArray(new r.Pointer(r.uint16, Sequence), 'count')\r\n  },\r\n\r\n  3: { // Alternate Substitution\r\n    substFormat:    r.uint16,\r\n    coverage:       new r.Pointer(r.uint16, Coverage),\r\n    count:          r.uint16,\r\n    alternateSet:   new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), 'count')\r\n  },\r\n\r\n  4: { // Ligature Substitution\r\n    substFormat:    r.uint16,\r\n    coverage:       new r.Pointer(r.uint16, Coverage),\r\n    count:          r.uint16,\r\n    ligatureSets:   new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), 'count')\r\n  },\r\n\r\n  5: Context,         // Contextual Substitution\r\n  6: ChainingContext, // Chaining Contextual Substitution\r\n\r\n  7: { // Extension Substitution\r\n    substFormat:   r.uint16,\r\n    lookupType:    r.uint16,   // cannot also be 7\r\n    extension:     new r.Pointer(r.uint32, GSUBLookup)\r\n  },\r\n\r\n  8: { // Reverse Chaining Contextual Single Substitution\r\n    substFormat:            r.uint16,\r\n    coverage:               new r.Pointer(r.uint16, Coverage),\r\n    backtrackCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\r\n    lookaheadGlyphCount:    r.uint16,\r\n    lookaheadCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\r\n    glyphCount:             r.uint16,\r\n    substitutes:            new r.Array(r.uint16, 'glyphCount')\r\n  }\r\n});\r\n\r\n// Fix circular reference\r\nGSUBLookup.versions[7].extension.type = GSUBLookup;\r\n\r\nexport default new r.VersionedStruct(r.uint32, {\r\n  header: {\r\n    scriptList:     new r.Pointer(r.uint16, ScriptList),\r\n    featureList:    new r.Pointer(r.uint16, FeatureList),\r\n    lookupList:     new r.Pointer(r.uint16, new LookupList(GSUBLookup))\r\n  },\r\n\r\n  0x00010000: {},\r\n  0x00010001: {\r\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport { ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device } from './opentype';\r\nimport { GPOSLookup } from './GPOS';\r\n\r\nlet JstfGSUBModList = new r.Array(r.uint16, r.uint16);\r\n\r\nlet JstfPriority = new r.Struct({\r\n  shrinkageEnableGSUB:    new r.Pointer(r.uint16, JstfGSUBModList),\r\n  shrinkageDisableGSUB:   new r.Pointer(r.uint16, JstfGSUBModList),\r\n  shrinkageEnableGPOS:    new r.Pointer(r.uint16, JstfGSUBModList),\r\n  shrinkageDisableGPOS:   new r.Pointer(r.uint16, JstfGSUBModList),\r\n  shrinkageJstfMax:       new r.Pointer(r.uint16, new LookupList(GPOSLookup)),\r\n  extensionEnableGSUB:    new r.Pointer(r.uint16, JstfGSUBModList),\r\n  extensionDisableGSUB:   new r.Pointer(r.uint16, JstfGSUBModList),\r\n  extensionEnableGPOS:    new r.Pointer(r.uint16, JstfGSUBModList),\r\n  extensionDisableGPOS:   new r.Pointer(r.uint16, JstfGSUBModList),\r\n  extensionJstfMax:       new r.Pointer(r.uint16, new LookupList(GPOSLookup))\r\n});\r\n\r\nlet JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);\r\n\r\nlet JstfLangSysRecord = new r.Struct({\r\n  tag:         new r.String(4),\r\n  jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)\r\n});\r\n\r\nlet JstfScript = new r.Struct({\r\n  extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)), // array of glyphs to extend line length\r\n  defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),\r\n  langSysCount:   r.uint16,\r\n  langSysRecords: new r.Array(JstfLangSysRecord, 'langSysCount')\r\n});\r\n\r\nlet JstfScriptRecord = new r.Struct({\r\n  tag:    new r.String(4),\r\n  script: new r.Pointer(r.uint16, JstfScript, {type: 'parent'})\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:     r.uint32,  // should be 0x00010000\r\n  scriptCount: r.uint16,\r\n  scriptList:  new r.Array(JstfScriptRecord, 'scriptCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport {resolveLength} from '@foliojs-fork/restructure/src/utils';\r\nimport {ItemVariationStore} from './variations';\r\n\r\n// TODO: add this to restructure\r\nclass VariableSizeNumber {\r\n  constructor(size) {\r\n    this._size = size;\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    switch (this.size(0, parent)) {\r\n      case 1: return stream.readUInt8();\r\n      case 2: return stream.readUInt16BE();\r\n      case 3: return stream.readUInt24BE();\r\n      case 4: return stream.readUInt32BE();\r\n    }\r\n  }\r\n\r\n  size(val, parent) {\r\n    return resolveLength(this._size, null, parent);\r\n  }\r\n}\r\n\r\nlet MapDataEntry = new r.Struct({\r\n  entry: new VariableSizeNumber(t => ((t.parent.entryFormat & 0x0030) >> 4) + 1),\r\n  outerIndex: t => t.entry >> ((t.parent.entryFormat & 0x000F) + 1),\r\n  innerIndex: t => t.entry & ((1 << ((t.parent.entryFormat & 0x000F) + 1)) - 1)\r\n});\r\n\r\nlet DeltaSetIndexMap = new r.Struct({\r\n  entryFormat: r.uint16,\r\n  mapCount: r.uint16,\r\n  mapData: new r.Array(MapDataEntry, 'mapCount')\r\n});\r\n\r\nexport default new r.Struct({\r\n  majorVersion: r.uint16,\r\n  minorVersion: r.uint16,\r\n  itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),\r\n  advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\r\n  LSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\r\n  RSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet Signature = new r.Struct({\r\n  format: r.uint32,\r\n  length: r.uint32,\r\n  offset: r.uint32\r\n});\r\n\r\nlet SignatureBlock = new r.Struct({\r\n  reserved:       new r.Reserved(r.uint16, 2),\r\n  cbSignature:    r.uint32,  // Length (in bytes) of the PKCS#7 packet in pbSignature\r\n  signature:      new r.Buffer('cbSignature')\r\n});\r\n\r\nexport default new r.Struct({\r\n  ulVersion:       r.uint32,  // Version number of the DSIG table (0x00000001)\r\n  usNumSigs:       r.uint16,  // Number of signatures in the table\r\n  usFlag:          r.uint16,  // Permission flags\r\n  signatures:      new r.Array(Signature, 'usNumSigs'),\r\n  signatureBlocks: new r.Array(SignatureBlock, 'usNumSigs')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet GaspRange = new r.Struct({\r\n  rangeMaxPPEM:       r.uint16,                  // Upper limit of range, in ppem\r\n  rangeGaspBehavior:  new r.Bitfield(r.uint16, [ // Flags describing desired rasterizer behavior\r\n    'grayscale', 'gridfit',\r\n    'symmetricSmoothing', 'symmetricGridfit'     // only in version 1, for ClearType\r\n  ])\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:    r.uint16,  // set to 0\r\n  numRanges:  r.uint16,\r\n  gaspRanges: new r.Array(GaspRange, 'numRanges') // Sorted by ppem\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet DeviceRecord = new r.Struct({\r\n  pixelSize:      r.uint8,\r\n  maximumWidth:   r.uint8,\r\n  widths:         new r.Array(r.uint8, t => t.parent.parent.maxp.numGlyphs)\r\n});\r\n\r\n// The Horizontal Device Metrics table stores integer advance widths scaled to particular pixel sizes\r\nexport default new r.Struct({\r\n  version:            r.uint16,\r\n  numRecords:         r.int16,\r\n  sizeDeviceRecord:   r.int32,\r\n  records:            new r.Array(DeviceRecord, 'numRecords')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet KernPair = new r.Struct({\r\n  left:   r.uint16,\r\n  right:  r.uint16,\r\n  value:  r.int16\r\n});\r\n\r\nlet ClassTable = new r.Struct({\r\n  firstGlyph: r.uint16,\r\n  nGlyphs: r.uint16,\r\n  offsets: new r.Array(r.uint16, 'nGlyphs'),\r\n  max: t => t.offsets.length && Math.max.apply(Math, t.offsets)\r\n});\r\n\r\nlet Kern2Array = new r.Struct({\r\n  off: t => t._startOffset - t.parent.parent._startOffset,\r\n  len: t => (((t.parent.leftTable.max - t.off) / t.parent.rowWidth) + 1) * (t.parent.rowWidth / 2),\r\n  values: new r.LazyArray(r.int16, 'len')\r\n});\r\n\r\nlet KernSubtable = new r.VersionedStruct('format', {\r\n  0: {\r\n    nPairs:         r.uint16,\r\n    searchRange:    r.uint16,\r\n    entrySelector:  r.uint16,\r\n    rangeShift:     r.uint16,\r\n    pairs:          new r.Array(KernPair, 'nPairs')\r\n  },\r\n\r\n  2: {\r\n    rowWidth:   r.uint16,\r\n    leftTable:  new r.Pointer(r.uint16, ClassTable, {type: 'parent'}),\r\n    rightTable: new r.Pointer(r.uint16, ClassTable, {type: 'parent'}),\r\n    array:      new r.Pointer(r.uint16, Kern2Array, {type: 'parent'})\r\n  },\r\n\r\n  3: {\r\n    glyphCount:       r.uint16,\r\n    kernValueCount:   r.uint8,\r\n    leftClassCount:   r.uint8,\r\n    rightClassCount:  r.uint8,\r\n    flags:            r.uint8,\r\n    kernValue:        new r.Array(r.int16, 'kernValueCount'),\r\n    leftClass:        new r.Array(r.uint8, 'glyphCount'),\r\n    rightClass:       new r.Array(r.uint8, 'glyphCount'),\r\n    kernIndex:        new r.Array(r.uint8, t => t.leftClassCount * t.rightClassCount)\r\n  }\r\n});\r\n\r\nlet KernTable = new r.VersionedStruct('version', {\r\n  0: { // Microsoft uses this format\r\n    subVersion: r.uint16,  // Microsoft has an extra sub-table version number\r\n    length:     r.uint16,  // Length of the subtable, in bytes\r\n    format:     r.uint8,   // Format of subtable\r\n    coverage:   new r.Bitfield(r.uint8, [\r\n      'horizontal',    // 1 if table has horizontal data, 0 if vertical\r\n      'minimum',       // If set to 1, the table has minimum values. If set to 0, the table has kerning values.\r\n      'crossStream',   // If set to 1, kerning is perpendicular to the flow of the text\r\n      'override'      // If set to 1 the value in this table replaces the accumulated value\r\n    ]),\r\n    subtable:   KernSubtable,\r\n    padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\r\n  },\r\n  1: { // Apple uses this format\r\n    length:     r.uint32,\r\n    coverage:   new r.Bitfield(r.uint8, [\r\n      null, null, null, null, null,\r\n      'variation',     // Set if table has variation kerning values\r\n      'crossStream',   // Set if table has cross-stream kerning values\r\n      'vertical'      // Set if table has vertical kerning values\r\n    ]),\r\n    format:     r.uint8,\r\n    tupleIndex: r.uint16,\r\n    subtable:   KernSubtable,\r\n    padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\r\n  }\r\n});\r\n\r\nexport default new r.VersionedStruct(r.uint16, {\r\n  0: { // Microsoft Version\r\n    nTables:    r.uint16,\r\n    tables:     new r.Array(KernTable, 'nTables')\r\n  },\r\n\r\n  1: { // Apple Version\r\n    reserved:   new r.Reserved(r.uint16), // the other half of the version number\r\n    nTables:    r.uint32,\r\n    tables:     new r.Array(KernTable, 'nTables')\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// Linear Threshold table\r\n// Records the ppem for each glyph at which the scaling becomes linear again,\r\n// despite instructions effecting the advance width\r\nexport default new r.Struct({\r\n  version:    r.uint16,\r\n  numGlyphs:  r.uint16,\r\n  yPels:      new r.Array(r.uint8, 'numGlyphs')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// PCL 5 Table\r\n// NOTE: The PCLT table is strongly discouraged for OpenType fonts with TrueType outlines\r\nexport default new r.Struct({\r\n  version:              r.uint16,\r\n  fontNumber:           r.uint32,\r\n  pitch:                r.uint16,\r\n  xHeight:              r.uint16,\r\n  style:                r.uint16,\r\n  typeFamily:           r.uint16,\r\n  capHeight:            r.uint16,\r\n  symbolSet:            r.uint16,\r\n  typeface:             new r.String(16),\r\n  characterComplement:  new r.String(8),\r\n  fileName:             new r.String(6),\r\n  strokeWeight:         new r.String(1),\r\n  widthType:            new r.String(1),\r\n  serifStyle:           r.uint8,\r\n  reserved:             new r.Reserved(r.uint8)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// VDMX tables contain ascender/descender overrides for certain (usually small)\r\n// sizes. This is needed in order to match font metrics on Windows.\r\n\r\nlet Ratio = new r.Struct({\r\n  bCharSet:       r.uint8,                             // Character set\r\n  xRatio:         r.uint8,                             // Value to use for x-Ratio\r\n  yStartRatio:    r.uint8,                             // Starting y-Ratio value\r\n  yEndRatio:      r.uint8                              // Ending y-Ratio value\r\n});\r\n\r\nlet vTable = new r.Struct({\r\n  yPelHeight:     r.uint16,                            // yPelHeight to which values apply\r\n  yMax:           r.int16,                             // Maximum value (in pels) for this yPelHeight\r\n  yMin:           r.int16                              // Minimum value (in pels) for this yPelHeight\r\n});\r\n\r\nlet VdmxGroup = new r.Struct({\r\n  recs:           r.uint16,                            // Number of height records in this group\r\n  startsz:        r.uint8,                             // Starting yPelHeight\r\n  endsz:          r.uint8,                             // Ending yPelHeight\r\n  entries:        new r.Array(vTable, 'recs')          // The VDMX records\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:        r.uint16,                            // Version number (0 or 1)\r\n  numRecs:        r.uint16,                            // Number of VDMX groups present\r\n  numRatios:      r.uint16,                            // Number of aspect ratio groupings\r\n  ratioRanges:    new r.Array(Ratio, 'numRatios'),     // Ratio ranges\r\n  offsets:        new r.Array(r.uint16, 'numRatios'),  // Offset to the VDMX group for this ratio range\r\n  groups:         new r.Array(VdmxGroup, 'numRecs')    // The actual VDMX groupings\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// Vertical Header Table\r\nexport default new r.Struct({\r\n  version:                r.uint16,  // Version number of the Vertical Header Table\r\n  ascent:                 r.int16,   // The vertical typographic ascender for this font\r\n  descent:                r.int16,   // The vertical typographic descender for this font\r\n  lineGap:                r.int16,   // The vertical typographic line gap for this font\r\n  advanceHeightMax:       r.int16,   // The maximum advance height measurement found in the font\r\n  minTopSideBearing:      r.int16,   // The minimum top side bearing measurement found in the font\r\n  minBottomSideBearing:   r.int16,   // The minimum bottom side bearing measurement found in the font\r\n  yMaxExtent:             r.int16,\r\n  caretSlopeRise:         r.int16,   // Caret slope (rise/run)\r\n  caretSlopeRun:          r.int16,\r\n  caretOffset:            r.int16,   // Set value equal to 0 for nonslanted fonts\r\n  reserved:               new r.Reserved(r.int16, 4),\r\n  metricDataFormat:       r.int16,   // Set to 0\r\n  numberOfMetrics:        r.uint16   // Number of advance heights in the Vertical Metrics table\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet VmtxEntry = new r.Struct({\r\n  advance: r.uint16,  // The advance height of the glyph\r\n  bearing: r.int16    // The top sidebearing of the glyph\r\n});\r\n\r\n// Vertical Metrics Table\r\nexport default new r.Struct({\r\n  metrics:  new r.LazyArray(VmtxEntry, t => t.parent.vhea.numberOfMetrics),\r\n  bearings: new r.LazyArray(r.int16, t => t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet shortFrac = new r.Fixed(16, 'BE', 14);\r\n\r\nlet Correspondence = new r.Struct({\r\n  fromCoord: shortFrac,\r\n  toCoord: shortFrac\r\n});\r\n\r\nlet Segment = new r.Struct({\r\n  pairCount: r.uint16,\r\n  correspondence: new r.Array(Correspondence, 'pairCount')\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  axisCount: r.uint32,\r\n  segment: new r.Array(Segment, 'axisCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nclass UnboundedArrayAccessor {\r\n  constructor(type, stream, parent) {\r\n    this.type = type;\r\n    this.stream = stream;\r\n    this.parent = parent;\r\n    this.base = this.stream.pos;\r\n    this._items = [];\r\n  }\r\n\r\n  getItem(index) {\r\n    if (this._items[index] == null) {\r\n      let pos = this.stream.pos;\r\n      this.stream.pos = this.base + this.type.size(null, this.parent) * index;\r\n      this._items[index] = this.type.decode(this.stream, this.parent);\r\n      this.stream.pos = pos;\r\n    }\r\n\r\n    return this._items[index];\r\n  }\r\n\r\n  inspect() {\r\n    return `[UnboundedArray ${this.type.constructor.name}]`;\r\n  }\r\n}\r\n\r\nexport class UnboundedArray extends r.Array {\r\n  constructor(type) {\r\n    super(type, 0);\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    return new UnboundedArrayAccessor(this.type, stream, parent);\r\n  }\r\n}\r\n\r\nexport let LookupTable = function(ValueType = r.uint16) {\r\n  // Helper class that makes internal structures invisible to pointers\r\n  class Shadow {\r\n    constructor(type) {\r\n      this.type = type;\r\n    }\r\n\r\n    decode(stream, ctx) {\r\n      ctx = ctx.parent.parent;\r\n      return this.type.decode(stream, ctx);\r\n    }\r\n\r\n    size(val, ctx) {\r\n      ctx = ctx.parent.parent;\r\n      return this.type.size(val, ctx);\r\n    }\r\n\r\n    encode(stream, val, ctx) {\r\n      ctx = ctx.parent.parent;\r\n      return this.type.encode(stream, val, ctx);\r\n    }\r\n  }\r\n\r\n  ValueType = new Shadow(ValueType);\r\n\r\n  let BinarySearchHeader = new r.Struct({\r\n    unitSize: r.uint16,\r\n    nUnits: r.uint16,\r\n    searchRange: r.uint16,\r\n    entrySelector: r.uint16,\r\n    rangeShift: r.uint16\r\n  });\r\n\r\n  let LookupSegmentSingle = new r.Struct({\r\n    lastGlyph: r.uint16,\r\n    firstGlyph: r.uint16,\r\n    value: ValueType\r\n  });\r\n\r\n  let LookupSegmentArray = new r.Struct({\r\n    lastGlyph: r.uint16,\r\n    firstGlyph: r.uint16,\r\n    values: new r.Pointer(r.uint16, new r.Array(ValueType, t => t.lastGlyph - t.firstGlyph + 1), {type: 'parent'})\r\n  });\r\n\r\n  let LookupSingle = new r.Struct({\r\n    glyph: r.uint16,\r\n    value: ValueType\r\n  });\r\n\r\n  return new r.VersionedStruct(r.uint16, {\r\n    0: {\r\n      values: new UnboundedArray(ValueType) // length == number of glyphs maybe?\r\n    },\r\n    2: {\r\n      binarySearchHeader: BinarySearchHeader,\r\n      segments: new r.Array(LookupSegmentSingle, t => t.binarySearchHeader.nUnits)\r\n    },\r\n    4: {\r\n      binarySearchHeader: BinarySearchHeader,\r\n      segments: new r.Array(LookupSegmentArray, t => t.binarySearchHeader.nUnits)\r\n    },\r\n    6: {\r\n      binarySearchHeader: BinarySearchHeader,\r\n      segments: new r.Array(LookupSingle, t => t.binarySearchHeader.nUnits)\r\n    },\r\n    8: {\r\n      firstGlyph: r.uint16,\r\n      count: r.uint16,\r\n      values: new r.Array(ValueType, 'count')\r\n    }\r\n  });\r\n};\r\n\r\nexport function StateTable(entryData = {}, lookupType = r.uint16) {\r\n  let entry = Object.assign({\r\n    newState: r.uint16,\r\n    flags: r.uint16\r\n  }, entryData);\r\n\r\n  let Entry = new r.Struct(entry);\r\n  let StateArray = new UnboundedArray(new r.Array(r.uint16, t => t.nClasses));\r\n\r\n  let StateHeader = new r.Struct({\r\n    nClasses: r.uint32,\r\n    classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),\r\n    stateArray: new r.Pointer(r.uint32, StateArray),\r\n    entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))\r\n  });\r\n\r\n  return StateHeader;\r\n}\r\n\r\n// This is the old version of the StateTable structure\r\nexport function StateTable1(entryData = {}, lookupType = r.uint16) {\r\n  let ClassLookupTable = new r.Struct({\r\n    version() { return 8; }, // simulate LookupTable\r\n    firstGlyph: r.uint16,\r\n    values: new r.Array(r.uint8, r.uint16)\r\n  });\r\n\r\n  let entry = Object.assign({\r\n    newStateOffset: r.uint16,\r\n    // convert offset to stateArray index\r\n    newState: t => (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses,\r\n    flags: r.uint16\r\n  }, entryData);\r\n\r\n  let Entry = new r.Struct(entry);\r\n  let StateArray = new UnboundedArray(new r.Array(r.uint8, t => t.nClasses));\r\n\r\n  let StateHeader1 = new r.Struct({\r\n    nClasses: r.uint16,\r\n    classTable: new r.Pointer(r.uint16, ClassLookupTable),\r\n    stateArray: new r.Pointer(r.uint16, StateArray),\r\n    entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))\r\n  });\r\n\r\n  return StateHeader1;\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\nimport { LookupTable } from './aat';\r\n\r\nlet BslnSubtable = new r.VersionedStruct('format', {\r\n  0: { // Distance-based, no mapping\r\n    deltas: new r.Array(r.int16, 32)\r\n  },\r\n\r\n  1: { // Distance-based, with mapping\r\n    deltas: new r.Array(r.int16, 32),\r\n    mappingData: new LookupTable(r.uint16)\r\n  },\r\n\r\n  2: { // Control point-based, no mapping\r\n    standardGlyph: r.uint16,\r\n    controlPoints: new r.Array(r.uint16, 32)\r\n  },\r\n\r\n  3: { // Control point-based, with mapping\r\n    standardGlyph: r.uint16,\r\n    controlPoints: new r.Array(r.uint16, 32),\r\n    mappingData: new LookupTable(r.uint16)\r\n  }\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  format: r.uint16,\r\n  defaultBaseline: r.uint16,\r\n  subtable: BslnSubtable\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet Setting = new r.Struct({\r\n  setting: r.uint16,\r\n  nameIndex: r.int16,\r\n  name: t => t.parent.parent.parent.name.records.fontFeatures[t.nameIndex]\r\n});\r\n\r\nlet FeatureName = new r.Struct({\r\n  feature: r.uint16,\r\n  nSettings: r.uint16,\r\n  settingTable: new r.Pointer(r.uint32, new r.Array(Setting, 'nSettings'), { type: 'parent' }),\r\n  featureFlags: new r.Bitfield(r.uint8, [\r\n    null, null, null, null, null, null,\r\n    'hasDefault', 'exclusive'\r\n  ]),\r\n  defaultSetting: r.uint8,\r\n  nameIndex: r.int16,\r\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameIndex]\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  featureNameCount: r.uint16,\r\n  reserved1: new r.Reserved(r.uint16),\r\n  reserved2: new r.Reserved(r.uint32),\r\n  featureNames: new r.Array(FeatureName, 'featureNameCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet Axis = new r.Struct({\r\n  axisTag: new r.String(4),\r\n  minValue: r.fixed32,\r\n  defaultValue: r.fixed32,\r\n  maxValue: r.fixed32,\r\n  flags: r.uint16,\r\n  nameID: r.uint16,\r\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID]\r\n});\r\n\r\nlet Instance = new r.Struct({\r\n  nameID: r.uint16,\r\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID],\r\n  flags: r.uint16,\r\n  coord: new r.Array(r.fixed32, t => t.parent.axisCount),\r\n  postscriptNameID: new r.Optional(r.uint16, t => t.parent.instanceSize - t._currentOffset > 0)\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  offsetToData: r.uint16,\r\n  countSizePairs: r.uint16,\r\n  axisCount: r.uint16,\r\n  axisSize: r.uint16,\r\n  instanceCount: r.uint16,\r\n  instanceSize: r.uint16,\r\n  axis: new r.Array(Axis, 'axisCount'),\r\n  instance: new r.Array(Instance, 'instanceCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet shortFrac = new r.Fixed(16, 'BE', 14);\r\nclass Offset {\r\n  static decode(stream, parent) {\r\n    // In short format, offsets are multiplied by 2.\r\n    // This doesn't seem to be documented by Apple, but it\r\n    // is implemented this way in Freetype.\r\n    return parent.flags\r\n      ? stream.readUInt32BE()\r\n      : stream.readUInt16BE() * 2;\r\n  }\r\n}\r\n\r\nlet gvar = new r.Struct({\r\n  version: r.uint16,\r\n  reserved: new r.Reserved(r.uint16),\r\n  axisCount: r.uint16,\r\n  globalCoordCount: r.uint16,\r\n  globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac, 'axisCount'), 'globalCoordCount')),\r\n  glyphCount: r.uint16,\r\n  flags: r.uint16,\r\n  offsetToData: r.uint32,\r\n  offsets: new r.Array(new r.Pointer(Offset, 'void', { relativeTo: ctx => ctx.offsetToData, allowNull: false }), t => t.glyphCount + 1)\r\n});\r\n\r\nexport default gvar;\r\n","import r from '@foliojs-fork/restructure';\r\nimport { LookupTable, StateTable1 } from './aat';\r\n\r\nlet ClassTable = new r.Struct({\r\n  length: r.uint16,\r\n  coverage: r.uint16,\r\n  subFeatureFlags: r.uint32,\r\n  stateTable: new StateTable1\r\n});\r\n\r\nlet WidthDeltaRecord = new r.Struct({\r\n  justClass: r.uint32,\r\n  beforeGrowLimit: r.fixed32,\r\n  beforeShrinkLimit: r.fixed32,\r\n  afterGrowLimit: r.fixed32,\r\n  afterShrinkLimit: r.fixed32,\r\n  growFlags: r.uint16,\r\n  shrinkFlags: r.uint16\r\n});\r\n\r\nlet WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);\r\n\r\nlet ActionData = new r.VersionedStruct('actionType', {\r\n  0: { // Decomposition action\r\n    lowerLimit: r.fixed32,\r\n    upperLimit: r.fixed32,\r\n    order: r.uint16,\r\n    glyphs: new r.Array(r.uint16, r.uint16)\r\n  },\r\n\r\n  1: { // Unconditional add glyph action\r\n    addGlyph: r.uint16\r\n  },\r\n\r\n  2: { // Conditional add glyph action\r\n    substThreshold: r.fixed32,\r\n    addGlyph: r.uint16,\r\n    substGlyph: r.uint16\r\n  },\r\n\r\n  3: {}, // Stretch glyph action (no data, not supported by CoreText)\r\n\r\n  4: { // Ductile glyph action (not supported by CoreText)\r\n    variationAxis: r.uint32,\r\n    minimumLimit: r.fixed32,\r\n    noStretchValue: r.fixed32,\r\n    maximumLimit: r.fixed32\r\n  },\r\n\r\n  5: { // Repeated add glyph action\r\n    flags: r.uint16,\r\n    glyph: r.uint16\r\n  }\r\n});\r\n\r\nlet Action = new r.Struct({\r\n  actionClass: r.uint16,\r\n  actionType: r.uint16,\r\n  actionLength: r.uint32,\r\n  actionData: ActionData,\r\n  padding: new r.Reserved(r.uint8, t => t.actionLength - t._currentOffset)\r\n});\r\n\r\nlet PostcompensationAction = new r.Array(Action, r.uint32);\r\nlet PostCompensationTable = new r.Struct({\r\n  lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction))\r\n});\r\n\r\nlet JustificationTable = new r.Struct({\r\n  classTable: new r.Pointer(r.uint16, ClassTable, { type: 'parent' }),\r\n  wdcOffset: r.uint16,\r\n  postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, { type: 'parent' }),\r\n  widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, { type: 'parent', relativeTo: ctx => ctx.wdcOffset }))\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.uint32,\r\n  format: r.uint16,\r\n  horizontal: new r.Pointer(r.uint16, JustificationTable),\r\n  vertical: new r.Pointer(r.uint16, JustificationTable)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport { UnboundedArray, LookupTable, StateTable } from './aat';\r\n\r\nlet LigatureData = {\r\n  action: r.uint16\r\n};\r\n\r\nlet ContextualData = {\r\n  markIndex: r.uint16,\r\n  currentIndex: r.uint16\r\n};\r\n\r\nlet InsertionData = {\r\n  currentInsertIndex: r.uint16,\r\n  markedInsertIndex: r.uint16\r\n};\r\n\r\nlet SubstitutionTable = new r.Struct({\r\n  items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable))\r\n});\r\n\r\nlet SubtableData = new r.VersionedStruct('type', {\r\n  0: { // Indic Rearrangement Subtable\r\n    stateTable: new StateTable\r\n  },\r\n\r\n  1: { // Contextual Glyph Substitution Subtable\r\n    stateTable: new StateTable(ContextualData),\r\n    substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)\r\n  },\r\n\r\n  2: { // Ligature subtable\r\n    stateTable: new StateTable(LigatureData),\r\n    ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),\r\n    components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),\r\n    ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\r\n  },\r\n\r\n  4: { // Non-contextual Glyph Substitution Subtable\r\n    lookupTable: new LookupTable\r\n  },\r\n\r\n  5: { // Glyph Insertion Subtable\r\n    stateTable: new StateTable(InsertionData),\r\n    insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\r\n  }\r\n});\r\n\r\nlet Subtable = new r.Struct({\r\n  length: r.uint32,\r\n  coverage: r.uint24,\r\n  type: r.uint8,\r\n  subFeatureFlags: r.uint32,\r\n  table: SubtableData,\r\n  padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\r\n});\r\n\r\nlet FeatureEntry = new r.Struct({\r\n  featureType:    r.uint16,\r\n  featureSetting: r.uint16,\r\n  enableFlags:    r.uint32,\r\n  disableFlags:   r.uint32\r\n});\r\n\r\nlet MorxChain = new r.Struct({\r\n  defaultFlags:     r.uint32,\r\n  chainLength:      r.uint32,\r\n  nFeatureEntries:  r.uint32,\r\n  nSubtables:       r.uint32,\r\n  features:         new r.Array(FeatureEntry, 'nFeatureEntries'),\r\n  subtables:        new r.Array(Subtable, 'nSubtables')\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:  r.uint16,\r\n  unused:   new r.Reserved(r.uint16),\r\n  nChains:  r.uint32,\r\n  chains:   new r.Array(MorxChain, 'nChains')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport { LookupTable } from './aat';\r\n\r\nlet OpticalBounds = new r.Struct({\r\n  left: r.int16,\r\n  top: r.int16,\r\n  right: r.int16,\r\n  bottom: r.int16\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  format: r.uint16,\r\n  lookupTable: new LookupTable(OpticalBounds)\r\n});\r\n","let tables = {};\r\nexport default tables;\r\n\r\n// Required Tables\r\nimport cmap from './cmap';\r\nimport head from './head';\r\nimport hhea from './hhea';\r\nimport hmtx from './hmtx';\r\nimport maxp from './maxp';\r\nimport name from './name';\r\nimport OS2 from './OS2';\r\nimport post from './post';\r\n\r\ntables.cmap = cmap;\r\ntables.head = head;\r\ntables.hhea = hhea;\r\ntables.hmtx = hmtx;\r\ntables.maxp = maxp;\r\ntables.name = name;\r\ntables['OS/2'] = OS2;\r\ntables.post = post;\r\n\r\n\r\n// TrueType Outlines\r\nimport cvt from './cvt';\r\nimport fpgm from './fpgm';\r\nimport loca from './loca';\r\nimport prep from './prep';\r\nimport glyf from './glyf';\r\n\r\ntables.fpgm = fpgm;\r\ntables.loca = loca;\r\ntables.prep = prep;\r\ntables['cvt '] = cvt;\r\ntables.glyf = glyf;\r\n\r\n\r\n// PostScript Outlines\r\nimport CFFFont from '../cff/CFFFont';\r\nimport VORG from './VORG';\r\n\r\ntables['CFF '] = CFFFont;\r\ntables['CFF2'] = CFFFont;\r\ntables.VORG = VORG;\r\n\r\n\r\n// Bitmap Glyphs\r\nimport EBLC from './EBLC';\r\nimport sbix from './sbix';\r\nimport COLR from './COLR';\r\nimport CPAL from './CPAL';\r\n\r\ntables.EBLC = EBLC;\r\ntables.CBLC = tables.EBLC;\r\ntables.sbix = sbix;\r\ntables.COLR = COLR;\r\ntables.CPAL = CPAL;\r\n\r\n\r\n// Advanced OpenType Tables\r\nimport BASE from './BASE';\r\nimport GDEF from './GDEF';\r\nimport GPOS from './GPOS';\r\nimport GSUB from './GSUB';\r\nimport JSTF from './JSTF';\r\n\r\ntables.BASE = BASE;\r\ntables.GDEF = GDEF;\r\ntables.GPOS = GPOS;\r\ntables.GSUB = GSUB;\r\ntables.JSTF = JSTF;\r\n\r\n// OpenType variations tables\r\nimport HVAR from './HVAR';\r\n\r\ntables.HVAR = HVAR;\r\n\r\n// Other OpenType Tables\r\nimport DSIG from './DSIG';\r\nimport gasp from './gasp';\r\nimport hdmx from './hdmx';\r\nimport kern from './kern';\r\nimport LTSH from './LTSH';\r\nimport PCLT from './PCLT';\r\nimport VDMX from './VDMX';\r\nimport vhea from './vhea';\r\nimport vmtx from './vmtx';\r\n\r\ntables.DSIG = DSIG;\r\ntables.gasp = gasp;\r\ntables.hdmx = hdmx;\r\ntables.kern = kern;\r\ntables.LTSH = LTSH;\r\ntables.PCLT = PCLT;\r\ntables.VDMX = VDMX;\r\ntables.vhea = vhea;\r\ntables.vmtx = vmtx;\r\n\r\n\r\n// Apple Advanced Typography Tables\r\nimport avar from './avar';\r\nimport bsln from './bsln';\r\nimport feat from './feat';\r\nimport fvar from './fvar';\r\nimport gvar from './gvar';\r\nimport just from './just';\r\nimport morx from './morx';\r\nimport opbd from './opbd';\r\n\r\ntables.avar = avar;\r\ntables.bsln = bsln;\r\ntables.feat = feat;\r\ntables.fvar = fvar;\r\ntables.gvar = gvar;\r\ntables.just = just;\r\ntables.morx = morx;\r\ntables.opbd = opbd;\r\n","import r from '@foliojs-fork/restructure';\r\nimport Tables from './';\r\n\r\nlet TableEntry = new r.Struct({\r\n  tag:        new r.String(4),\r\n  checkSum:   r.uint32,\r\n  offset:     new r.Pointer(r.uint32, 'void', { type: 'global' }),\r\n  length:     r.uint32\r\n});\r\n\r\nlet Directory = new r.Struct({\r\n  tag:            new r.String(4),\r\n  numTables:      r.uint16,\r\n  searchRange:    r.uint16,\r\n  entrySelector:  r.uint16,\r\n  rangeShift:     r.uint16,\r\n  tables:         new r.Array(TableEntry, 'numTables')\r\n});\r\n\r\nDirectory.process = function() {\r\n  let tables = {};\r\n  for (let table of this.tables) {\r\n    tables[table.tag] = table;\r\n  }\r\n\r\n  this.tables = tables;\r\n};\r\n\r\nDirectory.preEncode = function(stream) {\r\n  let tables = [];\r\n  for (let tag in this.tables) {\r\n    let table = this.tables[tag];\r\n    if (table) {\r\n      tables.push({\r\n        tag: tag,\r\n        checkSum: 0,\r\n        offset: new r.VoidPointer(Tables[tag], table),\r\n        length: Tables[tag].size(table)\r\n      });\r\n    }\r\n  }\r\n\r\n  this.tag = 'true';\r\n  this.numTables = tables.length;\r\n  this.tables = tables;\r\n\r\n  let maxExponentFor2 = Math.floor((Math.log(this.numTables) / Math.LN2));\r\n  let maxPowerOf2 = Math.pow(2, maxExponentFor2);\r\n\r\n  this.searchRange =  maxPowerOf2 * 16;\r\n  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;\r\n  this.rangeShift = this.numTables * 16 - this.searchRange;\r\n};\r\n\r\nexport default Directory;\r\n","export function binarySearch(arr, cmp) {\r\n  let min = 0;\r\n  let max = arr.length - 1;\r\n  while (min <= max) {\r\n    let mid = (min + max) >> 1;\r\n    let res = cmp(arr[mid]);\r\n\r\n    if (res < 0) {\r\n      max = mid - 1;\r\n    } else if (res > 0) {\r\n      min = mid + 1;\r\n    } else {\r\n      return mid;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nexport function range(index, end) {\r\n  let range = [];\r\n  while (index < end) {\r\n    range.push(index++);\r\n  }\r\n  return range;\r\n}\r\n","import {binarySearch} from './utils';\r\nimport {getEncoding} from './encodings';\r\nimport {cache} from './decorators';\r\nimport {range} from './utils';\r\n\r\n// iconv-lite is an optional dependency.\r\ntry {\r\n  var iconv = require('iconv-lite');\r\n} catch (err) {}\r\n\r\nexport default class CmapProcessor {\r\n  constructor(cmapTable) {\r\n    // Attempt to find a Unicode cmap first\r\n    this.encoding = null;\r\n    this.cmap = this.findSubtable(cmapTable, [\r\n      // 32-bit subtables\r\n      [3, 10],\r\n      [0, 6],\r\n      [0, 4],\r\n\r\n      // 16-bit subtables\r\n      [3, 1],\r\n      [0, 3],\r\n      [0, 2],\r\n      [0, 1],\r\n      [0, 0]\r\n    ]);\r\n\r\n    // If not unicode cmap was found, and iconv-lite is installed,\r\n    // take the first table with a supported encoding.\r\n    if (!this.cmap && iconv) {\r\n      for (let cmap of cmapTable.tables) {\r\n        let encoding = getEncoding(cmap.platformID, cmap.encodingID, cmap.table.language - 1);\r\n        if (iconv.encodingExists(encoding)) {\r\n          this.cmap = cmap.table;\r\n          this.encoding = encoding;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!this.cmap) {\r\n      throw new Error(\"Could not find a supported cmap table\");\r\n    }\r\n\r\n    this.uvs = this.findSubtable(cmapTable, [[0, 5]]);\r\n    if (this.uvs && this.uvs.version !== 14) {\r\n      this.uvs = null;\r\n    }\r\n  }\r\n\r\n  findSubtable(cmapTable, pairs) {\r\n    for (let [platformID, encodingID] of pairs) {\r\n      for (let cmap of cmapTable.tables) {\r\n        if (cmap.platformID === platformID && cmap.encodingID === encodingID) {\r\n          return cmap.table;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  lookup(codepoint, variationSelector) {\r\n    // If there is no Unicode cmap in this font, we need to re-encode\r\n    // the codepoint in the encoding that the cmap supports.\r\n    if (this.encoding) {\r\n      let buf = iconv.encode(String.fromCodePoint(codepoint), this.encoding);\r\n      codepoint = 0;\r\n      for (let i = 0; i < buf.length; i++) {\r\n        codepoint = (codepoint << 8) | buf[i];\r\n      }\r\n\r\n    // Otherwise, try to get a Unicode variation selector for this codepoint if one is provided.\r\n    } else if (variationSelector) {\r\n      let gid = this.getVariationSelector(codepoint, variationSelector);\r\n      if (gid) {\r\n        return gid;\r\n      }\r\n    }\r\n\r\n    let cmap = this.cmap;\r\n    switch (cmap.version) {\r\n      case 0:\r\n        return cmap.codeMap.get(codepoint) || 0;\r\n\r\n      case 4: {\r\n        let min = 0;\r\n        let max = cmap.segCount - 1;\r\n        while (min <= max) {\r\n          let mid = (min + max) >> 1;\r\n\r\n          if (codepoint < cmap.startCode.get(mid)) {\r\n            max = mid - 1;\r\n          } else if (codepoint > cmap.endCode.get(mid)) {\r\n            min = mid + 1;\r\n          } else {\r\n            let rangeOffset = cmap.idRangeOffset.get(mid);\r\n            let gid;\r\n\r\n            if (rangeOffset === 0) {\r\n              gid = codepoint + cmap.idDelta.get(mid);\r\n            } else {\r\n              let index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);\r\n              gid = cmap.glyphIndexArray.get(index) || 0;\r\n              if (gid !== 0) {\r\n                gid += cmap.idDelta.get(mid);\r\n              }\r\n            }\r\n\r\n            return gid & 0xffff;\r\n          }\r\n        }\r\n\r\n        return 0;\r\n      }\r\n\r\n      case 8:\r\n        throw new Error('TODO: cmap format 8');\r\n\r\n      case 6:\r\n      case 10:\r\n        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;\r\n\r\n      case 12:\r\n      case 13: {\r\n        let min = 0;\r\n        let max = cmap.nGroups - 1;\r\n        while (min <= max) {\r\n          let mid = (min + max) >> 1;\r\n          let group = cmap.groups.get(mid);\r\n\r\n          if (codepoint < group.startCharCode) {\r\n            max = mid - 1;\r\n          } else if (codepoint > group.endCharCode) {\r\n            min = mid + 1;\r\n          } else {\r\n            if (cmap.version === 12) {\r\n              return group.glyphID + (codepoint - group.startCharCode);\r\n            } else {\r\n              return group.glyphID;\r\n            }\r\n          }\r\n        }\r\n\r\n        return 0;\r\n      }\r\n\r\n      case 14:\r\n        throw new Error('TODO: cmap format 14');\r\n\r\n      default:\r\n        throw new Error(`Unknown cmap format ${cmap.version}`);\r\n    }\r\n  }\r\n\r\n  getVariationSelector(codepoint, variationSelector) {\r\n    if (!this.uvs) {\r\n      return 0;\r\n    }\r\n\r\n    let selectors = this.uvs.varSelectors.toArray();\r\n    let i = binarySearch(selectors, x => variationSelector - x.varSelector);\r\n    let sel = selectors[i];\r\n\r\n    if (i !== -1 && sel.defaultUVS) {\r\n      i = binarySearch(sel.defaultUVS, x =>\r\n        codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? +1 : 0\r\n      );\r\n    }\r\n\r\n    if (i !== -1 && sel.nonDefaultUVS) {\r\n      i = binarySearch(sel.nonDefaultUVS, x => codepoint - x.unicodeValue);\r\n      if (i !== -1) {\r\n        return sel.nonDefaultUVS[i].glyphID;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  @cache\r\n  getCharacterSet() {\r\n    let cmap = this.cmap;\r\n    switch (cmap.version) {\r\n      case 0:\r\n        return range(0, cmap.codeMap.length);\r\n\r\n      case 4: {\r\n        let res = [];\r\n        let endCodes = cmap.endCode.toArray();\r\n        for (let i = 0; i < endCodes.length; i++) {\r\n          let tail = endCodes[i] + 1;\r\n          let start = cmap.startCode.get(i);\r\n          res.push(...range(start, tail));\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 8:\r\n        throw new Error('TODO: cmap format 8');\r\n\r\n      case 6:\r\n      case 10:\r\n        return range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);\r\n\r\n      case 12:\r\n      case 13: {\r\n        let res = [];\r\n        for (let group of cmap.groups.toArray()) {\r\n          res.push(...range(group.startCharCode, group.endCharCode + 1));\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 14:\r\n        throw new Error('TODO: cmap format 14');\r\n\r\n      default:\r\n        throw new Error(`Unknown cmap format ${cmap.version}`);\r\n    }\r\n  }\r\n\r\n  @cache\r\n  codePointsForGlyph(gid) {\r\n    let cmap = this.cmap;\r\n    switch (cmap.version) {\r\n      case 0: {\r\n        let res = [];\r\n        for (let i = 0; i < 256; i++) {\r\n          if (cmap.codeMap.get(i) === gid) {\r\n            res.push(i);\r\n          }\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 4: {\r\n        let res = [];\r\n        for (let i = 0; i < cmap.segCount; i++) {\r\n          let end = cmap.endCode.get(i);\r\n          let start = cmap.startCode.get(i);\r\n          let rangeOffset = cmap.idRangeOffset.get(i);\r\n          let delta = cmap.idDelta.get(i);\r\n\r\n          for (var c = start; c <= end; c++) {\r\n            let g = 0;\r\n            if (rangeOffset === 0) {\r\n              g = c + delta;\r\n            } else {\r\n              let index = rangeOffset / 2 + (c - start) - (cmap.segCount - i);\r\n              g = cmap.glyphIndexArray.get(index) || 0;\r\n              if (g !== 0) {\r\n                g += delta;\r\n              }\r\n            }\r\n\r\n            if (g === gid) {\r\n              res.push(c);\r\n            }\r\n          }\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 12: {\r\n        let res = [];\r\n        for (let group of cmap.groups.toArray()) {\r\n          if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {\r\n            res.push(group.startCharCode + (gid - group.glyphID));\r\n          }\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 13: {\r\n        let res = [];\r\n        for (let group of cmap.groups.toArray()) {\r\n          if (gid === group.glyphID) {\r\n            res.push(...range(group.startCharCode, group.endCharCode + 1));\r\n          }\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      default:\r\n        throw new Error(`Unknown cmap format ${cmap.version}`);\r\n    }\r\n  }\r\n}\r\n","import {binarySearch} from '../utils';\r\n\r\nexport default class KernProcessor {\r\n  constructor(font) {\r\n    this.kern = font.kern;\r\n  }\r\n\r\n  process(glyphs, positions) {\r\n    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {\r\n      let left = glyphs[glyphIndex].id;\r\n      let right = glyphs[glyphIndex + 1].id;\r\n      positions[glyphIndex].xAdvance += this.getKerning(left, right);\r\n    }\r\n  }\r\n\r\n  getKerning(left, right) {\r\n    let res = 0;\r\n\r\n    for (let table of this.kern.tables) {\r\n      if (table.coverage.crossStream) {\r\n        continue;\r\n      }\r\n\r\n      switch (table.version) {\r\n        case 0:\r\n          if (!table.coverage.horizontal) {\r\n            continue;\r\n          }\r\n\r\n          break;\r\n        case 1:\r\n          if (table.coverage.vertical || table.coverage.variation) {\r\n            continue;\r\n          }\r\n\r\n          break;\r\n        default:\r\n          throw new Error(`Unsupported kerning table version ${table.version}`);\r\n      }\r\n\r\n      let val = 0;\r\n      let s = table.subtable;\r\n      switch (table.format) {\r\n        case 0:\r\n          let pairIdx = binarySearch(s.pairs, function (pair) {\r\n            return (left - pair.left) || (right - pair.right);\r\n          });\r\n\r\n          if (pairIdx >= 0) {\r\n            val = s.pairs[pairIdx].value;\r\n          }\r\n\r\n          break;\r\n\r\n        case 2:\r\n          let leftOffset = 0, rightOffset = 0;\r\n          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {\r\n            leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];\r\n          } else {\r\n            leftOffset = s.array.off;\r\n          }\r\n\r\n          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {\r\n            rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];\r\n          }\r\n\r\n          let index = (leftOffset + rightOffset - s.array.off) / 2;\r\n          val = s.array.values.get(index);\r\n          break;\r\n\r\n        case 3:\r\n          if (left >= s.glyphCount || right >= s.glyphCount) {\r\n            return 0;\r\n          }\r\n\r\n          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];\r\n          break;\r\n\r\n        default:\r\n          throw new Error(`Unsupported kerning sub-table format ${table.format}`);\r\n      }\r\n\r\n      // Microsoft supports the override flag, which resets the result\r\n      // Otherwise, the sum of the results from all subtables is returned\r\n      if (table.coverage.override) {\r\n        res = val;\r\n      } else {\r\n        res += val;\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n}\r\n","import unicode from 'unicode-properties';\r\n\r\n/**\r\n * This class is used when GPOS does not define 'mark' or 'mkmk' features\r\n * for positioning marks relative to base glyphs. It uses the unicode\r\n * combining class property to position marks.\r\n *\r\n * Based on code from Harfbuzz, thanks!\r\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-fallback.cc\r\n */\r\nexport default class UnicodeLayoutEngine {\r\n  constructor(font) {\r\n    this.font = font;\r\n  }\r\n\r\n  positionGlyphs(glyphs, positions) {\r\n    // find each base + mark cluster, and position the marks relative to the base\r\n    let clusterStart = 0;\r\n    let clusterEnd = 0;\r\n    for (let index = 0; index < glyphs.length; index++) {\r\n      let glyph = glyphs[index];\r\n      if (glyph.isMark) { // TODO: handle ligatures\r\n        clusterEnd = index;\r\n      } else {\r\n        if (clusterStart !== clusterEnd) {\r\n          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\r\n        }\r\n\r\n        clusterStart = clusterEnd = index;\r\n      }\r\n    }\r\n\r\n    if (clusterStart !== clusterEnd) {\r\n      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\r\n    }\r\n\r\n    return positions;\r\n  }\r\n\r\n  positionCluster(glyphs, positions, clusterStart, clusterEnd) {\r\n    let base = glyphs[clusterStart];\r\n    let baseBox = base.cbox.copy();\r\n\r\n    // adjust bounding box for ligature glyphs\r\n    if (base.codePoints.length > 1) {\r\n      // LTR. TODO: RTL support.\r\n      baseBox.minX += ((base.codePoints.length - 1) * baseBox.width) / base.codePoints.length;\r\n    }\r\n\r\n    let xOffset = -positions[clusterStart].xAdvance;\r\n    let yOffset = 0;\r\n    let yGap = this.font.unitsPerEm / 16;\r\n\r\n    // position each of the mark glyphs relative to the base glyph\r\n    for (let index = clusterStart + 1; index <= clusterEnd; index++) {\r\n      let mark = glyphs[index];\r\n      let markBox = mark.cbox;\r\n      let position = positions[index];\r\n\r\n      let combiningClass = this.getCombiningClass(mark.codePoints[0]);\r\n\r\n      if (combiningClass !== 'Not_Reordered') {\r\n        position.xOffset = position.yOffset = 0;\r\n\r\n        // x positioning\r\n        switch (combiningClass) {\r\n          case 'Double_Above':\r\n          case 'Double_Below':\r\n            // LTR. TODO: RTL support.\r\n            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;\r\n            break;\r\n\r\n          case 'Attached_Below_Left':\r\n          case 'Below_Left':\r\n          case 'Above_Left':\r\n            // left align\r\n            position.xOffset += baseBox.minX - markBox.minX;\r\n            break;\r\n\r\n          case 'Attached_Above_Right':\r\n          case 'Below_Right':\r\n          case 'Above_Right':\r\n            // right align\r\n            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;\r\n            break;\r\n\r\n          default: // Attached_Below, Attached_Above, Below, Above, other\r\n            // center align\r\n            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;\r\n        }\r\n\r\n        // y positioning\r\n        switch (combiningClass) {\r\n          case 'Double_Below':\r\n          case 'Below_Left':\r\n          case 'Below':\r\n          case 'Below_Right':\r\n          case 'Attached_Below_Left':\r\n          case 'Attached_Below':\r\n            // add a small gap between the glyphs if they are not attached\r\n            if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {\r\n              baseBox.minY += yGap;\r\n            }\r\n\r\n            position.yOffset = -baseBox.minY - markBox.maxY;\r\n            baseBox.minY += markBox.height;\r\n            break;\r\n\r\n          case 'Double_Above':\r\n          case 'Above_Left':\r\n          case 'Above':\r\n          case 'Above_Right':\r\n          case 'Attached_Above':\r\n          case 'Attached_Above_Right':\r\n            // add a small gap between the glyphs if they are not attached\r\n            if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {\r\n              baseBox.maxY += yGap;\r\n            }\r\n\r\n            position.yOffset = baseBox.maxY - markBox.minY;\r\n            baseBox.maxY += markBox.height;\r\n            break;\r\n        }\r\n\r\n        position.xAdvance = position.yAdvance = 0;\r\n        position.xOffset += xOffset;\r\n        position.yOffset += yOffset;\r\n\r\n      } else {\r\n        xOffset -= position.xAdvance;\r\n        yOffset -= position.yAdvance;\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  getCombiningClass(codePoint) {\r\n    let combiningClass = unicode.getCombiningClass(codePoint);\r\n\r\n    // Thai / Lao need some per-character work\r\n    if ((codePoint & ~0xff) === 0x0e00) {\r\n      if (combiningClass === 'Not_Reordered') {\r\n        switch (codePoint) {\r\n          case 0x0e31:\r\n          case 0x0e34:\r\n          case 0x0e35:\r\n          case 0x0e36:\r\n          case 0x0e37:\r\n          case 0x0e47:\r\n          case 0x0e4c:\r\n          case 0x0e3d:\r\n          case 0x0e4e:\r\n            return 'Above_Right';\r\n\r\n          case 0x0eb1:\r\n          case 0x0eb4:\r\n          case 0x0eb5:\r\n          case 0x0eb6:\r\n          case 0x0eb7:\r\n          case 0x0ebb:\r\n          case 0x0ecc:\r\n          case 0x0ecd:\r\n            return 'Above';\r\n\r\n          case 0x0ebc:\r\n            return 'Below';\r\n        }\r\n      } else if (codePoint === 0x0e3a) { // virama\r\n        return 'Below_Right';\r\n      }\r\n    }\r\n\r\n    switch (combiningClass) {\r\n      // Hebrew\r\n\r\n      case 'CCC10': // sheva\r\n      case 'CCC11': // hataf segol\r\n      case 'CCC12': // hataf patah\r\n      case 'CCC13': // hataf qamats\r\n      case 'CCC14': // hiriq\r\n      case 'CCC15': // tsere\r\n      case 'CCC16': // segol\r\n      case 'CCC17': // patah\r\n      case 'CCC18': // qamats\r\n      case 'CCC20': // qubuts\r\n      case 'CCC22': // meteg\r\n        return 'Below';\r\n\r\n      case 'CCC23': // rafe\r\n        return 'Attached_Above';\r\n\r\n      case 'CCC24': // shin dot\r\n        return 'Above_Right';\r\n\r\n      case 'CCC25': // sin dot\r\n      case 'CCC19': // holam\r\n        return 'Above_Left';\r\n\r\n      case 'CCC26': // point varika\r\n        return 'Above';\r\n\r\n      case 'CCC21': // dagesh\r\n        break;\r\n\r\n      // Arabic and Syriac\r\n\r\n      case 'CCC27': // fathatan\r\n      case 'CCC28': // dammatan\r\n      case 'CCC30': // fatha\r\n      case 'CCC31': // damma\r\n      case 'CCC33': // shadda\r\n      case 'CCC34': // sukun\r\n      case 'CCC35': // superscript alef\r\n      case 'CCC36': // superscript alaph\r\n        return 'Above';\r\n\r\n      case 'CCC29': // kasratan\r\n      case 'CCC32': // kasra\r\n        return 'Below';\r\n\r\n      // Thai\r\n\r\n      case 'CCC103': // sara u / sara uu\r\n        return 'Below_Right';\r\n\r\n      case 'CCC107': // mai\r\n        return 'Above_Right';\r\n\r\n      // Lao\r\n\r\n      case 'CCC118': // sign u / sign uu\r\n        return 'Below';\r\n\r\n      case 'CCC122': // mai\r\n        return 'Above';\r\n\r\n      // Tibetan\r\n\r\n      case 'CCC129': // sign aa\r\n      case 'CCC132': // sign u\r\n        return 'Below';\r\n\r\n      case 'CCC130': // sign i\r\n        return 'Above';\r\n    }\r\n\r\n    return combiningClass;\r\n  }\r\n}\r\n","/**\r\n * Represents a glyph bounding box\r\n */\r\nexport default class BBox {\r\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\r\n    /**\r\n     * The minimum X position in the bounding box\r\n     * @type {number}\r\n     */\r\n    this.minX = minX;\r\n\r\n    /**\r\n     * The minimum Y position in the bounding box\r\n     * @type {number}\r\n     */\r\n    this.minY = minY;\r\n\r\n    /**\r\n     * The maxmimum X position in the bounding box\r\n     * @type {number}\r\n     */\r\n    this.maxX = maxX;\r\n\r\n    /**\r\n     * The maxmimum Y position in the bounding box\r\n     * @type {number}\r\n     */\r\n    this.maxY = maxY;\r\n  }\r\n\r\n  /**\r\n   * The width of the bounding box\r\n   * @type {number}\r\n   */\r\n  get width() {\r\n    return this.maxX - this.minX;\r\n  }\r\n\r\n  /**\r\n   * The height of the bounding box\r\n   * @type {number}\r\n   */\r\n  get height() {\r\n    return this.maxY - this.minY;\r\n  }\r\n\r\n  addPoint(x, y) {\r\n    if (Math.abs(x) !== Infinity) {\r\n      if (x < this.minX) {\r\n        this.minX = x;\r\n      }\r\n\r\n      if (x > this.maxX) {\r\n        this.maxX = x;\r\n      }\r\n    }\r\n\r\n    if (Math.abs(y) !== Infinity) {\r\n      if (y < this.minY) {\r\n        this.minY = y;\r\n      }\r\n\r\n      if (y > this.maxY) {\r\n        this.maxY = y;\r\n      }\r\n    }\r\n  }\r\n\r\n  copy() {\r\n    return new BBox(this.minX, this.minY, this.maxX, this.maxY);\r\n  }\r\n}\r\n","import unicode from 'unicode-properties';\r\n\r\n// This maps the Unicode Script property to an OpenType script tag\r\n// Data from http://www.microsoft.com/typography/otspec/scripttags.htm\r\n// and http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt.\r\nconst UNICODE_SCRIPTS = {\r\n  Caucasian_Albanian: 'aghb',\r\n  Arabic: 'arab',\r\n  Imperial_Aramaic: 'armi',\r\n  Armenian: 'armn',\r\n  Avestan: 'avst',\r\n  Balinese: 'bali',\r\n  Bamum: 'bamu',\r\n  Bassa_Vah: 'bass',\r\n  Batak: 'batk',\r\n  Bengali: ['bng2', 'beng'],\r\n  Bopomofo: 'bopo',\r\n  Brahmi: 'brah',\r\n  Braille: 'brai',\r\n  Buginese: 'bugi',\r\n  Buhid: 'buhd',\r\n  Chakma: 'cakm',\r\n  Canadian_Aboriginal: 'cans',\r\n  Carian: 'cari',\r\n  Cham: 'cham',\r\n  Cherokee: 'cher',\r\n  Coptic: 'copt',\r\n  Cypriot: 'cprt',\r\n  Cyrillic: 'cyrl',\r\n  Devanagari: ['dev2', 'deva'],\r\n  Deseret: 'dsrt',\r\n  Duployan: 'dupl',\r\n  Egyptian_Hieroglyphs: 'egyp',\r\n  Elbasan: 'elba',\r\n  Ethiopic: 'ethi',\r\n  Georgian: 'geor',\r\n  Glagolitic: 'glag',\r\n  Gothic: 'goth',\r\n  Grantha: 'gran',\r\n  Greek: 'grek',\r\n  Gujarati: ['gjr2', 'gujr'],\r\n  Gurmukhi: ['gur2', 'guru'],\r\n  Hangul: 'hang',\r\n  Han: 'hani',\r\n  Hanunoo: 'hano',\r\n  Hebrew: 'hebr',\r\n  Hiragana: 'hira',\r\n  Pahawh_Hmong: 'hmng',\r\n  Katakana_Or_Hiragana: 'hrkt',\r\n  Old_Italic: 'ital',\r\n  Javanese: 'java',\r\n  Kayah_Li: 'kali',\r\n  Katakana: 'kana',\r\n  Kharoshthi: 'khar',\r\n  Khmer: 'khmr',\r\n  Khojki: 'khoj',\r\n  Kannada: ['knd2', 'knda'],\r\n  Kaithi: 'kthi',\r\n  Tai_Tham: 'lana',\r\n  Lao: 'lao ',\r\n  Latin: 'latn',\r\n  Lepcha: 'lepc',\r\n  Limbu: 'limb',\r\n  Linear_A: 'lina',\r\n  Linear_B: 'linb',\r\n  Lisu: 'lisu',\r\n  Lycian: 'lyci',\r\n  Lydian: 'lydi',\r\n  Mahajani: 'mahj',\r\n  Mandaic: 'mand',\r\n  Manichaean: 'mani',\r\n  Mende_Kikakui: 'mend',\r\n  Meroitic_Cursive: 'merc',\r\n  Meroitic_Hieroglyphs: 'mero',\r\n  Malayalam: ['mlm2', 'mlym'],\r\n  Modi: 'modi',\r\n  Mongolian: 'mong',\r\n  Mro: 'mroo',\r\n  Meetei_Mayek: 'mtei',\r\n  Myanmar: ['mym2', 'mymr'],\r\n  Old_North_Arabian: 'narb',\r\n  Nabataean: 'nbat',\r\n  Nko: 'nko ',\r\n  Ogham: 'ogam',\r\n  Ol_Chiki: 'olck',\r\n  Old_Turkic: 'orkh',\r\n  Oriya: ['ory2', 'orya'],\r\n  Osmanya: 'osma',\r\n  Palmyrene: 'palm',\r\n  Pau_Cin_Hau: 'pauc',\r\n  Old_Permic: 'perm',\r\n  Phags_Pa: 'phag',\r\n  Inscriptional_Pahlavi: 'phli',\r\n  Psalter_Pahlavi: 'phlp',\r\n  Phoenician: 'phnx',\r\n  Miao: 'plrd',\r\n  Inscriptional_Parthian: 'prti',\r\n  Rejang: 'rjng',\r\n  Runic: 'runr',\r\n  Samaritan: 'samr',\r\n  Old_South_Arabian: 'sarb',\r\n  Saurashtra: 'saur',\r\n  Shavian: 'shaw',\r\n  Sharada: 'shrd',\r\n  Siddham: 'sidd',\r\n  Khudawadi: 'sind',\r\n  Sinhala: 'sinh',\r\n  Sora_Sompeng: 'sora',\r\n  Sundanese: 'sund',\r\n  Syloti_Nagri: 'sylo',\r\n  Syriac: 'syrc',\r\n  Tagbanwa: 'tagb',\r\n  Takri: 'takr',\r\n  Tai_Le: 'tale',\r\n  New_Tai_Lue: 'talu',\r\n  Tamil: ['tml2', 'taml'],\r\n  Tai_Viet: 'tavt',\r\n  Telugu: ['tel2', 'telu'],\r\n  Tifinagh: 'tfng',\r\n  Tagalog: 'tglg',\r\n  Thaana: 'thaa',\r\n  Thai: 'thai',\r\n  Tibetan: 'tibt',\r\n  Tirhuta: 'tirh',\r\n  Ugaritic: 'ugar',\r\n  Vai: 'vai ',\r\n  Warang_Citi: 'wara',\r\n  Old_Persian: 'xpeo',\r\n  Cuneiform: 'xsux',\r\n  Yi: 'yi  ',\r\n  Inherited: 'zinh',\r\n  Common: 'zyyy',\r\n  Unknown: 'zzzz'\r\n};\r\n\r\nconst OPENTYPE_SCRIPTS = {};\r\nfor (let script in UNICODE_SCRIPTS) {\r\n  let tag = UNICODE_SCRIPTS[script];\r\n  if (Array.isArray(tag)) {\r\n    for (let t of tag) {\r\n      OPENTYPE_SCRIPTS[t] = script;\r\n    }\r\n  } else {\r\n    OPENTYPE_SCRIPTS[tag] = script;\r\n  }\r\n}\r\n\r\nexport function fromUnicode(script) {\r\n  return UNICODE_SCRIPTS[script];\r\n}\r\n\r\nexport function fromOpenType(tag) {\r\n  return OPENTYPE_SCRIPTS[tag];\r\n}\r\n\r\nexport function forString(string) {\r\n  let len = string.length;\r\n  let idx = 0;\r\n  while (idx < len) {\r\n    let code = string.charCodeAt(idx++);\r\n\r\n    // Check if this is a high surrogate\r\n    if (0xd800 <= code && code <= 0xdbff && idx < len) {\r\n      let next = string.charCodeAt(idx);\r\n\r\n      // Check if this is a low surrogate\r\n      if (0xdc00 <= next && next <= 0xdfff) {\r\n        idx++;\r\n        code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;\r\n      }\r\n    }\r\n\r\n    let script = unicode.getScript(code);\r\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {\r\n      return UNICODE_SCRIPTS[script];\r\n    }\r\n  }\r\n\r\n  return UNICODE_SCRIPTS.Unknown;\r\n}\r\n\r\nexport function forCodePoints(codePoints) {\r\n  for (let i = 0; i < codePoints.length; i++) {\r\n    let codePoint = codePoints[i];\r\n    let script = unicode.getScript(codePoint);\r\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {\r\n      return UNICODE_SCRIPTS[script];\r\n    }\r\n  }\r\n\r\n  return UNICODE_SCRIPTS.Unknown;\r\n}\r\n\r\n// The scripts in this map are written from right to left\r\nconst RTL = {\r\n  arab: true,   // Arabic\r\n  hebr: true,   // Hebrew\r\n  syrc: true,   // Syriac\r\n  thaa: true,   // Thaana\r\n  cprt: true,   // Cypriot Syllabary\r\n  khar: true,   // Kharosthi\r\n  phnx: true,   // Phoenician\r\n  'nko ': true, // N'Ko\r\n  lydi: true,   // Lydian\r\n  avst: true,   // Avestan\r\n  armi: true,   // Imperial Aramaic\r\n  phli: true,   // Inscriptional Pahlavi\r\n  prti: true,   // Inscriptional Parthian\r\n  sarb: true,   // Old South Arabian\r\n  orkh: true,   // Old Turkic, Orkhon Runic\r\n  samr: true,   // Samaritan\r\n  mand: true,   // Mandaic, Mandaean\r\n  merc: true,   // Meroitic Cursive\r\n  mero: true,   // Meroitic Hieroglyphs\r\n\r\n  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)\r\n  mani: true,   // Manichaean\r\n  mend: true,   // Mende Kikakui\r\n  nbat: true,   // Nabataean\r\n  narb: true,   // Old North Arabian\r\n  palm: true,   // Palmyrene\r\n  phlp: true    // Psalter Pahlavi\r\n};\r\n\r\nexport function direction(script) {\r\n  if (RTL[script]) {\r\n    return 'rtl';\r\n  }\r\n\r\n  return 'ltr';\r\n}\r\n","import BBox from '../glyph/BBox';\r\nimport * as Script from '../layout/Script';\r\n\r\n/**\r\n * Represents a run of Glyph and GlyphPosition objects.\r\n * Returned by the font layout method.\r\n */\r\nexport default class GlyphRun {\r\n  constructor(glyphs, features, script, language, direction) {\r\n    /**\r\n     * An array of Glyph objects in the run\r\n     * @type {Glyph[]}\r\n     */\r\n    this.glyphs = glyphs;\r\n\r\n    /**\r\n     * An array of GlyphPosition objects for each glyph in the run\r\n     * @type {GlyphPosition[]}\r\n     */\r\n    this.positions = null;\r\n\r\n    /**\r\n     * The script that was requested for shaping. This was either passed in or detected automatically.\r\n     * @type {string}\r\n     */\r\n    this.script = script;\r\n\r\n    /**\r\n     * The language requested for shaping, as passed in. If `null`, the default language for the\r\n     * script was used.\r\n     * @type {string}\r\n     */\r\n    this.language = language || null;\r\n\r\n    /**\r\n     * The direction requested for shaping, as passed in (either ltr or rtl).\r\n     * If `null`, the default direction of the script is used.\r\n     * @type {string}\r\n     */\r\n    this.direction = direction || Script.direction(script);\r\n\r\n    /**\r\n     * The features requested during shaping. This is a combination of user\r\n     * specified features and features chosen by the shaper.\r\n     * @type {object}\r\n     */\r\n    this.features = {};\r\n\r\n    // Convert features to an object\r\n    if (Array.isArray(features)) {\r\n      for (let tag of features) {\r\n        this.features[tag] = true;\r\n      }\r\n    } else if (typeof features === 'object') {\r\n      this.features = features;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The total advance width of the run.\r\n   * @type {number}\r\n   */\r\n  get advanceWidth() {\r\n    let width = 0;\r\n    for (let position of this.positions) {\r\n      width += position.xAdvance;\r\n    }\r\n\r\n    return width;\r\n  }\r\n\r\n /**\r\n  * The total advance height of the run.\r\n  * @type {number}\r\n  */\r\n  get advanceHeight() {\r\n    let height = 0;\r\n    for (let position of this.positions) {\r\n      height += position.yAdvance;\r\n    }\r\n\r\n    return height;\r\n  }\r\n\r\n /**\r\n  * The bounding box containing all glyphs in the run.\r\n  * @type {BBox}\r\n  */\r\n  get bbox() {\r\n    let bbox = new BBox;\r\n\r\n    let x = 0;\r\n    let y = 0;\r\n    for (let index = 0; index < this.glyphs.length; index++) {\r\n      let glyph = this.glyphs[index];\r\n      let p = this.positions[index];\r\n      let b = glyph.bbox;\r\n\r\n      bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);\r\n      bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);\r\n\r\n      x += p.xAdvance;\r\n      y += p.yAdvance;\r\n    }\r\n\r\n    return bbox;\r\n  }\r\n}\r\n","/**\r\n * Represents positioning information for a glyph in a GlyphRun.\r\n */\r\nexport default class GlyphPosition {\r\n  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {\r\n    /**\r\n     * The amount to move the virtual pen in the X direction after rendering this glyph.\r\n     * @type {number}\r\n     */\r\n    this.xAdvance = xAdvance;\r\n\r\n    /**\r\n     * The amount to move the virtual pen in the Y direction after rendering this glyph.\r\n     * @type {number}\r\n     */\r\n    this.yAdvance = yAdvance;\r\n\r\n    /**\r\n     * The offset from the pen position in the X direction at which to render this glyph.\r\n     * @type {number}\r\n     */\r\n    this.xOffset = xOffset;\r\n\r\n    /**\r\n     * The offset from the pen position in the Y direction at which to render this glyph.\r\n     * @type {number}\r\n     */\r\n    this.yOffset = yOffset;\r\n  }\r\n}\r\n","// see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html\r\n// and /System/Library/Frameworks/CoreText.framework/Versions/A/Headers/SFNTLayoutTypes.h on a Mac\r\nconst features = {\r\n  allTypographicFeatures: {\r\n    code: 0,\r\n    exclusive: false,\r\n    allTypeFeatures: 0\r\n  },\r\n  ligatures: {\r\n    code: 1,\r\n    exclusive: false,\r\n    requiredLigatures: 0,\r\n    commonLigatures: 2,\r\n    rareLigatures: 4,\r\n    // logos: 6\r\n    rebusPictures: 8,\r\n    diphthongLigatures: 10,\r\n    squaredLigatures: 12,\r\n    abbrevSquaredLigatures: 14,\r\n    symbolLigatures: 16,\r\n    contextualLigatures: 18,\r\n    historicalLigatures: 20\r\n  },\r\n  cursiveConnection: {\r\n    code: 2,\r\n    exclusive: true,\r\n    unconnected: 0,\r\n    partiallyConnected: 1,\r\n    cursive: 2\r\n  },\r\n  letterCase: {\r\n    code: 3,\r\n    exclusive: true\r\n  },\r\n    // upperAndLowerCase: 0          # deprecated\r\n    // allCaps: 1                    # deprecated\r\n    // allLowerCase: 2               # deprecated\r\n    // smallCaps: 3                  # deprecated\r\n    // initialCaps: 4                # deprecated\r\n    // initialCapsAndSmallCaps: 5    # deprecated\r\n  verticalSubstitution: {\r\n    code: 4,\r\n    exclusive: false,\r\n    substituteVerticalForms: 0\r\n  },\r\n  linguisticRearrangement: {\r\n    code: 5,\r\n    exclusive: false,\r\n    linguisticRearrangement: 0\r\n  },\r\n  numberSpacing: {\r\n    code: 6,\r\n    exclusive: true,\r\n    monospacedNumbers: 0,\r\n    proportionalNumbers: 1,\r\n    thirdWidthNumbers: 2,\r\n    quarterWidthNumbers: 3\r\n  },\r\n  smartSwash: {\r\n    code: 8,\r\n    exclusive: false,\r\n    wordInitialSwashes: 0,\r\n    wordFinalSwashes: 2,\r\n    // lineInitialSwashes: 4\r\n    // lineFinalSwashes: 6\r\n    nonFinalSwashes: 8\r\n  },\r\n  diacritics: {\r\n    code: 9,\r\n    exclusive: true,\r\n    showDiacritics: 0,\r\n    hideDiacritics: 1,\r\n    decomposeDiacritics: 2\r\n  },\r\n  verticalPosition: {\r\n    code: 10,\r\n    exclusive: true,\r\n    normalPosition: 0,\r\n    superiors: 1,\r\n    inferiors: 2,\r\n    ordinals: 3,\r\n    scientificInferiors: 4\r\n  },\r\n  fractions: {\r\n    code: 11,\r\n    exclusive: true,\r\n    noFractions: 0,\r\n    verticalFractions: 1,\r\n    diagonalFractions: 2\r\n  },\r\n  overlappingCharacters: {\r\n    code: 13,\r\n    exclusive: false,\r\n    preventOverlap: 0\r\n  },\r\n  typographicExtras: {\r\n    code: 14,\r\n    exclusive: false,\r\n    // hyphensToEmDash: 0\r\n    // hyphenToEnDash: 2\r\n    slashedZero: 4\r\n  },\r\n    // formInterrobang: 6\r\n    // smartQuotes: 8\r\n    // periodsToEllipsis: 10\r\n  mathematicalExtras: {\r\n    code: 15,\r\n    exclusive: false,\r\n    // hyphenToMinus: 0\r\n    // asteristoMultiply: 2\r\n    // slashToDivide: 4\r\n    // inequalityLigatures: 6\r\n    // exponents: 8\r\n    mathematicalGreek: 10\r\n  },\r\n  ornamentSets: {\r\n    code: 16,\r\n    exclusive: true,\r\n    noOrnaments: 0,\r\n    dingbats: 1,\r\n    piCharacters: 2,\r\n    fleurons: 3,\r\n    decorativeBorders: 4,\r\n    internationalSymbols: 5,\r\n    mathSymbols: 6\r\n  },\r\n  characterAlternatives: {\r\n    code: 17,\r\n    exclusive: true,\r\n    noAlternates: 0\r\n  },\r\n    // user defined options\r\n  designComplexity: {\r\n    code: 18,\r\n    exclusive: true,\r\n    designLevel1: 0,\r\n    designLevel2: 1,\r\n    designLevel3: 2,\r\n    designLevel4: 3,\r\n    designLevel5: 4\r\n  },\r\n  styleOptions: {\r\n    code: 19,\r\n    exclusive: true,\r\n    noStyleOptions: 0,\r\n    displayText: 1,\r\n    engravedText: 2,\r\n    illuminatedCaps: 3,\r\n    titlingCaps: 4,\r\n    tallCaps: 5\r\n  },\r\n  characterShape: {\r\n    code: 20,\r\n    exclusive: true,\r\n    traditionalCharacters: 0,\r\n    simplifiedCharacters: 1,\r\n    JIS1978Characters: 2,\r\n    JIS1983Characters: 3,\r\n    JIS1990Characters: 4,\r\n    traditionalAltOne: 5,\r\n    traditionalAltTwo: 6,\r\n    traditionalAltThree: 7,\r\n    traditionalAltFour: 8,\r\n    traditionalAltFive: 9,\r\n    expertCharacters: 10,\r\n    JIS2004Characters: 11,\r\n    hojoCharacters: 12,\r\n    NLCCharacters: 13,\r\n    traditionalNamesCharacters: 14\r\n  },\r\n  numberCase: {\r\n    code: 21,\r\n    exclusive: true,\r\n    lowerCaseNumbers: 0,\r\n    upperCaseNumbers: 1\r\n  },\r\n  textSpacing: {\r\n    code: 22,\r\n    exclusive: true,\r\n    proportionalText: 0,\r\n    monospacedText: 1,\r\n    halfWidthText: 2,\r\n    thirdWidthText: 3,\r\n    quarterWidthText: 4,\r\n    altProportionalText: 5,\r\n    altHalfWidthText: 6\r\n  },\r\n  transliteration: {\r\n    code: 23,\r\n    exclusive: true,\r\n    noTransliteration: 0\r\n  },\r\n    // hanjaToHangul: 1\r\n    // hiraganaToKatakana: 2\r\n    // katakanaToHiragana: 3\r\n    // kanaToRomanization: 4\r\n    // romanizationToHiragana: 5\r\n    // romanizationToKatakana: 6\r\n    // hanjaToHangulAltOne: 7\r\n    // hanjaToHangulAltTwo: 8\r\n    // hanjaToHangulAltThree: 9\r\n  annotation: {\r\n    code: 24,\r\n    exclusive: true,\r\n    noAnnotation: 0,\r\n    boxAnnotation: 1,\r\n    roundedBoxAnnotation: 2,\r\n    circleAnnotation: 3,\r\n    invertedCircleAnnotation: 4,\r\n    parenthesisAnnotation: 5,\r\n    periodAnnotation: 6,\r\n    romanNumeralAnnotation: 7,\r\n    diamondAnnotation: 8,\r\n    invertedBoxAnnotation: 9,\r\n    invertedRoundedBoxAnnotation: 10\r\n  },\r\n  kanaSpacing: {\r\n    code: 25,\r\n    exclusive: true,\r\n    fullWidthKana: 0,\r\n    proportionalKana: 1\r\n  },\r\n  ideographicSpacing: {\r\n    code: 26,\r\n    exclusive: true,\r\n    fullWidthIdeographs: 0,\r\n    proportionalIdeographs: 1,\r\n    halfWidthIdeographs: 2\r\n  },\r\n  unicodeDecomposition: {\r\n    code: 27,\r\n    exclusive: false,\r\n    canonicalComposition: 0,\r\n    compatibilityComposition: 2,\r\n    transcodingComposition: 4\r\n  },\r\n  rubyKana: {\r\n    code: 28,\r\n    exclusive: false,\r\n    // noRubyKana: 0     # deprecated - use rubyKanaOff instead\r\n    // rubyKana: 1     # deprecated - use rubyKanaOn instead\r\n    rubyKana: 2\r\n  },\r\n  CJKSymbolAlternatives: {\r\n    code: 29,\r\n    exclusive: true,\r\n    noCJKSymbolAlternatives: 0,\r\n    CJKSymbolAltOne: 1,\r\n    CJKSymbolAltTwo: 2,\r\n    CJKSymbolAltThree: 3,\r\n    CJKSymbolAltFour: 4,\r\n    CJKSymbolAltFive: 5\r\n  },\r\n  ideographicAlternatives: {\r\n    code: 30,\r\n    exclusive: true,\r\n    noIdeographicAlternatives: 0,\r\n    ideographicAltOne: 1,\r\n    ideographicAltTwo: 2,\r\n    ideographicAltThree: 3,\r\n    ideographicAltFour: 4,\r\n    ideographicAltFive: 5\r\n  },\r\n  CJKVerticalRomanPlacement: {\r\n    code: 31,\r\n    exclusive: true,\r\n    CJKVerticalRomanCentered: 0,\r\n    CJKVerticalRomanHBaseline: 1\r\n  },\r\n  italicCJKRoman: {\r\n    code: 32,\r\n    exclusive: false,\r\n    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead\r\n    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead\r\n    CJKItalicRoman: 2\r\n  },\r\n  caseSensitiveLayout: {\r\n    code: 33,\r\n    exclusive: false,\r\n    caseSensitiveLayout: 0,\r\n    caseSensitiveSpacing: 2\r\n  },\r\n  alternateKana: {\r\n    code: 34,\r\n    exclusive: false,\r\n    alternateHorizKana: 0,\r\n    alternateVertKana: 2\r\n  },\r\n  stylisticAlternatives: {\r\n    code: 35,\r\n    exclusive: false,\r\n    noStylisticAlternates: 0,\r\n    stylisticAltOne: 2,\r\n    stylisticAltTwo: 4,\r\n    stylisticAltThree: 6,\r\n    stylisticAltFour: 8,\r\n    stylisticAltFive: 10,\r\n    stylisticAltSix: 12,\r\n    stylisticAltSeven: 14,\r\n    stylisticAltEight: 16,\r\n    stylisticAltNine: 18,\r\n    stylisticAltTen: 20,\r\n    stylisticAltEleven: 22,\r\n    stylisticAltTwelve: 24,\r\n    stylisticAltThirteen: 26,\r\n    stylisticAltFourteen: 28,\r\n    stylisticAltFifteen: 30,\r\n    stylisticAltSixteen: 32,\r\n    stylisticAltSeventeen: 34,\r\n    stylisticAltEighteen: 36,\r\n    stylisticAltNineteen: 38,\r\n    stylisticAltTwenty: 40\r\n  },\r\n  contextualAlternates: {\r\n    code: 36,\r\n    exclusive: false,\r\n    contextualAlternates: 0,\r\n    swashAlternates: 2,\r\n    contextualSwashAlternates: 4\r\n  },\r\n  lowerCase: {\r\n    code: 37,\r\n    exclusive: true,\r\n    defaultLowerCase: 0,\r\n    lowerCaseSmallCaps: 1,\r\n    lowerCasePetiteCaps: 2\r\n  },\r\n  upperCase: {\r\n    code: 38,\r\n    exclusive: true,\r\n    defaultUpperCase: 0,\r\n    upperCaseSmallCaps: 1,\r\n    upperCasePetiteCaps: 2\r\n  },\r\n  languageTag: { // indices into ltag table\r\n    code: 39,\r\n    exclusive: true\r\n  },\r\n  CJKRomanSpacing: {\r\n    code: 103,\r\n    exclusive: true,\r\n    halfWidthCJKRoman: 0,\r\n    proportionalCJKRoman: 1,\r\n    defaultCJKRoman: 2,\r\n    fullWidthCJKRoman: 3\r\n  }\r\n};\r\n\r\nconst feature = (name, selector) => [features[name].code, features[name][selector]];\r\n\r\nconst OTMapping = {\r\n  rlig: feature('ligatures', 'requiredLigatures'),\r\n  clig: feature('ligatures', 'contextualLigatures'),\r\n  dlig: feature('ligatures', 'rareLigatures'),\r\n  hlig: feature('ligatures', 'historicalLigatures'),\r\n  liga: feature('ligatures', 'commonLigatures'),\r\n  hist: feature('ligatures', 'historicalLigatures'), // ??\r\n\r\n  smcp: feature('lowerCase', 'lowerCaseSmallCaps'),\r\n  pcap: feature('lowerCase', 'lowerCasePetiteCaps'),\r\n\r\n  frac: feature('fractions', 'diagonalFractions'),\r\n  dnom: feature('fractions', 'diagonalFractions'), // ??\r\n  numr: feature('fractions', 'diagonalFractions'), // ??\r\n  afrc: feature('fractions', 'verticalFractions'),\r\n  // aalt\r\n  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?\r\n  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?\r\n  // unic, vatu, vhal, vjmo, vpal, vrt2\r\n  // dist -> trak table?\r\n  // kern, vkrn -> kern table\r\n  // lfbd + opbd + rtbd -> opbd table?\r\n  // mark, mkmk -> acnt table?\r\n  // locl -> languageTag + ltag table\r\n\r\n  case: feature('caseSensitiveLayout', 'caseSensitiveLayout'), // also caseSensitiveSpacing\r\n  ccmp: feature('unicodeDecomposition', 'canonicalComposition'), // compatibilityComposition?\r\n  cpct: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'), // guess..., probably not given below\r\n  valt: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),\r\n  swsh: feature('contextualAlternates', 'swashAlternates'),\r\n  cswh: feature('contextualAlternates', 'contextualSwashAlternates'),\r\n  curs: feature('cursiveConnection', 'cursive'), // ??\r\n  c2pc: feature('upperCase', 'upperCasePetiteCaps'),\r\n  c2sc: feature('upperCase', 'upperCaseSmallCaps'),\r\n\r\n  init: feature('smartSwash', 'wordInitialSwashes'), // ??\r\n  fin2: feature('smartSwash', 'wordFinalSwashes'), // ??\r\n  medi: feature('smartSwash', 'nonFinalSwashes'), // ??\r\n  med2: feature('smartSwash', 'nonFinalSwashes'), // ??\r\n  fin3: feature('smartSwash', 'wordFinalSwashes'), // ??\r\n  fina: feature('smartSwash', 'wordFinalSwashes'), // ??\r\n\r\n  pkna: feature('kanaSpacing', 'proportionalKana'),\r\n  half: feature('textSpacing', 'halfWidthText'), // also HalfWidthCJKRoman, HalfWidthIdeographs?\r\n  halt: feature('textSpacing', 'altHalfWidthText'),\r\n\r\n  hkna: feature('alternateKana', 'alternateHorizKana'),\r\n  vkna: feature('alternateKana', 'alternateVertKana'),\r\n  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated\r\n\r\n  ital: feature('italicCJKRoman', 'CJKItalicRoman'),\r\n  lnum: feature('numberCase', 'upperCaseNumbers'),\r\n  onum: feature('numberCase', 'lowerCaseNumbers'),\r\n  mgrk: feature('mathematicalExtras', 'mathematicalGreek'),\r\n\r\n  // nalt: not enough info. what type of annotation?\r\n  // ornm: ditto, which ornament style?\r\n\r\n  calt: feature('contextualAlternates', 'contextualAlternates'), // or more?\r\n  vrt2: feature('verticalSubstitution', 'substituteVerticalForms'), // oh... below?\r\n  vert: feature('verticalSubstitution', 'substituteVerticalForms'),\r\n  tnum: feature('numberSpacing', 'monospacedNumbers'),\r\n  pnum: feature('numberSpacing', 'proportionalNumbers'),\r\n  sups: feature('verticalPosition', 'superiors'),\r\n  subs: feature('verticalPosition', 'inferiors'),\r\n  ordn: feature('verticalPosition', 'ordinals'),\r\n  pwid: feature('textSpacing', 'proportionalText'),\r\n  hwid: feature('textSpacing', 'halfWidthText'),\r\n  qwid: feature('textSpacing', 'quarterWidthText'), // also QuarterWidthNumbers?\r\n  twid: feature('textSpacing', 'thirdWidthText'), // also ThirdWidthNumbers?\r\n  fwid: feature('textSpacing', 'proportionalText'), //??\r\n  palt: feature('textSpacing', 'altProportionalText'),\r\n  trad: feature('characterShape', 'traditionalCharacters'),\r\n  smpl: feature('characterShape', 'simplifiedCharacters'),\r\n  jp78: feature('characterShape', 'JIS1978Characters'),\r\n  jp83: feature('characterShape', 'JIS1983Characters'),\r\n  jp90: feature('characterShape', 'JIS1990Characters'),\r\n  jp04: feature('characterShape', 'JIS2004Characters'),\r\n  expt: feature('characterShape', 'expertCharacters'),\r\n  hojo: feature('characterShape', 'hojoCharacters'),\r\n  nlck: feature('characterShape', 'NLCCharacters'),\r\n  tnam: feature('characterShape', 'traditionalNamesCharacters'),\r\n  ruby: feature('rubyKana', 'rubyKana'),\r\n  titl: feature('styleOptions', 'titlingCaps'),\r\n  zero: feature('typographicExtras', 'slashedZero'),\r\n\r\n  ss01: feature('stylisticAlternatives', 'stylisticAltOne'),\r\n  ss02: feature('stylisticAlternatives', 'stylisticAltTwo'),\r\n  ss03: feature('stylisticAlternatives', 'stylisticAltThree'),\r\n  ss04: feature('stylisticAlternatives', 'stylisticAltFour'),\r\n  ss05: feature('stylisticAlternatives', 'stylisticAltFive'),\r\n  ss06: feature('stylisticAlternatives', 'stylisticAltSix'),\r\n  ss07: feature('stylisticAlternatives', 'stylisticAltSeven'),\r\n  ss08: feature('stylisticAlternatives', 'stylisticAltEight'),\r\n  ss09: feature('stylisticAlternatives', 'stylisticAltNine'),\r\n  ss10: feature('stylisticAlternatives', 'stylisticAltTen'),\r\n  ss11: feature('stylisticAlternatives', 'stylisticAltEleven'),\r\n  ss12: feature('stylisticAlternatives', 'stylisticAltTwelve'),\r\n  ss13: feature('stylisticAlternatives', 'stylisticAltThirteen'),\r\n  ss14: feature('stylisticAlternatives', 'stylisticAltFourteen'),\r\n  ss15: feature('stylisticAlternatives', 'stylisticAltFifteen'),\r\n  ss16: feature('stylisticAlternatives', 'stylisticAltSixteen'),\r\n  ss17: feature('stylisticAlternatives', 'stylisticAltSeventeen'),\r\n  ss18: feature('stylisticAlternatives', 'stylisticAltEighteen'),\r\n  ss19: feature('stylisticAlternatives', 'stylisticAltNineteen'),\r\n  ss20: feature('stylisticAlternatives', 'stylisticAltTwenty')\r\n};\r\n\r\n  // salt: feature 'stylisticAlternatives', 'stylisticAltOne' # hmm, which one to choose\r\n\r\n// Add cv01-cv99 features\r\nfor (let i = 1; i <= 99; i++) {\r\n  OTMapping[`cv${`00${i}`.slice(-2)}`] = [features.characterAlternatives.code, i];\r\n}\r\n\r\n// create inverse mapping\r\nlet AATMapping = {};\r\nfor (let ot in OTMapping) {\r\n  let aat = OTMapping[ot];\r\n  if (AATMapping[aat[0]] == null) {\r\n    AATMapping[aat[0]] = {};\r\n  }\r\n\r\n  AATMapping[aat[0]][aat[1]] = ot;\r\n}\r\n\r\n// Maps an array of OpenType features to AAT features\r\n// in the form of {featureType:{featureSetting:true}}\r\nexport function mapOTToAAT(features) {\r\n  let res = {};\r\n  for (let k in features) {\r\n    let r;\r\n    if (r = OTMapping[k]) {\r\n      if (res[r[0]] == null) {\r\n        res[r[0]] = {};\r\n      }\r\n\r\n      res[r[0]][r[1]] = features[k];\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// Maps strings in a [featureType, featureSetting]\r\n// to their equivalent number codes\r\nfunction mapFeatureStrings(f) {\r\n  let [type, setting] = f;\r\n  if (isNaN(type)) {\r\n    var typeCode = features[type] && features[type].code;\r\n  } else {\r\n    var typeCode = type;\r\n  }\r\n\r\n  if (isNaN(setting)) {\r\n    var settingCode = features[type] && features[type][setting];\r\n  } else {\r\n    var settingCode = setting;\r\n  }\r\n\r\n  return [typeCode, settingCode];\r\n}\r\n\r\n// Maps AAT features to an array of OpenType features\r\n// Supports both arrays in the form of [[featureType, featureSetting]]\r\n// and objects in the form of {featureType:{featureSetting:true}}\r\n// featureTypes and featureSettings can be either strings or number codes\r\nexport function mapAATToOT(features) {\r\n  let res = {};\r\n  if (Array.isArray(features)) {\r\n    for (let k = 0; k < features.length; k++) {\r\n      let r;\r\n      let f = mapFeatureStrings(features[k]);\r\n      if (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]]) {\r\n        res[r] = true;\r\n      }\r\n    }\r\n\r\n  } else if (typeof features === 'object') {\r\n    for (let type in features) {\r\n      let feature = features[type];\r\n      for (let setting in feature) {\r\n        let r;\r\n        let f = mapFeatureStrings([type, setting]);\r\n        if (feature[setting] && (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]])) {\r\n          res[r] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return Object.keys(res);\r\n}\r\n","import {cache} from '../decorators';\r\nimport {range} from '../utils';\r\n\r\nexport default class AATLookupTable {\r\n  constructor(table) {\r\n    this.table = table;\r\n  }\r\n\r\n  lookup(glyph) {\r\n    switch (this.table.version) {\r\n      case 0: // simple array format\r\n        return this.table.values.getItem(glyph);\r\n\r\n      case 2: // segment format\r\n      case 4: {\r\n        let min = 0;\r\n        let max = this.table.binarySearchHeader.nUnits - 1;\r\n\r\n        while (min <= max) {\r\n          var mid = (min + max) >> 1;\r\n          var seg = this.table.segments[mid];\r\n\r\n          // special end of search value\r\n          if (seg.firstGlyph === 0xffff) {\r\n            return null;\r\n          }\r\n\r\n          if (glyph < seg.firstGlyph) {\r\n            max = mid - 1;\r\n          } else if (glyph > seg.lastGlyph) {\r\n            min = mid + 1;\r\n          } else {\r\n            if (this.table.version === 2) {\r\n              return seg.value;\r\n            } else {\r\n              return seg.values[glyph - seg.firstGlyph];\r\n            }\r\n          }\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      case 6: { // lookup single\r\n        let min = 0;\r\n        let max = this.table.binarySearchHeader.nUnits - 1;\r\n\r\n        while (min <= max) {\r\n          var mid = (min + max) >> 1;\r\n          var seg = this.table.segments[mid];\r\n\r\n          // special end of search value\r\n          if (seg.glyph === 0xffff) {\r\n            return null;\r\n          }\r\n\r\n          if (glyph < seg.glyph) {\r\n            max = mid - 1;\r\n          } else if (glyph > seg.glyph) {\r\n            min = mid + 1;\r\n          } else {\r\n            return seg.value;\r\n          }\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      case 8: // lookup trimmed\r\n        return this.table.values[glyph - this.table.firstGlyph];\r\n\r\n      default:\r\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\r\n    }\r\n  }\r\n\r\n  @cache\r\n  glyphsForValue(classValue) {\r\n    let res = [];\r\n\r\n    switch (this.table.version) {\r\n      case 2: // segment format\r\n      case 4: {\r\n        for (let segment of this.table.segments) {\r\n          if ((this.table.version === 2 && segment.value === classValue)) {\r\n            res.push(...range(segment.firstGlyph, segment.lastGlyph + 1));\r\n          } else {\r\n            for (let index = 0; index < segment.values.length; index++) {\r\n              if (segment.values[index] === classValue) {\r\n                res.push(segment.firstGlyph + index);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      case 6: { // lookup single\r\n        for (let segment of this.table.segments) {\r\n          if (segment.value === classValue) {\r\n            res.push(segment.glyph);\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      case 8: { // lookup trimmed\r\n        for (let i = 0; i < this.table.values.length; i++) {\r\n          if (this.table.values[i] === classValue) {\r\n            res.push(this.table.firstGlyph + i);\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      default:\r\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\r\n    }\r\n\r\n    return res;\r\n  }\r\n}\r\n","import AATLookupTable from './AATLookupTable';\r\n\r\nconst START_OF_TEXT_STATE = 0;\r\nconst START_OF_LINE_STATE = 1;\r\n\r\nconst END_OF_TEXT_CLASS = 0;\r\nconst OUT_OF_BOUNDS_CLASS = 1;\r\nconst DELETED_GLYPH_CLASS = 2;\r\nconst END_OF_LINE_CLASS = 3;\r\n\r\nconst DONT_ADVANCE = 0x4000;\r\n\r\nexport default class AATStateMachine {\r\n  constructor(stateTable) {\r\n    this.stateTable = stateTable;\r\n    this.lookupTable = new AATLookupTable(stateTable.classTable);\r\n  }\r\n\r\n  process(glyphs, reverse, processEntry) {\r\n    let currentState = START_OF_TEXT_STATE; // START_OF_LINE_STATE is used for kashida glyph insertions sometimes I think?\r\n    let index = reverse ? glyphs.length - 1 : 0;\r\n    let dir = reverse ? -1 : 1;\r\n\r\n    while ((dir === 1 && index <= glyphs.length) || (dir === -1 && index >= -1)) {\r\n      let glyph = null;\r\n      let classCode = OUT_OF_BOUNDS_CLASS;\r\n      let shouldAdvance = true;\r\n\r\n      if (index === glyphs.length || index === -1) {\r\n        classCode = END_OF_TEXT_CLASS;\r\n      } else {\r\n        glyph = glyphs[index];\r\n        if (glyph.id === 0xffff) { // deleted glyph\r\n          classCode = DELETED_GLYPH_CLASS;\r\n        } else {\r\n          classCode = this.lookupTable.lookup(glyph.id);\r\n          if (classCode == null) {\r\n            classCode = OUT_OF_BOUNDS_CLASS;\r\n          }\r\n        }\r\n      }\r\n\r\n      let row = this.stateTable.stateArray.getItem(currentState);\r\n      let entryIndex = row[classCode];\r\n      let entry = this.stateTable.entryTable.getItem(entryIndex);\r\n\r\n      if (classCode !== END_OF_TEXT_CLASS && classCode !==  DELETED_GLYPH_CLASS) {\r\n        processEntry(glyph, entry, index);\r\n        shouldAdvance = !(entry.flags & DONT_ADVANCE);\r\n      }\r\n\r\n      currentState = entry.newState;\r\n      if (shouldAdvance) {\r\n        index += dir;\r\n      }\r\n    }\r\n\r\n    return glyphs;\r\n  }\r\n\r\n  /**\r\n   * Performs a depth-first traversal of the glyph strings\r\n   * represented by the state machine.\r\n   */\r\n  traverse(opts, state = 0, visited = new Set) {\r\n    if (visited.has(state)) {\r\n      return;\r\n    }\r\n\r\n    visited.add(state);\r\n\r\n    let {nClasses, stateArray, entryTable} = this.stateTable;\r\n    let row = stateArray.getItem(state);\r\n\r\n    // Skip predefined classes\r\n    for (let classCode = 4; classCode < nClasses; classCode++) {\r\n      let entryIndex = row[classCode];\r\n      let entry = entryTable.getItem(entryIndex);\r\n\r\n      // Try all glyphs in the class\r\n      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {\r\n        if (opts.enter) {\r\n          opts.enter(glyph, entry);\r\n        }\r\n\r\n        if (entry.newState !== 0) {\r\n          this.traverse(opts, entry.newState, visited);\r\n        }\r\n\r\n        if (opts.exit) {\r\n          opts.exit(glyph, entry);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import AATStateMachine from './AATStateMachine';\r\nimport AATLookupTable from './AATLookupTable';\r\nimport {cache} from '../decorators';\r\n\r\n// indic replacement flags\r\nconst MARK_FIRST = 0x8000;\r\nconst MARK_LAST  = 0x2000;\r\nconst VERB       = 0x000F;\r\n\r\n// contextual substitution and glyph insertion flag\r\nconst SET_MARK = 0x8000;\r\n\r\n// ligature entry flags\r\nconst SET_COMPONENT  = 0x8000;\r\nconst PERFORM_ACTION = 0x2000;\r\n\r\n// ligature action masks\r\nconst LAST_MASK   = 0x80000000;\r\nconst STORE_MASK  = 0x40000000;\r\nconst OFFSET_MASK = 0x3FFFFFFF;\r\n\r\nconst VERTICAL_ONLY           = 0x800000;\r\nconst REVERSE_DIRECTION       = 0x400000;\r\nconst HORIZONTAL_AND_VERTICAL = 0x200000;\r\n\r\n// glyph insertion flags\r\nconst CURRENT_IS_KASHIDA_LIKE = 0x2000;\r\nconst MARKED_IS_KASHIDA_LIKE  = 0x1000;\r\nconst CURRENT_INSERT_BEFORE   = 0x0800;\r\nconst MARKED_INSERT_BEFORE    = 0x0400;\r\nconst CURRENT_INSERT_COUNT    = 0x03E0;\r\nconst MARKED_INSERT_COUNT     = 0x001F;\r\n\r\nexport default class AATMorxProcessor {\r\n  constructor(font) {\r\n    this.processIndicRearragement = this.processIndicRearragement.bind(this);\r\n    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);\r\n    this.processLigature = this.processLigature.bind(this);\r\n    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);\r\n    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);\r\n    this.font = font;\r\n    this.morx = font.morx;\r\n    this.inputCache = null;\r\n  }\r\n\r\n  // Processes an array of glyphs and applies the specified features\r\n  // Features should be in the form of {featureType:{featureSetting:boolean}}\r\n  process(glyphs, features = {}) {\r\n    for (let chain of this.morx.chains) {\r\n      let flags = chain.defaultFlags;\r\n\r\n      // enable/disable the requested features\r\n      for (let feature of chain.features) {\r\n        let f;\r\n        if (f = features[feature.featureType]) {\r\n          if (f[feature.featureSetting]) {\r\n            flags &= feature.disableFlags;\r\n            flags |= feature.enableFlags;\r\n          } else if (f[feature.featureSetting] === false) {\r\n            flags |= ~feature.disableFlags;\r\n            flags &= ~feature.enableFlags;\r\n          }\r\n        }\r\n      }\r\n\r\n      for (let subtable of chain.subtables) {\r\n        if (subtable.subFeatureFlags & flags) {\r\n          this.processSubtable(subtable, glyphs);\r\n        }\r\n      }\r\n    }\r\n\r\n    // remove deleted glyphs\r\n    let index = glyphs.length - 1;\r\n    while (index >= 0) {\r\n      if (glyphs[index].id === 0xffff) {\r\n        glyphs.splice(index, 1);\r\n      }\r\n\r\n      index--;\r\n    }\r\n\r\n    return glyphs;\r\n  }\r\n\r\n  processSubtable(subtable, glyphs) {\r\n    this.subtable = subtable;\r\n    this.glyphs = glyphs;\r\n    if (this.subtable.type === 4) {\r\n      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);\r\n      return;\r\n    }\r\n\r\n    this.ligatureStack = [];\r\n    this.markedGlyph = null;\r\n    this.firstGlyph = null;\r\n    this.lastGlyph = null;\r\n    this.markedIndex = null;\r\n\r\n    let stateMachine = this.getStateMachine(subtable);\r\n    let process = this.getProcessor();\r\n\r\n    let reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);\r\n    return stateMachine.process(this.glyphs, reverse, process);\r\n  }\r\n\r\n  @cache\r\n  getStateMachine(subtable) {\r\n    return new AATStateMachine(subtable.table.stateTable);\r\n  }\r\n\r\n  getProcessor() {\r\n    switch (this.subtable.type) {\r\n      case 0:\r\n        return this.processIndicRearragement;\r\n      case 1:\r\n        return this.processContextualSubstitution;\r\n      case 2:\r\n        return this.processLigature;\r\n      case 4:\r\n        return this.processNoncontextualSubstitutions;\r\n      case 5:\r\n        return this.processGlyphInsertion;\r\n      default:\r\n        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);\r\n    }\r\n  }\r\n\r\n  processIndicRearragement(glyph, entry, index) {\r\n    if (entry.flags & MARK_FIRST) {\r\n      this.firstGlyph = index;\r\n    }\r\n\r\n    if (entry.flags & MARK_LAST) {\r\n      this.lastGlyph = index;\r\n    }\r\n\r\n    reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);\r\n  }\r\n\r\n  processContextualSubstitution(glyph, entry, index) {\r\n    let subsitutions = this.subtable.table.substitutionTable.items;\r\n    if (entry.markIndex !== 0xffff) {\r\n      let lookup = subsitutions.getItem(entry.markIndex);\r\n      let lookupTable = new AATLookupTable(lookup);\r\n      glyph = this.glyphs[this.markedGlyph];\r\n      var gid = lookupTable.lookup(glyph.id);\r\n      if (gid) {\r\n        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);\r\n      }\r\n    }\r\n\r\n    if (entry.currentIndex !== 0xffff) {\r\n      let lookup = subsitutions.getItem(entry.currentIndex);\r\n      let lookupTable = new AATLookupTable(lookup);\r\n      glyph = this.glyphs[index];\r\n      var gid = lookupTable.lookup(glyph.id);\r\n      if (gid) {\r\n        this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\r\n      }\r\n    }\r\n\r\n    if (entry.flags & SET_MARK) {\r\n      this.markedGlyph = index;\r\n    }\r\n  }\r\n\r\n  processLigature(glyph, entry, index) {\r\n    if (entry.flags & SET_COMPONENT) {\r\n      this.ligatureStack.push(index);\r\n    }\r\n\r\n    if (entry.flags & PERFORM_ACTION) {\r\n      let actions = this.subtable.table.ligatureActions;\r\n      let components = this.subtable.table.components;\r\n      let ligatureList = this.subtable.table.ligatureList;\r\n\r\n      let actionIndex = entry.action;\r\n      let last = false;\r\n      let ligatureIndex = 0;\r\n      let codePoints = [];\r\n      let ligatureGlyphs = [];\r\n\r\n      while (!last) {\r\n        let componentGlyph = this.ligatureStack.pop();\r\n        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);\r\n\r\n        let action = actions.getItem(actionIndex++);\r\n        last = !!(action & LAST_MASK);\r\n        let store = !!(action & STORE_MASK);\r\n        let offset = (action & OFFSET_MASK) << 2 >> 2; // sign extend 30 to 32 bits\r\n        offset += this.glyphs[componentGlyph].id;\r\n\r\n        let component = components.getItem(offset);\r\n        ligatureIndex += component;\r\n\r\n        if (last || store) {\r\n          let ligatureEntry = ligatureList.getItem(ligatureIndex);\r\n          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);\r\n          ligatureGlyphs.push(componentGlyph);\r\n          ligatureIndex = 0;\r\n          codePoints = [];\r\n        } else {\r\n          this.glyphs[componentGlyph] = this.font.getGlyph(0xffff);\r\n        }\r\n      }\r\n\r\n      // Put ligature glyph indexes back on the stack\r\n      this.ligatureStack.push(...ligatureGlyphs);\r\n    }\r\n  }\r\n\r\n  processNoncontextualSubstitutions(subtable, glyphs, index) {\r\n    let lookupTable = new AATLookupTable(subtable.table.lookupTable);\r\n\r\n    for (index = 0; index < glyphs.length; index++) {\r\n      let glyph = glyphs[index];\r\n      if (glyph.id !== 0xffff) {\r\n        let gid = lookupTable.lookup(glyph.id);\r\n        if (gid) { // 0 means do nothing\r\n          glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {\r\n    let insertions = [];\r\n    while (count--) {\r\n      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);\r\n      insertions.push(this.font.getGlyph(gid));\r\n    }\r\n\r\n    if (!isBefore) {\r\n      glyphIndex++;\r\n    }\r\n\r\n    this.glyphs.splice(glyphIndex, 0, ...insertions);\r\n  }\r\n\r\n  processGlyphInsertion(glyph, entry, index) {\r\n    if (entry.flags & SET_MARK) {\r\n      this.markedIndex = index;\r\n    }\r\n\r\n    if (entry.markedInsertIndex !== 0xffff) {\r\n      let count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;\r\n      let isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);\r\n      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);\r\n    }\r\n\r\n    if (entry.currentInsertIndex !== 0xffff) {\r\n      let count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;\r\n      let isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);\r\n      this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore);\r\n    }\r\n  }\r\n\r\n  getSupportedFeatures() {\r\n    let features = [];\r\n    for (let chain of this.morx.chains) {\r\n      for (let feature of chain.features) {\r\n        features.push([feature.featureType, feature.featureSetting]);\r\n      }\r\n    }\r\n\r\n    return features;\r\n  }\r\n\r\n  generateInputs(gid) {\r\n    if (!this.inputCache) {\r\n      this.generateInputCache();\r\n    }\r\n\r\n    return this.inputCache[gid] || [];\r\n  }\r\n\r\n  generateInputCache() {\r\n    this.inputCache = {};\r\n\r\n    for (let chain of this.morx.chains) {\r\n      let flags = chain.defaultFlags;\r\n\r\n      for (let subtable of chain.subtables) {\r\n        if (subtable.subFeatureFlags & flags) {\r\n          this.generateInputsForSubtable(subtable);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  generateInputsForSubtable(subtable) {\r\n    // Currently, only supporting ligature subtables.\r\n    if (subtable.type !== 2) {\r\n      return;\r\n    }\r\n\r\n    let reverse = !!(subtable.coverage & REVERSE_DIRECTION);\r\n    if (reverse) {\r\n      throw new Error('Reverse subtable, not supported.');\r\n    }\r\n\r\n    this.subtable = subtable;\r\n    this.ligatureStack = [];\r\n\r\n    let stateMachine = this.getStateMachine(subtable);\r\n    let process = this.getProcessor();\r\n\r\n    let input = [];\r\n    let stack = [];\r\n    this.glyphs = [];\r\n\r\n    stateMachine.traverse({\r\n      enter: (glyph, entry) => {\r\n        let glyphs = this.glyphs;\r\n        stack.push({\r\n          glyphs: glyphs.slice(),\r\n          ligatureStack: this.ligatureStack.slice()\r\n        });\r\n\r\n        // Add glyph to input and glyphs to process.\r\n        let g = this.font.getGlyph(glyph);\r\n        input.push(g);\r\n        glyphs.push(input[input.length - 1]);\r\n\r\n        // Process ligature substitution\r\n        process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);\r\n\r\n        // Add input to result if only one matching (non-deleted) glyph remains.\r\n        let count = 0;\r\n        let found = 0;\r\n        for (let i = 0; i < glyphs.length && count <= 1; i++) {\r\n          if (glyphs[i].id !== 0xffff) {\r\n            count++;\r\n            found = glyphs[i].id;\r\n          }\r\n        }\r\n\r\n        if (count === 1) {\r\n          let result = input.map(g => g.id);\r\n          let cache = this.inputCache[found];\r\n          if (cache) {\r\n            cache.push(result);\r\n          } else {\r\n            this.inputCache[found] = [result];\r\n          }\r\n        }\r\n      },\r\n\r\n      exit: () => {\r\n        ({glyphs: this.glyphs, ligatureStack: this.ligatureStack} = stack.pop());\r\n        input.pop();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// swaps the glyphs in rangeA with those in rangeB\r\n// reverse the glyphs inside those ranges if specified\r\n// ranges are in [offset, length] format\r\nfunction swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {\r\n  let end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);\r\n  if (reverseB) {\r\n    end.reverse();\r\n  }\r\n\r\n  let start = glyphs.splice(rangeA[0], rangeA[1], ...end);\r\n  if (reverseA) {\r\n    start.reverse();\r\n  }\r\n\r\n  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start);\r\n  return glyphs;\r\n}\r\n\r\nfunction reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {\r\n  let length = lastGlyph - firstGlyph + 1;\r\n  switch (verb) {\r\n    case 0: // no change\r\n      return glyphs;\r\n\r\n    case 1: // Ax => xA\r\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);\r\n\r\n    case 2: // xD => Dx\r\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);\r\n\r\n    case 3: // AxD => DxA\r\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);\r\n\r\n    case 4: // ABx => xAB\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);\r\n\r\n    case 5: // ABx => xBA\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);\r\n\r\n    case 6: // xCD => CDx\r\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);\r\n\r\n    case 7: // xCD => DCx\r\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);\r\n\r\n    case 8: // AxCD => CDxA\r\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);\r\n\r\n    case 9: // AxCD => DCxA\r\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);\r\n\r\n    case 10: // ABxD => DxAB\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);\r\n\r\n    case 11: // ABxD => DxBA\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);\r\n\r\n    case 12: // ABxCD => CDxAB\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);\r\n\r\n    case 13: // ABxCD => CDxBA\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);\r\n\r\n    case 14: // ABxCD => DCxAB\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);\r\n\r\n    case 15: // ABxCD => DCxBA\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);\r\n\r\n    default:\r\n      throw new Error(`Unknown verb: ${verb}`);\r\n  }\r\n}\r\n","import * as AATFeatureMap from './AATFeatureMap';\r\nimport * as Script from '../layout/Script';\r\nimport AATMorxProcessor from './AATMorxProcessor';\r\n\r\nexport default class AATLayoutEngine {\r\n  constructor(font) {\r\n    this.font = font;\r\n    this.morxProcessor = new AATMorxProcessor(font);\r\n    this.fallbackPosition = false;\r\n  }\r\n\r\n  substitute(glyphRun) {\r\n    // AAT expects the glyphs to be in visual order prior to morx processing,\r\n    // so reverse the glyphs if the script is right-to-left.\r\n    if (glyphRun.direction === 'rtl') {\r\n      glyphRun.glyphs.reverse();\r\n    }\r\n\r\n    this.morxProcessor.process(glyphRun.glyphs, AATFeatureMap.mapOTToAAT(glyphRun.features));\r\n  }\r\n\r\n  getAvailableFeatures(script, language) {\r\n    return AATFeatureMap.mapAATToOT(this.morxProcessor.getSupportedFeatures());\r\n  }\r\n\r\n  stringsForGlyph(gid) {\r\n    let glyphStrings = this.morxProcessor.generateInputs(gid);\r\n    let result = new Set;\r\n\r\n    for (let glyphs of glyphStrings) {\r\n      this._addStrings(glyphs, 0, result, '');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  _addStrings(glyphs, index, strings, string) {\r\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);\r\n\r\n    for (let codePoint of codePoints) {\r\n      let s = string + String.fromCodePoint(codePoint);\r\n      if (index < glyphs.length - 1) {\r\n        this._addStrings(glyphs, index + 1, strings, s);\r\n      } else {\r\n        strings.add(s);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import * as Script from '../layout/Script';\r\n\r\n/**\r\n * ShapingPlans are used by the OpenType shapers to store which\r\n * features should by applied, and in what order to apply them.\r\n * The features are applied in groups called stages. A feature\r\n * can be applied globally to all glyphs, or locally to only\r\n * specific glyphs.\r\n *\r\n * @private\r\n */\r\nexport default class ShapingPlan {\r\n  constructor(font, script, direction) {\r\n    this.font = font;\r\n    this.script = script;\r\n    this.direction = direction;\r\n    this.stages = [];\r\n    this.globalFeatures = {};\r\n    this.allFeatures = {};\r\n  }\r\n\r\n  /**\r\n   * Adds the given features to the last stage.\r\n   * Ignores features that have already been applied.\r\n   */\r\n  _addFeatures(features, global) {\r\n    let stageIndex = this.stages.length - 1;\r\n    let stage = this.stages[stageIndex];\r\n    for (let feature of features) {\r\n      if (this.allFeatures[feature] == null) {\r\n        stage.push(feature);\r\n        this.allFeatures[feature] = stageIndex;\r\n\r\n        if (global) {\r\n          this.globalFeatures[feature] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add features to the last stage\r\n   */\r\n  add(arg, global = true) {\r\n    if (this.stages.length === 0) {\r\n      this.stages.push([]);\r\n    }\r\n\r\n    if (typeof arg === 'string') {\r\n      arg = [arg];\r\n    }\r\n\r\n    if (Array.isArray(arg)) {\r\n      this._addFeatures(arg, global);\r\n    } else if (typeof arg === 'object') {\r\n      this._addFeatures(arg.global || [], true);\r\n      this._addFeatures(arg.local || [], false);\r\n    } else {\r\n      throw new Error(\"Unsupported argument to ShapingPlan#add\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a new stage\r\n   */\r\n  addStage(arg, global) {\r\n    if (typeof arg === 'function') {\r\n      this.stages.push(arg, []);\r\n    } else {\r\n      this.stages.push([]);\r\n      this.add(arg, global);\r\n    }\r\n  }\r\n\r\n  setFeatureOverrides(features) {\r\n    if (Array.isArray(features)) {\r\n      this.add(features);\r\n    } else if (typeof features === 'object') {\r\n      for (let tag in features) {\r\n        if (features[tag]) {\r\n          this.add(tag);\r\n        } else if (this.allFeatures[tag] != null) {\r\n          let stage = this.stages[this.allFeatures[tag]];\r\n          stage.splice(stage.indexOf(tag), 1);\r\n          delete this.allFeatures[tag];\r\n          delete this.globalFeatures[tag];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assigns the global features to the given glyphs\r\n   */\r\n  assignGlobalFeatures(glyphs) {\r\n    for (let glyph of glyphs) {\r\n      for (let feature in this.globalFeatures) {\r\n        glyph.features[feature] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes the planned stages using the given OTProcessor\r\n   */\r\n  process(processor, glyphs, positions) {\r\n    for (let stage of this.stages) {\r\n      if (typeof stage === 'function') {\r\n        if (!positions) {\r\n          stage(this.font, glyphs, this);\r\n        }\r\n\r\n      } else if (stage.length > 0) {\r\n        processor.applyFeatures(stage, glyphs, positions);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import unicode from 'unicode-properties';\r\n\r\nconst VARIATION_FEATURES = ['rvrn'];\r\nconst COMMON_FEATURES = ['ccmp', 'locl', 'rlig', 'mark', 'mkmk'];\r\nconst FRACTIONAL_FEATURES = ['frac', 'numr', 'dnom'];\r\nconst HORIZONTAL_FEATURES = ['calt', 'clig', 'liga', 'rclt', 'curs', 'kern'];\r\nconst VERTICAL_FEATURES = ['vert'];\r\nconst DIRECTIONAL_FEATURES = {\r\n  ltr: ['ltra', 'ltrm'],\r\n  rtl: ['rtla', 'rtlm']\r\n};\r\n\r\nexport default class DefaultShaper {\r\n  static zeroMarkWidths = 'AFTER_GPOS';\r\n  static plan(plan, glyphs, features) {\r\n    // Plan the features we want to apply\r\n    this.planPreprocessing(plan);\r\n    this.planFeatures(plan);\r\n    this.planPostprocessing(plan, features);\r\n\r\n    // Assign the global features to all the glyphs\r\n    plan.assignGlobalFeatures(glyphs);\r\n\r\n    // Assign local features to glyphs\r\n    this.assignFeatures(plan, glyphs);\r\n  }\r\n\r\n  static planPreprocessing(plan) {\r\n    plan.add({\r\n      global: [...VARIATION_FEATURES, ...DIRECTIONAL_FEATURES[plan.direction]],\r\n      local: FRACTIONAL_FEATURES\r\n    });\r\n  }\r\n\r\n  static planFeatures(plan) {\r\n    // Do nothing by default. Let subclasses override this.\r\n  }\r\n\r\n  static planPostprocessing(plan, userFeatures) {\r\n    plan.add([...COMMON_FEATURES, ...HORIZONTAL_FEATURES]);\r\n    plan.setFeatureOverrides(userFeatures);\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    // Enable contextual fractions\r\n    for (let i = 0; i < glyphs.length; i++) {\r\n      let glyph = glyphs[i];\r\n      if (glyph.codePoints[0] === 0x2044) { // fraction slash\r\n        let start = i;\r\n        let end = i + 1;\r\n\r\n        // Apply numerator\r\n        while (start > 0 && unicode.isDigit(glyphs[start - 1].codePoints[0])) {\r\n          glyphs[start - 1].features.numr = true;\r\n          glyphs[start - 1].features.frac = true;\r\n          start--;\r\n        }\r\n\r\n        // Apply denominator\r\n        while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {\r\n          glyphs[end].features.dnom = true;\r\n          glyphs[end].features.frac = true;\r\n          end++;\r\n        }\r\n\r\n        // Apply fraction slash\r\n        glyph.features.frac = true;\r\n        i = end - 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n","import DefaultShaper from './DefaultShaper';\r\nimport unicode from 'unicode-properties';\r\nimport UnicodeTrie from 'unicode-trie';\r\n\r\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/data.trie'));\r\nconst FEATURES = ['isol', 'fina', 'fin2', 'fin3', 'medi', 'med2', 'init'];\r\n\r\nconst ShapingClasses = {\r\n  Non_Joining: 0,\r\n  Left_Joining: 1,\r\n  Right_Joining: 2,\r\n  Dual_Joining: 3,\r\n  Join_Causing: 3,\r\n  ALAPH: 4,\r\n  'DALATH RISH': 5,\r\n  Transparent: 6\r\n};\r\n\r\nconst ISOL = 'isol';\r\nconst FINA = 'fina';\r\nconst FIN2 = 'fin2';\r\nconst FIN3 = 'fin3';\r\nconst MEDI = 'medi';\r\nconst MED2 = 'med2';\r\nconst INIT = 'init';\r\nconst NONE = null;\r\n\r\n// Each entry is [prevAction, curAction, nextState]\r\nconst STATE_TABLE = [\r\n  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH\r\n  // State 0: prev was U,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 6 ] ],\r\n\r\n  // State 1: prev was R or ISOL/ALAPH,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, FIN2, 5 ],  [ NONE, ISOL, 6 ] ],\r\n\r\n  // State 2: prev was D/L in ISOL form,  willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ INIT, FINA, 1 ],  [ INIT, FINA, 3 ],  [ INIT, FINA, 4 ],  [ INIT, FINA, 6 ] ],\r\n\r\n  // State 3: prev was D in FINA form,  willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ MEDI, FINA, 1 ],  [ MEDI, FINA, 3 ],  [ MEDI, FINA, 4 ],  [ MEDI, FINA, 6 ] ],\r\n\r\n  // State 4: prev was FINA ALAPH,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ MED2, ISOL, 1 ],  [ MED2, ISOL, 2 ],  [ MED2, FIN2, 5 ],  [ MED2, ISOL, 6 ] ],\r\n\r\n  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ ISOL, ISOL, 1 ],  [ ISOL, ISOL, 2 ],  [ ISOL, FIN2, 5 ],  [ ISOL, ISOL, 6 ] ],\r\n\r\n  // State 6: prev was DALATH/RISH,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, FIN3, 5 ],  [ NONE, ISOL, 6 ] ]\r\n];\r\n\r\n/**\r\n * This is a shaper for Arabic, and other cursive scripts.\r\n * It uses data from ArabicShaping.txt in the Unicode database,\r\n * compiled to a UnicodeTrie by generate-data.coffee.\r\n *\r\n * The shaping state machine was ported from Harfbuzz.\r\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-arabic.cc\r\n */\r\nexport default class ArabicShaper extends DefaultShaper {\r\n  static planFeatures(plan) {\r\n    plan.add(['ccmp', 'locl']);\r\n    for (let i = 0; i < FEATURES.length; i++) {\r\n      let feature = FEATURES[i];\r\n      plan.addStage(feature, false);\r\n    }\r\n\r\n    plan.addStage('mset');\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    super.assignFeatures(plan, glyphs);\r\n\r\n    let prev = -1;\r\n    let state = 0;\r\n    let actions = [];\r\n\r\n    // Apply the state machine to map glyphs to features\r\n    for (let i = 0; i < glyphs.length; i++) {\r\n      let curAction, prevAction;\r\n      var glyph = glyphs[i];\r\n      let type = getShapingClass(glyph.codePoints[0]);\r\n      if (type === ShapingClasses.Transparent) {\r\n        actions[i] = NONE;\r\n        continue;\r\n      }\r\n\r\n      [prevAction, curAction, state] = STATE_TABLE[state][type];\r\n\r\n      if (prevAction !== NONE && prev !== -1) {\r\n        actions[prev] = prevAction;\r\n      }\r\n\r\n      actions[i] = curAction;\r\n      prev = i;\r\n    }\r\n\r\n    // Apply the chosen features to their respective glyphs\r\n    for (let index = 0; index < glyphs.length; index++) {\r\n      let feature;\r\n      var glyph = glyphs[index];\r\n      if (feature = actions[index]) {\r\n        glyph.features[feature] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getShapingClass(codePoint) {\r\n  let res = trie.get(codePoint);\r\n  if (res) {\r\n    return res - 1;\r\n  }\r\n\r\n  let category = unicode.getCategory(codePoint);\r\n  if (category === 'Mn' || category === 'Me' || category === 'Cf') {\r\n    return ShapingClasses.Transparent;\r\n  }\r\n\r\n  return ShapingClasses.Non_Joining;\r\n}\r\n","export default class GlyphIterator {\r\n  constructor(glyphs, options) {\r\n    this.glyphs = glyphs;\r\n    this.reset(options);\r\n  }\r\n\r\n  reset(options = {}, index = 0) {\r\n    this.options = options;\r\n    this.flags = options.flags || {};\r\n    this.markAttachmentType = options.markAttachmentType || 0;\r\n    this.index = index;\r\n  }\r\n\r\n  get cur() {\r\n    return this.glyphs[this.index] || null;\r\n  }\r\n\r\n  shouldIgnore(glyph) {\r\n    return (this.flags.ignoreMarks && glyph.isMark) ||\r\n           (this.flags.ignoreBaseGlyphs && glyph.isBase) ||\r\n           (this.flags.ignoreLigatures && glyph.isLigature) ||\r\n           (this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType);\r\n  }\r\n\r\n  move(dir) {\r\n    this.index += dir;\r\n    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {\r\n      this.index += dir;\r\n    }\r\n\r\n    if (0 > this.index || this.index >= this.glyphs.length) {\r\n      return null;\r\n    }\r\n\r\n    return this.glyphs[this.index];\r\n  }\r\n\r\n  next() {\r\n    return this.move(+1);\r\n  }\r\n\r\n  prev() {\r\n    return this.move(-1);\r\n  }\r\n\r\n  peek(count = 1) {\r\n    let idx = this.index;\r\n    let res = this.increment(count);\r\n    this.index = idx;\r\n    return res;\r\n  }\r\n\r\n  peekIndex(count = 1) {\r\n    let idx = this.index;\r\n    this.increment(count);\r\n    let res = this.index;\r\n    this.index = idx;\r\n    return res;\r\n  }\r\n\r\n  increment(count = 1) {\r\n    let dir = count < 0 ? -1 : 1;\r\n    count = Math.abs(count);\r\n    while (count--) {\r\n      this.move(dir);\r\n    }\r\n\r\n    return this.glyphs[this.index];\r\n  }\r\n}\r\n","import GlyphIterator from './GlyphIterator';\r\nimport * as Script from '../layout/Script';\r\n\r\nconst DEFAULT_SCRIPTS = ['DFLT', 'dflt', 'latn'];\r\n\r\nexport default class OTProcessor {\r\n  constructor(font, table) {\r\n    this.font = font;\r\n    this.table = table;\r\n\r\n    this.script = null;\r\n    this.scriptTag = null;\r\n\r\n    this.language = null;\r\n    this.languageTag = null;\r\n\r\n    this.features = {};\r\n    this.lookups = {};\r\n\r\n    // Setup variation substitutions\r\n    this.variationsIndex = font._variationProcessor\r\n      ? this.findVariationsIndex(font._variationProcessor.normalizedCoords)\r\n      : -1;\r\n\r\n    // initialize to default script + language\r\n    this.selectScript();\r\n\r\n    // current context (set by applyFeatures)\r\n    this.glyphs = [];\r\n    this.positions = []; // only used by GPOS\r\n    this.ligatureID = 1;\r\n    this.currentFeature = null;\r\n  }\r\n\r\n  findScript(script) {\r\n    if (this.table.scriptList == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!Array.isArray(script)) {\r\n      script = [ script ];\r\n    }\r\n\r\n    for (let s of script) {\r\n      for (let entry of this.table.scriptList) {\r\n        if (entry.tag === s) {\r\n          return entry;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  selectScript(script, language, direction) {\r\n    let changed = false;\r\n    let entry;\r\n    if (!this.script || script !== this.scriptTag) {\r\n      entry = this.findScript(script);\r\n      if (!entry) {\r\n        entry = this.findScript(DEFAULT_SCRIPTS);\r\n      }\r\n\r\n      if (!entry) {\r\n        return this.scriptTag;\r\n      }\r\n\r\n      this.scriptTag = entry.tag;\r\n      this.script = entry.script;\r\n      this.language = null;\r\n      this.languageTag = null;\r\n      changed = true;\r\n    }\r\n\r\n    if (!direction || direction !== this.direction) {\r\n      this.direction = direction || Script.direction(script);\r\n    }\r\n\r\n    if (language && language.length < 4) {\r\n      language += ' '.repeat(4 - language.length);\r\n    }\r\n\r\n    if (!language || language !== this.languageTag) {\r\n      this.language = null;\r\n\r\n      for (let lang of this.script.langSysRecords) {\r\n        if (lang.tag === language) {\r\n          this.language = lang.langSys;\r\n          this.languageTag = lang.tag;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!this.language) {\r\n        this.language = this.script.defaultLangSys;\r\n        this.languageTag = null;\r\n      }\r\n\r\n      changed = true;\r\n    }\r\n\r\n    // Build a feature lookup table\r\n    if (changed) {\r\n      this.features = {};\r\n      if (this.language) {\r\n        for (let featureIndex of this.language.featureIndexes) {\r\n          let record = this.table.featureList[featureIndex];\r\n          let substituteFeature = this.substituteFeatureForVariations(featureIndex);\r\n          this.features[record.tag] = substituteFeature || record.feature;\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.scriptTag;\r\n  }\r\n\r\n  lookupsForFeatures(userFeatures = [], exclude) {\r\n    let lookups = [];\r\n    for (let tag of userFeatures) {\r\n      let feature = this.features[tag];\r\n      if (!feature) {\r\n        continue;\r\n      }\r\n\r\n      for (let lookupIndex of feature.lookupListIndexes) {\r\n        if (exclude && exclude.indexOf(lookupIndex) !== -1) {\r\n          continue;\r\n        }\r\n\r\n        lookups.push({\r\n          feature: tag,\r\n          index: lookupIndex,\r\n          lookup: this.table.lookupList.get(lookupIndex)\r\n        });\r\n      }\r\n    }\r\n\r\n    lookups.sort((a, b) => a.index - b.index);\r\n    return lookups;\r\n  }\r\n\r\n  substituteFeatureForVariations(featureIndex) {\r\n    if (this.variationsIndex === -1) {\r\n      return null;\r\n    }\r\n\r\n    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];\r\n    let substitutions = record.featureTableSubstitution.substitutions;\r\n    for (let substitution of substitutions) {\r\n      if (substitution.featureIndex === featureIndex) {\r\n        return substitution.alternateFeatureTable;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  findVariationsIndex(coords) {\r\n    let variations = this.table.featureVariations;\r\n    if (!variations) {\r\n      return -1;\r\n    }\r\n\r\n    let records = variations.featureVariationRecords;\r\n    for (let i = 0; i < records.length; i++) {\r\n      let conditions = records[i].conditionSet.conditionTable;\r\n      if (this.variationConditionsMatch(conditions, coords)) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  variationConditionsMatch(conditions, coords) {\r\n    return conditions.every(condition => {\r\n      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;\r\n      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;\r\n    });\r\n  }\r\n\r\n  applyFeatures(userFeatures, glyphs, advances) {\r\n    let lookups = this.lookupsForFeatures(userFeatures);\r\n    this.applyLookups(lookups, glyphs, advances);\r\n  }\r\n\r\n  applyLookups(lookups, glyphs, positions) {\r\n    this.glyphs = glyphs;\r\n    this.positions = positions;\r\n    this.glyphIterator = new GlyphIterator(glyphs);\r\n\r\n    for (let {feature, lookup} of lookups) {\r\n      this.currentFeature = feature;\r\n      this.glyphIterator.reset(lookup.flags);\r\n\r\n      while (this.glyphIterator.index < glyphs.length) {\r\n        if (!(feature in this.glyphIterator.cur.features)) {\r\n          this.glyphIterator.next();\r\n          continue;\r\n        }\r\n\r\n        for (let table of lookup.subTables) {\r\n          let res = this.applyLookup(lookup.lookupType, table);\r\n          if (res) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        this.glyphIterator.next();\r\n      }\r\n    }\r\n  }\r\n\r\n  applyLookup(lookup, table) {\r\n    throw new Error(\"applyLookup must be implemented by subclasses\");\r\n  }\r\n\r\n  applyLookupList(lookupRecords) {\r\n    let options = this.glyphIterator.options;\r\n    let glyphIndex = this.glyphIterator.index;\r\n\r\n    for (let lookupRecord of lookupRecords) {\r\n      // Reset flags and find glyph index for this lookup record\r\n      this.glyphIterator.reset(options, glyphIndex);\r\n      this.glyphIterator.increment(lookupRecord.sequenceIndex);\r\n\r\n      // Get the lookup and setup flags for subtables\r\n      let lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);\r\n      this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);\r\n\r\n      // Apply lookup subtables until one matches\r\n      for (let table of lookup.subTables) {\r\n        if (this.applyLookup(lookup.lookupType, table)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.glyphIterator.reset(options, glyphIndex);\r\n    return true;\r\n  }\r\n\r\n  coverageIndex(coverage, glyph) {\r\n    if (glyph == null) {\r\n      glyph = this.glyphIterator.cur.id;\r\n    }\r\n\r\n    switch (coverage.version) {\r\n      case 1:\r\n        return coverage.glyphs.indexOf(glyph);\r\n\r\n      case 2:\r\n        for (let range of coverage.rangeRecords) {\r\n          if (range.start <= glyph && glyph <= range.end) {\r\n            return range.startCoverageIndex + glyph - range.start;\r\n          }\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  match(sequenceIndex, sequence, fn, matched) {\r\n    let pos = this.glyphIterator.index;\r\n    let glyph = this.glyphIterator.increment(sequenceIndex);\r\n    let idx = 0;\r\n\r\n    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {\r\n      if (matched) {\r\n        matched.push(this.glyphIterator.index);\r\n      }\r\n\r\n      idx++;\r\n      glyph = this.glyphIterator.next();\r\n    }\r\n\r\n    this.glyphIterator.index = pos;\r\n    if (idx < sequence.length) {\r\n      return false;\r\n    }\r\n\r\n    return matched || true;\r\n  }\r\n\r\n  sequenceMatches(sequenceIndex, sequence) {\r\n    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);\r\n  }\r\n\r\n  sequenceMatchIndices(sequenceIndex, sequence) {\r\n    return this.match(sequenceIndex, sequence, (component, glyph) => {\r\n      // If the current feature doesn't apply to this glyph,\r\n      if (!(this.currentFeature in glyph.features)) {\r\n        return false;\r\n      }\r\n\r\n      return component === glyph.id;\r\n    }, []);\r\n  }\r\n\r\n  coverageSequenceMatches(sequenceIndex, sequence) {\r\n    return this.match(sequenceIndex, sequence, (coverage, glyph) =>\r\n      this.coverageIndex(coverage, glyph.id) >= 0\r\n    );\r\n  }\r\n\r\n  getClassID(glyph, classDef) {\r\n    switch (classDef.version) {\r\n      case 1: // Class array\r\n        let i = glyph - classDef.startGlyph;\r\n        if (i >= 0 && i < classDef.classValueArray.length) {\r\n          return classDef.classValueArray[i];\r\n        }\r\n\r\n        break;\r\n\r\n      case 2:\r\n        for (let range of classDef.classRangeRecord) {\r\n          if (range.start <= glyph && glyph <= range.end) {\r\n            return range.class;\r\n          }\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  classSequenceMatches(sequenceIndex, sequence, classDef) {\r\n    return this.match(sequenceIndex, sequence, (classID, glyph) =>\r\n      classID === this.getClassID(glyph.id, classDef)\r\n    );\r\n  }\r\n\r\n  applyContext(table) {\r\n    switch (table.version) {\r\n      case 1:\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        let set = table.ruleSets[index];\r\n        for (let rule of set) {\r\n          if (this.sequenceMatches(1, rule.input)) {\r\n            return this.applyLookupList(rule.lookupRecords);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 2:\r\n        if (this.coverageIndex(table.coverage) === -1) {\r\n          return false;\r\n        }\r\n\r\n        index = this.getClassID(this.glyphIterator.cur.id, table.classDef);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        set = table.classSet[index];\r\n        for (let rule of set) {\r\n          if (this.classSequenceMatches(1, rule.classes, table.classDef)) {\r\n            return this.applyLookupList(rule.lookupRecords);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 3:\r\n        if (this.coverageSequenceMatches(0, table.coverages)) {\r\n          return this.applyLookupList(table.lookupRecords);\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  applyChainingContext(table) {\r\n    switch (table.version) {\r\n      case 1:\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        let set = table.chainRuleSets[index];\r\n        for (let rule of set) {\r\n          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack)\r\n              && this.sequenceMatches(1, rule.input)\r\n              && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {\r\n            return this.applyLookupList(rule.lookupRecords);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 2:\r\n        if (this.coverageIndex(table.coverage) === -1) {\r\n          return false;\r\n        }\r\n\r\n        index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);\r\n        let rules = table.chainClassSet[index];\r\n        if (!rules) {\r\n          return false;\r\n        }\r\n\r\n        for (let rule of rules) {\r\n          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) &&\r\n              this.classSequenceMatches(1, rule.input, table.inputClassDef) &&\r\n              this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) {\r\n            return this.applyLookupList(rule.lookupRecords);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 3:\r\n        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) &&\r\n            this.coverageSequenceMatches(0, table.inputCoverage) &&\r\n            this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {\r\n          return this.applyLookupList(table.lookupRecords);\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","import unicode from 'unicode-properties';\r\nimport OTProcessor from './OTProcessor';\r\n\r\nexport default class GlyphInfo {\r\n  constructor(font, id, codePoints = [], features) {\r\n    this._font = font;\r\n    this.codePoints = codePoints;\r\n    this.id = id;\r\n\r\n    this.features = {};\r\n    if (Array.isArray(features)) {\r\n      for (let i = 0; i < features.length; i++) {\r\n        let feature = features[i];\r\n        this.features[feature] = true;\r\n      }\r\n    } else if (typeof features === 'object') {\r\n      Object.assign(this.features, features);\r\n    }\r\n\r\n    this.ligatureID = null;\r\n    this.ligatureComponent = null;\r\n    this.isLigated = false;\r\n    this.cursiveAttachment = null;\r\n    this.markAttachment = null;\r\n    this.shaperInfo = null;\r\n    this.substituted = false;\r\n    this.isMultiplied = false;\r\n  }\r\n\r\n  get id() {\r\n    return this._id;\r\n  }\r\n\r\n  set id(id) {\r\n    this._id = id;\r\n    this.substituted = true;\r\n\r\n    let GDEF = this._font.GDEF;\r\n    if (GDEF && GDEF.glyphClassDef) {\r\n      // TODO: clean this up\r\n      let classID = OTProcessor.prototype.getClassID(id, GDEF.glyphClassDef);\r\n      this.isBase = classID === 1;\r\n      this.isLigature = classID === 2;\r\n      this.isMark = classID === 3;\r\n      this.markAttachmentType = GDEF.markAttachClassDef ? OTProcessor.prototype.getClassID(id, GDEF.markAttachClassDef) : 0;\r\n    } else {\r\n      this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);\r\n      this.isBase = !this.isMark;\r\n      this.isLigature = this.codePoints.length > 1;\r\n      this.markAttachmentType = 0;\r\n    }\r\n  }\r\n\r\n  copy() {\r\n    return new GlyphInfo(this._font, this.id, this.codePoints, this.features);\r\n  }\r\n}\r\n","import DefaultShaper from './DefaultShaper';\r\nimport GlyphInfo from '../GlyphInfo';\r\n\r\n/**\r\n * This is a shaper for the Hangul script, used by the Korean language.\r\n * It does the following:\r\n *   - decompose if unsupported by the font:\r\n *     <LV>   -> <L,V>\r\n *     <LVT>  -> <L,V,T>\r\n *     <LV,T> -> <L,V,T>\r\n *\r\n *   - compose if supported by the font:\r\n *     <L,V>   -> <LV>\r\n *     <L,V,T> -> <LVT>\r\n *     <LV,T>  -> <LVT>\r\n *\r\n *   - reorder tone marks (S is any valid syllable):\r\n *     <S, M> -> <M, S>\r\n *\r\n *   - apply ljmo, vjmo, and tjmo OpenType features to decomposed Jamo sequences.\r\n *\r\n * This logic is based on the following documents:\r\n *   - http://www.microsoft.com/typography/OpenTypeDev/hangul/intro.htm\r\n *   - http://ktug.org/~nomos/harfbuzz-hangul/hangulshaper.pdf\r\n */\r\nexport default class HangulShaper extends DefaultShaper {\r\n  static zeroMarkWidths = 'NONE';\r\n  static planFeatures(plan) {\r\n    plan.add(['ljmo', 'vjmo', 'tjmo'], false);\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    let state = 0;\r\n    let i = 0;\r\n    while (i < glyphs.length) {\r\n      let action;\r\n      let glyph = glyphs[i];\r\n      let code = glyph.codePoints[0];\r\n      let type = getType(code);\r\n\r\n      [ action, state ] = STATE_TABLE[state][type];\r\n\r\n      switch (action) {\r\n        case DECOMPOSE:\r\n          // Decompose the composed syllable if it is not supported by the font.\r\n          if (!plan.font.hasGlyphForCodePoint(code)) {\r\n            i = decompose(glyphs, i, plan.font);\r\n          }\r\n          break;\r\n\r\n        case COMPOSE:\r\n          // Found a decomposed syllable. Try to compose if supported by the font.\r\n          i = compose(glyphs, i, plan.font);\r\n          break;\r\n\r\n        case TONE_MARK:\r\n          // Got a valid syllable, followed by a tone mark. Move the tone mark to the beginning of the syllable.\r\n          reorderToneMark(glyphs, i, plan.font);\r\n          break;\r\n\r\n        case INVALID:\r\n          // Tone mark has no valid syllable to attach to, so insert a dotted circle\r\n          i = insertDottedCircle(glyphs, i, plan.font);\r\n          break;\r\n      }\r\n\r\n      i++;\r\n    }\r\n  }\r\n}\r\n\r\nconst HANGUL_BASE  = 0xac00;\r\nconst HANGUL_END   = 0xd7a4;\r\nconst HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;\r\nconst L_BASE  = 0x1100; // lead\r\nconst V_BASE  = 0x1161; // vowel\r\nconst T_BASE  = 0x11a7; // trail\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst L_END   = L_BASE + L_COUNT - 1;\r\nconst V_END   = V_BASE + V_COUNT - 1;\r\nconst T_END   = T_BASE + T_COUNT - 1;\r\nconst DOTTED_CIRCLE = 0x25cc;\r\n\r\nconst isL    = code => 0x1100 <= code && code <= 0x115f || 0xa960 <= code && code <= 0xa97c;\r\nconst isV    = code => 0x1160 <= code && code <= 0x11a7 || 0xd7b0 <= code && code <= 0xd7c6;\r\nconst isT    = code => 0x11a8 <= code && code <= 0x11ff || 0xd7cb <= code && code <= 0xd7fb;\r\nconst isTone = code => 0x302e <= code && code <= 0x302f;\r\nconst isLVT  = code => HANGUL_BASE <= code && code <= HANGUL_END;\r\nconst isLV   = code => (code - HANGUL_BASE) < HANGUL_COUNT && (code - HANGUL_BASE) % T_COUNT === 0;\r\nconst isCombiningL = code => L_BASE <= code && code <= L_END;\r\nconst isCombiningV = code => V_BASE <= code && code <= V_END;\r\nconst isCombiningT = code => T_BASE + 1 && 1 <= code && code <= T_END;\r\n\r\n// Character categories\r\nconst X   = 0; // Other character\r\nconst L   = 1; // Leading consonant\r\nconst V   = 2; // Medial vowel\r\nconst T   = 3; // Trailing consonant\r\nconst LV  = 4; // Composed <LV> syllable\r\nconst LVT = 5; // Composed <LVT> syllable\r\nconst M   = 6; // Tone mark\r\n\r\n// This function classifies a character using the above categories.\r\nfunction getType(code) {\r\n  if (isL(code))    { return L; }\r\n  if (isV(code))    { return V; }\r\n  if (isT(code))    { return T; }\r\n  if (isLV(code))   { return LV; }\r\n  if (isLVT(code))  { return LVT; }\r\n  if (isTone(code)) { return M; }\r\n  return X;\r\n}\r\n\r\n// State machine actions\r\nconst NO_ACTION = 0;\r\nconst DECOMPOSE = 1;\r\nconst COMPOSE   = 2;\r\nconst TONE_MARK = 4;\r\nconst INVALID   = 5;\r\n\r\n// Build a state machine that accepts valid syllables, and applies actions along the way.\r\n// The logic this is implementing is documented at the top of the file.\r\nconst STATE_TABLE = [\r\n  //       X                 L                 V                T                  LV                LVT               M\r\n  // State 0: start state\r\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [  INVALID, 0  ] ],\r\n\r\n  // State 1: <L>\r\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [  COMPOSE, 2  ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [  INVALID, 0  ] ],\r\n\r\n  // State 2: <L,V> or <LV>\r\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [  COMPOSE, 3  ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [ TONE_MARK, 0 ] ],\r\n\r\n  // State 3: <L,V,T> or <LVT>\r\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [ TONE_MARK, 0 ] ]\r\n];\r\n\r\nfunction getGlyph(font, code, features) {\r\n  return new GlyphInfo(font, font.glyphForCodePoint(code).id, [code], features);\r\n}\r\n\r\nfunction decompose(glyphs, i, font) {\r\n  let glyph = glyphs[i];\r\n  let code = glyph.codePoints[0];\r\n\r\n  let s = code - HANGUL_BASE;\r\n  let t = T_BASE + s % T_COUNT;\r\n  s = s / T_COUNT | 0;\r\n  let l = L_BASE + s / V_COUNT | 0;\r\n  let v = V_BASE + s % V_COUNT;\r\n\r\n  // Don't decompose if all of the components are not available\r\n  if (!font.hasGlyphForCodePoint(l) ||\r\n      !font.hasGlyphForCodePoint(v) ||\r\n      (t !== T_BASE && !font.hasGlyphForCodePoint(t))) {\r\n    return i;\r\n  }\r\n\r\n  // Replace the current glyph with decomposed L, V, and T glyphs,\r\n  // and apply the proper OpenType features to each component.\r\n  let ljmo = getGlyph(font, l, glyph.features);\r\n  ljmo.features.ljmo = true;\r\n\r\n  let vjmo = getGlyph(font, v, glyph.features);\r\n  vjmo.features.vjmo = true;\r\n\r\n  let insert = [ ljmo, vjmo ];\r\n\r\n  if (t > T_BASE) {\r\n    let tjmo = getGlyph(font, t, glyph.features);\r\n    tjmo.features.tjmo = true;\r\n    insert.push(tjmo);\r\n  }\r\n\r\n  glyphs.splice(i, 1, ...insert);\r\n  return i + insert.length - 1;\r\n}\r\n\r\nfunction compose(glyphs, i, font) {\r\n  let glyph = glyphs[i];\r\n  let code = glyphs[i].codePoints[0];\r\n  let type = getType(code);\r\n\r\n  let prev = glyphs[i - 1].codePoints[0];\r\n  let prevType = getType(prev);\r\n\r\n  // Figure out what type of syllable we're dealing with\r\n  let lv, ljmo, vjmo, tjmo;\r\n  if (prevType === LV && type === T) {\r\n    // <LV,T>\r\n    lv = prev;\r\n    tjmo = glyph;\r\n  } else {\r\n    if (type === V) {\r\n      // <L,V>\r\n      ljmo = glyphs[i - 1];\r\n      vjmo = glyph;\r\n    } else {\r\n      // <L,V,T>\r\n      ljmo = glyphs[i - 2];\r\n      vjmo = glyphs[i - 1];\r\n      tjmo = glyph;\r\n    }\r\n\r\n    let l = ljmo.codePoints[0];\r\n    let v = vjmo.codePoints[0];\r\n\r\n    // Make sure L and V are combining characters\r\n    if (isCombiningL(l) && isCombiningV(v)) {\r\n      lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;\r\n    }\r\n  }\r\n\r\n  let t = (tjmo && tjmo.codePoints[0]) || T_BASE;\r\n  if ((lv != null) && (t === T_BASE || isCombiningT(t))) {\r\n    let s = lv + (t - T_BASE);\r\n\r\n    // Replace with a composed glyph if supported by the font,\r\n    // otherwise apply the proper OpenType features to each component.\r\n    if (font.hasGlyphForCodePoint(s)) {\r\n      let del = prevType === V ? 3 : 2;\r\n      glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));\r\n      return i - del + 1;\r\n    }\r\n  }\r\n\r\n  // Didn't compose (either a non-combining component or unsupported by font).\r\n  if (ljmo) { ljmo.features.ljmo = true; }\r\n  if (vjmo) { vjmo.features.vjmo = true; }\r\n  if (tjmo) { tjmo.features.tjmo = true; }\r\n\r\n  if (prevType === LV) {\r\n    // Sequence was originally <L,V>, which got combined earlier.\r\n    // Either the T was non-combining, or the LVT glyph wasn't supported.\r\n    // Decompose the glyph again and apply OT features.\r\n    decompose(glyphs, i - 1, font);\r\n    return i + 1;\r\n  }\r\n\r\n  return i;\r\n}\r\n\r\nfunction getLength(code) {\r\n  switch (getType(code)) {\r\n    case LV:\r\n    case LVT:\r\n      return 1;\r\n    case V:\r\n      return 2;\r\n    case T:\r\n      return 3;\r\n  }\r\n}\r\n\r\nfunction reorderToneMark(glyphs, i, font) {\r\n  let glyph = glyphs[i];\r\n  let code = glyphs[i].codePoints[0];\r\n\r\n  // Move tone mark to the beginning of the previous syllable, unless it is zero width\r\n  if (font.glyphForCodePoint(code).advanceWidth === 0) { return; }\r\n\r\n  let prev = glyphs[i - 1].codePoints[0];\r\n  let len = getLength(prev);\r\n\r\n  glyphs.splice(i, 1);\r\n  return glyphs.splice(i - len, 0, glyph);\r\n}\r\n\r\nfunction insertDottedCircle(glyphs, i, font) {\r\n  let glyph = glyphs[i];\r\n  let code = glyphs[i].codePoints[0];\r\n\r\n  if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {\r\n    let dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features);\r\n\r\n    // If the tone mark is zero width, insert the dotted circle before, otherwise after\r\n    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;\r\n    glyphs.splice(idx, 0, dottedCircle);\r\n    i++;\r\n  }\r\n\r\n  return i;\r\n}\r\n","// Cateories used in the OpenType spec:\r\n// https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx\r\nexport const CATEGORIES = {\r\n  X: 1 << 0,\r\n  C: 1 << 1,\r\n  V: 1 << 2,\r\n  N: 1 << 3,\r\n  H: 1 << 4,\r\n  ZWNJ: 1 << 5,\r\n  ZWJ: 1 << 6,\r\n  M: 1 << 7,\r\n  SM: 1 << 8,\r\n  VD: 1 << 9,\r\n  A: 1 << 10,\r\n  Placeholder: 1 << 11,\r\n  Dotted_Circle: 1 << 12,\r\n  RS: 1 << 13,    // Register Shifter, used in Khmer OT spec.\r\n  Coeng: 1 << 14, // Khmer-style Virama.\r\n  Repha: 1 << 15, // Atomically-encoded logical or visual repha.\r\n  Ra: 1 << 16,\r\n  CM: 1 << 17,    // Consonant-Medial.\r\n  Symbol: 1 << 18 // Avagraha, etc that take marks (SM,A,VD).\r\n};\r\n\r\n// Visual positions in a syllable from left to right.\r\nexport const POSITIONS = {\r\n  Start: 1 << 0,\r\n\r\n  Ra_To_Become_Reph: 1 << 1,\r\n  Pre_M: 1 << 2,\r\n  Pre_C: 1 << 3,\r\n\r\n  Base_C: 1 << 4,\r\n  After_Main: 1 << 5,\r\n\r\n  Above_C: 1 << 6,\r\n\r\n  Before_Sub: 1 << 7,\r\n  Below_C: 1 << 8,\r\n  After_Sub: 1 << 9,\r\n\r\n  Before_Post: 1 << 10,\r\n  Post_C: 1 << 11,\r\n  After_Post: 1 << 12,\r\n\r\n  Final_C: 1 << 13,\r\n  SMVD: 1 << 14,\r\n\r\n  End: 1 << 15\r\n};\r\n\r\nexport const CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;\r\nexport const JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;\r\nexport const HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;\r\n\r\nexport const INDIC_CONFIGS = {\r\n  Default: {\r\n    hasOldSpec: false,\r\n    virama: 0,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.Before_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Devanagari: {\r\n    hasOldSpec: true,\r\n    virama: 0x094D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.Before_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Bengali: {\r\n    hasOldSpec: true,\r\n    virama: 0x09CD,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Sub,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Gurmukhi: {\r\n    hasOldSpec: true,\r\n    virama: 0x0A4D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.Before_Sub,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Gujarati: {\r\n    hasOldSpec: true,\r\n    virama: 0x0ACD,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.Before_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Oriya: {\r\n    hasOldSpec: true,\r\n    virama: 0x0B4D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Main,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Tamil: {\r\n    hasOldSpec: true,\r\n    virama: 0x0BCD,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Telugu: {\r\n    hasOldSpec: true,\r\n    virama: 0x0C4D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Post,\r\n    rephMode: 'Explicit',\r\n    blwfMode: 'Post_Only'\r\n  },\r\n\r\n  Kannada: {\r\n    hasOldSpec: true,\r\n    virama: 0x0CCD,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Post_Only'\r\n  },\r\n\r\n  Malayalam: {\r\n    hasOldSpec: true,\r\n    virama: 0x0D4D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Main,\r\n    rephMode: 'Log_Repha',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  // Handled by UniversalShaper\r\n  // Sinhala: {\r\n  //   hasOldSpec: false,\r\n  //   virama: 0x0DCA,\r\n  //   basePos: 'Last_Sinhala',\r\n  //   rephPos: POSITIONS.After_Main,\r\n  //   rephMode: 'Explicit',\r\n  //   blwfMode: 'Pre_And_Post'\r\n  // },\r\n\r\n  Khmer: {\r\n    hasOldSpec: false,\r\n    virama: 0x17D2,\r\n    basePos: 'First',\r\n    rephPos: POSITIONS.Ra_To_Become_Reph,\r\n    rephMode: 'Vis_Repha',\r\n    blwfMode: 'Pre_And_Post'\r\n  }\r\n};\r\n\r\n// Additional decompositions that aren't in Unicode\r\nexport const INDIC_DECOMPOSITIONS = {\r\n  // Khmer\r\n  0x17BE: [0x17C1, 0x17BE],\r\n  0x17BF: [0x17C1, 0x17BF],\r\n  0x17C0: [0x17C1, 0x17C0],\r\n  0x17C4: [0x17C1, 0x17C4],\r\n  0x17C5: [0x17C1, 0x17C5]\r\n};\r\n","import DefaultShaper from './DefaultShaper';\r\nimport StateMachine from 'dfa';\r\nimport UnicodeTrie from 'unicode-trie';\r\nimport unicode from 'unicode-properties';\r\nimport * as Script from '../../layout/Script';\r\nimport GlyphInfo from '../GlyphInfo';\r\nimport indicMachine from './indic.json';\r\nimport useData from './use.json';\r\nimport {\r\n  CATEGORIES,\r\n  POSITIONS,\r\n  CONSONANT_FLAGS,\r\n  JOINER_FLAGS,\r\n  HALANT_OR_COENG_FLAGS, INDIC_CONFIGS,\r\n  INDIC_DECOMPOSITIONS\r\n} from './indic-data';\r\n\r\nconst {decompositions} = useData;\r\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/indic.trie'));\r\nconst stateMachine = new StateMachine(indicMachine);\r\n\r\n/**\r\n * The IndicShaper supports indic scripts e.g. Devanagari, Kannada, etc.\r\n * Based on code from Harfbuzz: https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-indic.cc\r\n */\r\nexport default class IndicShaper extends DefaultShaper {\r\n  static zeroMarkWidths = 'NONE';\r\n  static planFeatures(plan) {\r\n    plan.addStage(setupSyllables);\r\n\r\n    plan.addStage(['locl', 'ccmp']);\r\n\r\n    plan.addStage(initialReordering);\r\n\r\n    plan.addStage('nukt');\r\n    plan.addStage('akhn');\r\n    plan.addStage('rphf', false);\r\n    plan.addStage('rkrf');\r\n    plan.addStage('pref', false);\r\n    plan.addStage('blwf', false);\r\n    plan.addStage('abvf', false);\r\n    plan.addStage('half', false);\r\n    plan.addStage('pstf', false);\r\n    plan.addStage('vatu');\r\n    plan.addStage('cjct');\r\n    plan.addStage('cfar', false);\r\n\r\n    plan.addStage(finalReordering);\r\n\r\n    plan.addStage({\r\n      local: ['init'],\r\n      global: ['pres', 'abvs', 'blws', 'psts', 'haln', 'dist', 'abvm', 'blwm', 'calt', 'clig']\r\n    });\r\n\r\n    // Setup the indic config for the selected script\r\n    plan.unicodeScript = Script.fromOpenType(plan.script);\r\n    plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;\r\n    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== '2';\r\n\r\n    // TODO: turn off kern (Khmer) and liga features.\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    // Decompose split matras\r\n    // TODO: do this in a more general unicode normalizer\r\n    for (let i = glyphs.length - 1; i >= 0; i--) {\r\n      let codepoint = glyphs[i].codePoints[0];\r\n      let d = INDIC_DECOMPOSITIONS[codepoint] || decompositions[codepoint];\r\n      if (d) {\r\n        let decomposed = d.map(c => {\r\n          let g = plan.font.glyphForCodePoint(c);\r\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\r\n        });\r\n\r\n        glyphs.splice(i, 1, ...decomposed);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction indicCategory(glyph) {\r\n  return trie.get(glyph.codePoints[0]) >> 8;\r\n}\r\n\r\nfunction indicPosition(glyph) {\r\n  return 1 << (trie.get(glyph.codePoints[0]) & 0xff);\r\n}\r\n\r\nclass IndicInfo {\r\n  constructor(category, position, syllableType, syllable) {\r\n    this.category = category;\r\n    this.position = position;\r\n    this.syllableType = syllableType;\r\n    this.syllable = syllable;\r\n  }\r\n}\r\n\r\nfunction setupSyllables(font, glyphs) {\r\n  let syllable = 0;\r\n  let last = 0;\r\n  for (let [start, end, tags] of stateMachine.match(glyphs.map(indicCategory))) {\r\n    if (start > last) {\r\n      ++syllable;\r\n      for (let i = last; i < start; i++) {\r\n        glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\r\n      }\r\n    }\r\n\r\n    ++syllable;\r\n\r\n    // Create shaper info\r\n    for (let i = start; i <= end; i++) {\r\n      glyphs[i].shaperInfo = new IndicInfo(\r\n        1 << indicCategory(glyphs[i]),\r\n        indicPosition(glyphs[i]),\r\n        tags[0],\r\n        syllable\r\n      );\r\n    }\r\n\r\n    last = end + 1;\r\n  }\r\n\r\n  if (last < glyphs.length) {\r\n    ++syllable;\r\n    for (let i = last; i < glyphs.length; i++) {\r\n      glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\r\n    }\r\n  }\r\n}\r\n\r\nfunction isConsonant(glyph) {\r\n  return glyph.shaperInfo.category & CONSONANT_FLAGS;\r\n}\r\n\r\nfunction isJoiner(glyph) {\r\n  return glyph.shaperInfo.category & JOINER_FLAGS;\r\n}\r\n\r\nfunction isHalantOrCoeng(glyph) {\r\n  return glyph.shaperInfo.category & HALANT_OR_COENG_FLAGS;\r\n}\r\n\r\nfunction wouldSubstitute(glyphs, feature) {\r\n  for (let glyph of glyphs) {\r\n    glyph.features = {[feature]: true};\r\n  }\r\n\r\n  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;\r\n  GSUB.applyFeatures([feature], glyphs);\r\n\r\n  return glyphs.length === 1;\r\n}\r\n\r\nfunction consonantPosition(font, consonant, virama) {\r\n  let glyphs = [virama, consonant, virama];\r\n  if (wouldSubstitute(glyphs.slice(0, 2), 'blwf') || wouldSubstitute(glyphs.slice(1, 3), 'blwf')) {\r\n    return POSITIONS.Below_C;\r\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pstf') || wouldSubstitute(glyphs.slice(1, 3), 'pstf')) {\r\n    return POSITIONS.Post_C;\r\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pref') || wouldSubstitute(glyphs.slice(1, 3), 'pref')) {\r\n    return POSITIONS.Post_C;\r\n  }\r\n\r\n  return POSITIONS.Base_C;\r\n}\r\n\r\nfunction initialReordering(font, glyphs, plan) {\r\n  let indicConfig = plan.indicConfig;\r\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\r\n\r\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\r\n  let virama = font.glyphForCodePoint(indicConfig.virama).id;\r\n  if (virama) {\r\n    let info = new GlyphInfo(font, virama, [indicConfig.virama]);\r\n    for (let i = 0; i < glyphs.length; i++) {\r\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\r\n        glyphs[i].shaperInfo.position = consonantPosition(font, glyphs[i].copy(), info);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\r\n    let {category, syllableType} = glyphs[start].shaperInfo;\r\n\r\n    if (syllableType === 'symbol_cluster' || syllableType === 'non_indic_cluster') {\r\n      continue;\r\n    }\r\n\r\n    if (syllableType === 'broken_cluster' && dottedCircle) {\r\n      let g = new GlyphInfo(font, dottedCircle, [0x25cc]);\r\n      g.shaperInfo = new IndicInfo(\r\n        1 << indicCategory(g),\r\n        indicPosition(g),\r\n        glyphs[start].shaperInfo.syllableType,\r\n        glyphs[start].shaperInfo.syllable\r\n      );\r\n\r\n      // Insert after possible Repha.\r\n      let i = start;\r\n      while (i < end && glyphs[i].shaperInfo.category === CATEGORIES.Repha) {\r\n        i++;\r\n      }\r\n\r\n      glyphs.splice(i++, 0, g);\r\n      end++;\r\n    }\r\n\r\n    // 1. Find base consonant:\r\n    //\r\n    // The shaping engine finds the base consonant of the syllable, using the\r\n    // following algorithm: starting from the end of the syllable, move backwards\r\n    // until a consonant is found that does not have a below-base or post-base\r\n    // form (post-base forms have to follow below-base forms), or that is not a\r\n    // pre-base reordering Ra, or arrive at the first consonant. The consonant\r\n    // stopped at will be the base.\r\n\r\n    let base = end;\r\n    let limit = start;\r\n    let hasReph = false;\r\n\r\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\r\n    // and has more than one consonant, Ra is excluded from candidates for\r\n    // base consonants.\r\n    if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph &&\r\n      features.rphf &&\r\n      start + 3 <= end && (\r\n        (indicConfig.rephMode === 'Implicit' && !isJoiner(glyphs[start + 2])) ||\r\n        (indicConfig.rephMode === 'Explicit' && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)\r\n      )\r\n    ) {\r\n      // See if it matches the 'rphf' feature.\r\n      let g = [glyphs[start].copy(), glyphs[start + 1].copy(), glyphs[start + 2].copy()];\r\n      if (wouldSubstitute(g.slice(0, 2), 'rphf') || (indicConfig.rephMode === 'Explicit' && wouldSubstitute(g, 'rphf'))) {\r\n        limit += 2;\r\n        while (limit < end && isJoiner(glyphs[limit])) {\r\n          limit++;\r\n        }\r\n        base = start;\r\n        hasReph = true;\r\n      }\r\n    } else if (indicConfig.rephMode === 'Log_Repha' && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {\r\n      limit++;\r\n      while (limit < end && isJoiner(glyphs[limit])) {\r\n        limit++;\r\n      }\r\n      base = start;\r\n      hasReph = true;\r\n    }\r\n\r\n    switch (indicConfig.basePos) {\r\n      case 'Last': {\r\n        // starting from the end of the syllable, move backwards\r\n        let i = end;\r\n        let seenBelow = false;\r\n\r\n        do {\r\n          let info = glyphs[--i].shaperInfo;\r\n\r\n          // until a consonant is found\r\n          if (isConsonant(glyphs[i])) {\r\n            // that does not have a below-base or post-base form\r\n            // (post-base forms have to follow below-base forms),\r\n            if (info.position !== POSITIONS.Below_C && (info.position !== POSITIONS.Post_C || seenBelow)) {\r\n              base = i;\r\n              break;\r\n            }\r\n\r\n            // or that is not a pre-base reordering Ra,\r\n            //\r\n            // IMPLEMENTATION NOTES:\r\n            //\r\n            // Our pre-base reordering Ra's are marked POS_POST_C, so will be skipped\r\n            // by the logic above already.\r\n            //\r\n\r\n            // or arrive at the first consonant. The consonant stopped at will\r\n            // be the base.\r\n            if (info.position === POSITIONS.Below_C) {\r\n              seenBelow = true;\r\n            }\r\n\r\n            base = i;\r\n          } else if (start < i && info.category === CATEGORIES.ZWJ && glyphs[i - 1].shaperInfo.category === CATEGORIES.H) {\r\n            // A ZWJ after a Halant stops the base search, and requests an explicit\r\n            // half form.\r\n            // A ZWJ before a Halant, requests a subjoined form instead, and hence\r\n            // search continues.  This is particularly important for Bengali\r\n            // sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya.\r\n            break;\r\n          }\r\n        } while (i > limit);\r\n        break;\r\n      }\r\n\r\n      case 'First': {\r\n        // The first consonant is always the base.\r\n        base = start;\r\n\r\n        // Mark all subsequent consonants as below.\r\n        for (let i = base + 1; i < end; i++) {\r\n          if (isConsonant(glyphs[i])) {\r\n            glyphs[i].shaperInfo.position = POSITIONS.Below_C;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\r\n    // and has more than one consonant, Ra is excluded from candidates for\r\n    // base consonants.\r\n    //\r\n    //  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ)\r\n    if (hasReph && base === start && limit - base <= 2) {\r\n      hasReph = false;\r\n    }\r\n\r\n    // 2. Decompose and reorder Matras:\r\n    //\r\n    // Each matra and any syllable modifier sign in the cluster are moved to the\r\n    // appropriate position relative to the consonant(s) in the cluster. The\r\n    // shaping engine decomposes two- or three-part matras into their constituent\r\n    // parts before any repositioning. Matra characters are classified by which\r\n    // consonant in a conjunct they have affinity for and are reordered to the\r\n    // following positions:\r\n    //\r\n    //   o Before first half form in the syllable\r\n    //   o After subjoined consonants\r\n    //   o After post-form consonant\r\n    //   o After main consonant (for above marks)\r\n    //\r\n    // IMPLEMENTATION NOTES:\r\n    //\r\n    // The normalize() routine has already decomposed matras for us, so we don't\r\n    // need to worry about that.\r\n\r\n    // 3.  Reorder marks to canonical order:\r\n    //\r\n    // Adjacent nukta and halant or nukta and vedic sign are always repositioned\r\n    // if necessary, so that the nukta is first.\r\n    //\r\n    // IMPLEMENTATION NOTES:\r\n    //\r\n    // We don't need to do this: the normalize() routine already did this for us.\r\n\r\n    // Reorder characters\r\n\r\n    for (let i = start; i < base; i++) {\r\n      let info = glyphs[i].shaperInfo;\r\n      info.position = Math.min(POSITIONS.Pre_C, info.position);\r\n    }\r\n\r\n    if (base < end) {\r\n      glyphs[base].shaperInfo.position = POSITIONS.Base_C;\r\n    }\r\n\r\n    // Mark final consonants.  A final consonant is one appearing after a matra,\r\n    // like in Khmer.\r\n    for (let i = base + 1; i < end; i++) {\r\n      if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\r\n        for (let j = i + 1; j < end; j++) {\r\n          if (isConsonant(glyphs[j])) {\r\n            glyphs[j].shaperInfo.position = POSITIONS.Final_C;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Handle beginning Ra\r\n    if (hasReph) {\r\n      glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;\r\n    }\r\n\r\n    // For old-style Indic script tags, move the first post-base Halant after\r\n    // last consonant.\r\n    //\r\n    // Reports suggest that in some scripts Uniscribe does this only if there\r\n    // is *not* a Halant after last consonant already (eg. Kannada), while it\r\n    // does it unconditionally in other scripts (eg. Malayalam).  We don't\r\n    // currently know about other scripts, so we single out Malayalam for now.\r\n    //\r\n    // Kannada test case:\r\n    // U+0C9A,U+0CCD,U+0C9A,U+0CCD\r\n    // With some versions of Lohit Kannada.\r\n    // https://bugs.freedesktop.org/show_bug.cgi?id=59118\r\n    //\r\n    // Malayalam test case:\r\n    // U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\r\n    // With lohit-ttf-20121122/Lohit-Malayalam.ttf\r\n    if (plan.isOldSpec) {\r\n      let disallowDoubleHalants = plan.unicodeScript !== 'Malayalam';\r\n      for (let i = base + 1; i < end; i++) {\r\n        if (glyphs[i].shaperInfo.category === CATEGORIES.H) {\r\n          let j;\r\n          for (j = end - 1; j > i; j--) {\r\n            if (isConsonant(glyphs[j]) || (disallowDoubleHalants && glyphs[j].shaperInfo.category === CATEGORIES.H)) {\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (glyphs[j].shaperInfo.category !== CATEGORIES.H && j > i) {\r\n            // Move Halant to after last consonant.\r\n            let t = glyphs[i];\r\n            glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));\r\n            glyphs[j] = t;\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Attach misc marks to previous char to move with them.\r\n    let lastPos = POSITIONS.Start;\r\n    for (let i = start; i < end; i++) {\r\n      let info = glyphs[i].shaperInfo;\r\n      if (info.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & info.category)) {\r\n        info.position = lastPos;\r\n        if (info.category === CATEGORIES.H && info.position === POSITIONS.Pre_M) {\r\n          // Uniscribe doesn't move the Halant with Left Matra.\r\n          // TEST: U+092B,U+093F,U+094DE\r\n          // We follow.  This is important for the Sinhala\r\n          // U+0DDA split matra since it decomposes to U+0DD9,U+0DCA\r\n          // where U+0DD9 is a left matra and U+0DCA is the virama.\r\n          // We don't want to move the virama with the left matra.\r\n          // TEST: U+0D9A,U+0DDA\r\n          for (let j = i; j > start; j--) {\r\n            if (glyphs[j - 1].shaperInfo.position !== POSITIONS.Pre_M) {\r\n              info.position = glyphs[j - 1].shaperInfo.position;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      } else if (info.position !== POSITIONS.SMVD) {\r\n        lastPos = info.position;\r\n      }\r\n    }\r\n\r\n    // For post-base consonants let them own anything before them\r\n    // since the last consonant or matra.\r\n    let last = base;\r\n    for (let i = base + 1; i < end; i++) {\r\n      if (isConsonant(glyphs[i])) {\r\n        for (let j = last + 1; j < i; j++) {\r\n          if (glyphs[j].shaperInfo.position < POSITIONS.SMVD) {\r\n            glyphs[j].shaperInfo.position = glyphs[i].shaperInfo.position;\r\n          }\r\n        }\r\n        last = i;\r\n      } else if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\r\n        last = i;\r\n      }\r\n    }\r\n\r\n    let arr = glyphs.slice(start, end);\r\n    arr.sort((a, b) => a.shaperInfo.position - b.shaperInfo.position);\r\n    glyphs.splice(start, arr.length, ...arr);\r\n\r\n    // Find base again\r\n    for (let i = start; i < end; i++) {\r\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\r\n        base = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Setup features now\r\n\r\n    // Reph\r\n    for (let i = start; i < end && glyphs[i].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; i++) {\r\n      glyphs[i].features.rphf = true;\r\n    }\r\n\r\n    // Pre-base\r\n    let blwf = !plan.isOldSpec && indicConfig.blwfMode === 'Pre_And_Post';\r\n    for (let i = start; i < base; i++) {\r\n      glyphs[i].features.half = true;\r\n      if (blwf) {\r\n        glyphs[i].features.blwf = true;\r\n      }\r\n    }\r\n\r\n    // Post-base\r\n    for (let i = base + 1; i < end; i++) {\r\n      glyphs[i].features.abvf = true;\r\n      glyphs[i].features.pstf = true;\r\n      glyphs[i].features.blwf = true;\r\n    }\r\n\r\n    if (plan.isOldSpec && plan.unicodeScript === 'Devanagari') {\r\n      // Old-spec eye-lash Ra needs special handling.  From the\r\n      // spec:\r\n      //\r\n      // \"The feature 'below-base form' is applied to consonants\r\n      // having below-base forms and following the base consonant.\r\n      // The exception is vattu, which may appear below half forms\r\n      // as well as below the base glyph. The feature 'below-base\r\n      // form' will be applied to all such occurrences of Ra as well.\"\r\n      //\r\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+0915\r\n      // with Sanskrit 2003 font.\r\n      //\r\n      // However, note that Ra,Halant,ZWJ is the correct way to\r\n      // request eyelash form of Ra, so we wouldbn't inhibit it\r\n      // in that sequence.\r\n      //\r\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\r\n      for (let i = start; i + 1 < base; i++) {\r\n        if (glyphs[i].shaperInfo.category === CATEGORIES.Ra &&\r\n          glyphs[i + 1].shaperInfo.category === CATEGORIES.H &&\r\n          (i + 1 === base || glyphs[i + 2].shaperInfo.category === CATEGORIES.ZWJ)\r\n        ) {\r\n          glyphs[i].features.blwf = true;\r\n          glyphs[i + 1].features.blwf = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    let prefLen = 2;\r\n    if (features.pref && base + prefLen < end) {\r\n      // Find a Halant,Ra sequence and mark it for pre-base reordering processing.\r\n      for (let i = base + 1; i + prefLen - 1 < end; i++) {\r\n        let g = [glyphs[i].copy(), glyphs[i + 1].copy()];\r\n        if (wouldSubstitute(g, 'pref')) {\r\n          for (let j = 0; j < prefLen; j++) {\r\n            glyphs[i++].features.pref = true;\r\n          }\r\n\r\n          // Mark the subsequent stuff with 'cfar'.  Used in Khmer.\r\n          // Read the feature spec.\r\n          // This allows distinguishing the following cases with MS Khmer fonts:\r\n          // U+1784,U+17D2,U+179A,U+17D2,U+1782\r\n          // U+1784,U+17D2,U+1782,U+17D2,U+179A\r\n          if (features.cfar) {\r\n            for (; i < end; i++) {\r\n              glyphs[i].features.cfar = true;\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Apply ZWJ/ZWNJ effects\r\n    for (let i = start + 1; i < end; i++) {\r\n      if (isJoiner(glyphs[i])) {\r\n        let nonJoiner = glyphs[i].shaperInfo.category === CATEGORIES.ZWNJ;\r\n        let j = i;\r\n\r\n        do {\r\n          j--;\r\n\r\n          // ZWJ/ZWNJ should disable CJCT.  They do that by simply\r\n          // being there, since we don't skip them for the CJCT\r\n          // feature (ie. F_MANUAL_ZWJ)\r\n\r\n          // A ZWNJ disables HALF.\r\n          if (nonJoiner) {\r\n            delete glyphs[j].features.half;\r\n          }\r\n        } while (j > start && !isConsonant(glyphs[j]));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finalReordering(font, glyphs, plan) {\r\n  let indicConfig = plan.indicConfig;\r\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\r\n\r\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\r\n    // 4. Final reordering:\r\n    //\r\n    // After the localized forms and basic shaping forms GSUB features have been\r\n    // applied (see below), the shaping engine performs some final glyph\r\n    // reordering before applying all the remaining font features to the entire\r\n    // cluster.\r\n\r\n    let tryPref = !!features.pref;\r\n\r\n    // Find base again\r\n    let base = start;\r\n    for (; base < end; base++) {\r\n      if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {\r\n        if (tryPref && base + 1 < end) {\r\n          for (let i = base + 1; i < end; i++) {\r\n            if (glyphs[i].features.pref) {\r\n              if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {\r\n                // Ok, this was a 'pref' candidate but didn't form any.\r\n                // Base is around here...\r\n                base = i;\r\n                while (base < end && isHalantOrCoeng(glyphs[base])) {\r\n                  base++;\r\n                }\r\n                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;\r\n                tryPref = false;\r\n              }\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // For Malayalam, skip over unformed below- (but NOT post-) forms.\r\n        if (plan.unicodeScript === 'Malayalam') {\r\n          for (let i = base + 1; i < end; i++) {\r\n            while (i < end && isJoiner(glyphs[i])) {\r\n              i++;\r\n            }\r\n\r\n            if (i === end || !isHalantOrCoeng(glyphs[i])) {\r\n              break;\r\n            }\r\n\r\n            i++; // Skip halant.\r\n            while (i < end && isJoiner(glyphs[i])) {\r\n              i++;\r\n            }\r\n\r\n            if (i < end && isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === POSITIONS.Below_C) {\r\n              base = i;\r\n              glyphs[base].shaperInfo.position = POSITIONS.Base_C;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {\r\n          base--;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {\r\n      base--;\r\n    }\r\n\r\n    if (base < end) {\r\n      while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {\r\n        base--;\r\n      }\r\n    }\r\n\r\n    // o Reorder matras:\r\n    //\r\n    // If a pre-base matra character had been reordered before applying basic\r\n    // features, the glyph can be moved closer to the main consonant based on\r\n    // whether half-forms had been formed. Actual position for the matra is\r\n    // defined as “after last standalone halant glyph, after initial matra\r\n    // position and before the main consonant”. If ZWJ or ZWNJ follow this\r\n    // halant, position is moved after it.\r\n    //\r\n\r\n    if (start + 1 < end && start < base) { // Otherwise there can't be any pre-base matra characters.\r\n      // If we lost track of base, alas, position before last thingy.\r\n      let newPos = base === end ? base - 2 : base - 1;\r\n\r\n      // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\r\n      // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\r\n      // We want to position matra after them.\r\n      if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\r\n        while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\r\n          newPos--;\r\n        }\r\n\r\n        // If we found no Halant we are done.\r\n        // Otherwise only proceed if the Halant does\r\n        // not belong to the Matra itself!\r\n        if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\r\n          // If ZWJ or ZWNJ follow this halant, position is moved after it.\r\n          if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {\r\n            newPos++;\r\n          }\r\n        } else {\r\n          newPos = start; // No move.\r\n        }\r\n      }\r\n\r\n      if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\r\n        // Now go see if there's actually any matras...\r\n        for (let i = newPos; i > start; i--) {\r\n          if (glyphs[i - 1].shaperInfo.position === POSITIONS.Pre_M) {\r\n            let oldPos = i - 1;\r\n            if (oldPos < base && base <= newPos) { // Shouldn't actually happen.\r\n              base--;\r\n            }\r\n\r\n            let tmp = glyphs[oldPos];\r\n            glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));\r\n            glyphs[newPos] = tmp;\r\n\r\n            newPos--;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // o Reorder reph:\r\n    //\r\n    // Reph’s original position is always at the beginning of the syllable,\r\n    // (i.e. it is not reordered at the character reordering stage). However,\r\n    // it will be reordered according to the basic-forms shaping results.\r\n    // Possible positions for reph, depending on the script, are; after main,\r\n    // before post-base consonant forms, and after post-base consonant forms.\r\n\r\n    // Two cases:\r\n    //\r\n    // - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\r\n    //   we should only move it if the sequence ligated to the repha form.\r\n    //\r\n    // - If repha is encoded separately and in the logical position, we should only\r\n    //   move it if it did NOT ligate.  If it ligated, it's probably the font trying\r\n    //   to make it work without the reordering.\r\n    if (start + 1 < end &&\r\n      glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph &&\r\n      (glyphs[start].shaperInfo.category === CATEGORIES.Repha) !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)\r\n    ) {\r\n      let newRephPos;\r\n      let rephPos = indicConfig.rephPos;\r\n      let found = false;\r\n\r\n      // 1. If reph should be positioned after post-base consonant forms,\r\n      //    proceed to step 5.\r\n      if (rephPos !== POSITIONS.After_Post) {\r\n        //  2. If the reph repositioning class is not after post-base: target\r\n        //     position is after the first explicit halant glyph between the\r\n        //     first post-reph consonant and last main consonant. If ZWJ or ZWNJ\r\n        //     are following this halant, position is moved after it. If such\r\n        //     position is found, this is the target position. Otherwise,\r\n        //     proceed to the next step.\r\n        //\r\n        //     Note: in old-implementation fonts, where classifications were\r\n        //     fixed in shaping engine, there was no case where reph position\r\n        //     will be found on this step.\r\n        newRephPos = start + 1;\r\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\r\n          newRephPos++;\r\n        }\r\n\r\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\r\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\r\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\r\n            newRephPos++;\r\n          }\r\n\r\n          found = true;\r\n        }\r\n\r\n        // 3. If reph should be repositioned after the main consonant: find the\r\n        //    first consonant not ligated with main, or find the first\r\n        //    consonant that is not a potential pre-base reordering Ra.\r\n        if (!found && rephPos === POSITIONS.After_Main) {\r\n          newRephPos = base;\r\n          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {\r\n            newRephPos++;\r\n          }\r\n\r\n          found = newRephPos < end;\r\n        }\r\n\r\n        // 4. If reph should be positioned before post-base consonant, find\r\n        //    first post-base classified consonant not ligated with main. If no\r\n        //    consonant is found, the target position should be before the\r\n        //    first matra, syllable modifier sign or vedic sign.\r\n        //\r\n        // This is our take on what step 4 is trying to say (and failing, BADLY).\r\n        if (!found && rephPos === POSITIONS.After_Sub) {\r\n          newRephPos = base;\r\n          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {\r\n            newRephPos++;\r\n          }\r\n\r\n          found = newRephPos < end;\r\n        }\r\n      }\r\n\r\n      //  5. If no consonant is found in steps 3 or 4, move reph to a position\r\n      //     immediately before the first post-base matra, syllable modifier\r\n      //     sign or vedic sign that has a reordering class after the intended\r\n      //     reph position. For example, if the reordering position for reph\r\n      //     is post-main, it will skip above-base matras that also have a\r\n      //     post-main position.\r\n      if (!found) {\r\n        // Copied from step 2.\r\n        newRephPos = start + 1;\r\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\r\n          newRephPos++;\r\n        }\r\n\r\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\r\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\r\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\r\n            newRephPos++;\r\n          }\r\n\r\n          found = true;\r\n        }\r\n      }\r\n\r\n      // 6. Otherwise, reorder reph to the end of the syllable.\r\n      if (!found) {\r\n        newRephPos = end - 1;\r\n        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {\r\n          newRephPos--;\r\n        }\r\n\r\n        // If the Reph is to be ending up after a Matra,Halant sequence,\r\n        // position it before that Halant so it can interact with the Matra.\r\n        // However, if it's a plain Consonant,Halant we shouldn't do that.\r\n        // Uniscribe doesn't do this.\r\n        // TEST: U+0930,U+094D,U+0915,U+094B,U+094D\r\n        if (isHalantOrCoeng(glyphs[newRephPos])) {\r\n          for (let i = base + 1; i < newRephPos; i++) {\r\n            if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\r\n              newRephPos--;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      let reph = glyphs[start];\r\n      glyphs.splice(start, 0, ...glyphs.splice(start + 1, newRephPos - start));\r\n      glyphs[newRephPos] = reph;\r\n\r\n      if (start < base && base <= newRephPos) {\r\n        base--;\r\n      }\r\n    }\r\n\r\n    // o Reorder pre-base reordering consonants:\r\n    //\r\n    // If a pre-base reordering consonant is found, reorder it according to\r\n    // the following rules:\r\n    if (tryPref && base + 1 < end) {\r\n      for (let i = base + 1; i < end; i++) {\r\n        if (glyphs[i].features.pref) {\r\n           // 1. Only reorder a glyph produced by substitution during application\r\n           //    of the <pref> feature. (Note that a font may shape a Ra consonant with\r\n           //    the feature generally but block it in certain contexts.)\r\n\r\n          // Note: We just check that something got substituted.  We don't check that\r\n          // the <pref> feature actually did it...\r\n          //\r\n          // Reorder pref only if it ligated.\r\n          if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {\r\n            // 2. Try to find a target position the same way as for pre-base matra.\r\n            //    If it is found, reorder pre-base consonant glyph.\r\n            //\r\n            // 3. If position is not found, reorder immediately before main\r\n            //    consonant.\r\n            let newPos = base;\r\n\r\n            // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\r\n            // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\r\n            // We want to position matra after them.\r\n            if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\r\n              while (newPos > start && !(glyphs[newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\r\n                newPos--;\r\n              }\r\n\r\n              // In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a\r\n              // split matra, it should be reordered to *before* the left part of such matra.\r\n              if (newPos > start && glyphs[newPos - 1].shaperInfo.category === CATEGORIES.M) {\r\n                let oldPos = i;\r\n                for (let j = base + 1; j < oldPos; j++) {\r\n                  if (glyphs[j].shaperInfo.category === CATEGORIES.M) {\r\n                    newPos--;\r\n                    break;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            if (newPos > start && isHalantOrCoeng(glyphs[newPos - 1])) {\r\n              // -> If ZWJ or ZWNJ follow this halant, position is moved after it.\r\n              if (newPos < end && isJoiner(glyphs[newPos])) {\r\n                newPos++;\r\n              }\r\n            }\r\n\r\n            let oldPos = i;\r\n            let tmp = glyphs[oldPos];\r\n            glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));\r\n            glyphs[newPos] = tmp;\r\n\r\n            if (newPos <= base && base < oldPos) {\r\n              base++;\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Apply 'init' to the Left Matra if it's a word start.\r\n    if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(unicode.getCategory(glyphs[start - 1].codePoints[0])))) {\r\n      glyphs[start].features.init = true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction nextSyllable(glyphs, start) {\r\n  if (start >= glyphs.length) return start;\r\n  let syllable = glyphs[start].shaperInfo.syllable;\r\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\r\n  return start;\r\n}\r\n","import DefaultShaper from './DefaultShaper';\r\nimport StateMachine from 'dfa';\r\nimport UnicodeTrie from 'unicode-trie';\r\nimport GlyphInfo from '../GlyphInfo';\r\nimport useData from './use.json';\r\n\r\nconst {categories, decompositions} = useData;\r\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/use.trie'));\r\nconst stateMachine = new StateMachine(useData);\r\n\r\n/**\r\n * This shaper is an implementation of the Universal Shaping Engine, which\r\n * uses Unicode data to shape a number of scripts without a dedicated shaping engine.\r\n * See https://www.microsoft.com/typography/OpenTypeDev/USE/intro.htm.\r\n */\r\nexport default class UniversalShaper extends DefaultShaper {\r\n  static zeroMarkWidths = 'BEFORE_GPOS';\r\n  static planFeatures(plan) {\r\n    plan.addStage(setupSyllables);\r\n\r\n    // Default glyph pre-processing group\r\n    plan.addStage(['locl', 'ccmp', 'nukt', 'akhn']);\r\n\r\n    // Reordering group\r\n    plan.addStage(clearSubstitutionFlags);\r\n    plan.addStage(['rphf'], false);\r\n    plan.addStage(recordRphf);\r\n    plan.addStage(clearSubstitutionFlags);\r\n    plan.addStage(['pref']);\r\n    plan.addStage(recordPref);\r\n\r\n    // Orthographic unit shaping group\r\n    plan.addStage(['rkrf', 'abvf', 'blwf', 'half', 'pstf', 'vatu', 'cjct']);\r\n    plan.addStage(reorder);\r\n\r\n    // Topographical features\r\n    // Scripts that need this are handled by the Arabic shaper, not implemented here for now.\r\n    // plan.addStage(['isol', 'init', 'medi', 'fina', 'med2', 'fin2', 'fin3'], false);\r\n\r\n    // Standard topographic presentation and positional feature application\r\n    plan.addStage(['abvs', 'blws', 'pres', 'psts', 'dist', 'abvm', 'blwm']);\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    // Decompose split vowels\r\n    // TODO: do this in a more general unicode normalizer\r\n    for (let i = glyphs.length - 1; i >= 0; i--) {\r\n      let codepoint = glyphs[i].codePoints[0];\r\n      if (decompositions[codepoint]) {\r\n        let decomposed = decompositions[codepoint].map(c => {\r\n          let g = plan.font.glyphForCodePoint(c);\r\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\r\n        });\r\n\r\n        glyphs.splice(i, 1, ...decomposed);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction useCategory(glyph) {\r\n  return trie.get(glyph.codePoints[0]);\r\n}\r\n\r\nclass USEInfo {\r\n  constructor(category, syllableType, syllable) {\r\n    this.category = category;\r\n    this.syllableType = syllableType;\r\n    this.syllable = syllable;\r\n  }\r\n}\r\n\r\nfunction setupSyllables(font, glyphs) {\r\n  let syllable = 0;\r\n  for (let [start, end, tags] of stateMachine.match(glyphs.map(useCategory))) {\r\n    ++syllable;\r\n\r\n    // Create shaper info\r\n    for (let i = start; i <= end; i++) {\r\n      glyphs[i].shaperInfo = new USEInfo(categories[useCategory(glyphs[i])], tags[0], syllable);\r\n    }\r\n\r\n    // Assign rphf feature\r\n    let limit = glyphs[start].shaperInfo.category === 'R' ? 1 : Math.min(3, end - start);\r\n    for (let i = start; i < start + limit; i++) {\r\n      glyphs[i].features.rphf = true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction clearSubstitutionFlags(font, glyphs) {\r\n  for (let glyph of glyphs) {\r\n    glyph.substituted = false;\r\n  }\r\n}\r\n\r\nfunction recordRphf(font, glyphs) {\r\n  for (let glyph of glyphs) {\r\n    if (glyph.substituted && glyph.features.rphf) {\r\n      // Mark a substituted repha.\r\n      glyph.shaperInfo.category = 'R';\r\n    }\r\n  }\r\n}\r\n\r\nfunction recordPref(font, glyphs) {\r\n  for (let glyph of glyphs) {\r\n    if (glyph.substituted) {\r\n      // Mark a substituted pref as VPre, as they behave the same way.\r\n      glyph.shaperInfo.category = 'VPre';\r\n    }\r\n  }\r\n}\r\n\r\nfunction reorder(font, glyphs) {\r\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\r\n\r\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\r\n    let i, j;\r\n    let info = glyphs[start].shaperInfo;\r\n    let type = info.syllableType;\r\n\r\n    // Only a few syllable types need reordering.\r\n    if (type !== 'virama_terminated_cluster' && type !== 'standard_cluster' && type !== 'broken_cluster') {\r\n      continue;\r\n    }\r\n\r\n    // Insert a dotted circle glyph in broken clusters.\r\n    if (type === 'broken_cluster' && dottedCircle) {\r\n      let g = new GlyphInfo(font, dottedCircle, [0x25cc]);\r\n      g.shaperInfo = info;\r\n\r\n      // Insert after possible Repha.\r\n      for (i = start; i < end && glyphs[i].shaperInfo.category === 'R'; i++);\r\n      glyphs.splice(++i, 0, g);\r\n      end++;\r\n    }\r\n\r\n    // Move things forward.\r\n    if (info.category === 'R' && end - start > 1) {\r\n      // Got a repha. Reorder it to after first base, before first halant.\r\n      for (i = start + 1; i < end; i++) {\r\n        info = glyphs[i].shaperInfo;\r\n        if (isBase(info) || isHalant(glyphs[i])) {\r\n          // If we hit a halant, move before it; otherwise it's a base: move to it's\r\n          // place, and shift things in between backward.\r\n          if (isHalant(glyphs[i])) {\r\n            i--;\r\n          }\r\n\r\n          glyphs.splice(start, 0, ...glyphs.splice(start + 1, i - start), glyphs[i]);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Move things back.\r\n    for (i = start, j = end; i < end; i++) {\r\n      info = glyphs[i].shaperInfo;\r\n      if (isBase(info) || isHalant(glyphs[i])) {\r\n        // If we hit a halant, move after it; otherwise it's a base: move to it's\r\n        // place, and shift things in between backward.\r\n        j = isHalant(glyphs[i]) ? i + 1 : i;\r\n      } else if ((info.category === 'VPre' || info.category === 'VMPre') && j < i) {\r\n        glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction nextSyllable(glyphs, start) {\r\n  if (start >= glyphs.length) return start;\r\n  let syllable = glyphs[start].shaperInfo.syllable;\r\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\r\n  return start;\r\n}\r\n\r\nfunction isHalant(glyph) {\r\n  return glyph.shaperInfo.category === 'H' && !glyph.isLigated;\r\n}\r\n\r\nfunction isBase(info) {\r\n  return info.category === 'B' || info.category === 'GB';\r\n}\r\n","import DefaultShaper from './DefaultShaper';\r\nimport ArabicShaper from './ArabicShaper';\r\nimport HangulShaper from './HangulShaper';\r\nimport IndicShaper from './IndicShaper';\r\nimport UniversalShaper from './UniversalShaper';\r\n\r\nconst SHAPERS = {\r\n  arab: ArabicShaper,    // Arabic\r\n  mong: ArabicShaper,    // Mongolian\r\n  syrc: ArabicShaper,    // Syriac\r\n  'nko ': ArabicShaper,  // N'Ko\r\n  phag: ArabicShaper,    // Phags Pa\r\n  mand: ArabicShaper,    // Mandaic\r\n  mani: ArabicShaper,    // Manichaean\r\n  phlp: ArabicShaper,    // Psalter Pahlavi\r\n\r\n  hang: HangulShaper,    // Hangul\r\n\r\n  bng2: IndicShaper,     // Bengali\r\n  beng: IndicShaper,     // Bengali\r\n  dev2: IndicShaper,     // Devanagari\r\n  deva: IndicShaper,     // Devanagari\r\n  gjr2: IndicShaper,     // Gujarati\r\n  gujr: IndicShaper,     // Gujarati\r\n  guru: IndicShaper,     // Gurmukhi\r\n  gur2: IndicShaper,     // Gurmukhi\r\n  knda: IndicShaper,     // Kannada\r\n  knd2: IndicShaper,     // Kannada\r\n  mlm2: IndicShaper,     // Malayalam\r\n  mlym: IndicShaper,     // Malayalam\r\n  ory2: IndicShaper,     // Oriya\r\n  orya: IndicShaper,     // Oriya\r\n  taml: IndicShaper,     // Tamil\r\n  tml2: IndicShaper,     // Tamil\r\n  telu: IndicShaper,     // Telugu\r\n  tel2: IndicShaper,     // Telugu\r\n  khmr: IndicShaper,     // Khmer\r\n\r\n  bali: UniversalShaper, // Balinese\r\n  batk: UniversalShaper, // Batak\r\n  brah: UniversalShaper, // Brahmi\r\n  bugi: UniversalShaper, // Buginese\r\n  buhd: UniversalShaper, // Buhid\r\n  cakm: UniversalShaper, // Chakma\r\n  cham: UniversalShaper, // Cham\r\n  dupl: UniversalShaper, // Duployan\r\n  egyp: UniversalShaper, // Egyptian Hieroglyphs\r\n  gran: UniversalShaper, // Grantha\r\n  hano: UniversalShaper, // Hanunoo\r\n  java: UniversalShaper, // Javanese\r\n  kthi: UniversalShaper, // Kaithi\r\n  kali: UniversalShaper, // Kayah Li\r\n  khar: UniversalShaper, // Kharoshthi\r\n  khoj: UniversalShaper, // Khojki\r\n  sind: UniversalShaper, // Khudawadi\r\n  lepc: UniversalShaper, // Lepcha\r\n  limb: UniversalShaper, // Limbu\r\n  mahj: UniversalShaper, // Mahajani\r\n  // mand: UniversalShaper, // Mandaic\r\n  // mani: UniversalShaper, // Manichaean\r\n  mtei: UniversalShaper, // Meitei Mayek\r\n  modi: UniversalShaper, // Modi\r\n  // mong: UniversalShaper, // Mongolian\r\n  // 'nko ': UniversalShaper, // N’Ko\r\n  hmng: UniversalShaper, // Pahawh Hmong\r\n  // phag: UniversalShaper, // Phags-pa\r\n  // phlp: UniversalShaper, // Psalter Pahlavi\r\n  rjng: UniversalShaper, // Rejang\r\n  saur: UniversalShaper, // Saurashtra\r\n  shrd: UniversalShaper, // Sharada\r\n  sidd: UniversalShaper, // Siddham\r\n  sinh: UniversalShaper, // Sinhala\r\n  sund: UniversalShaper, // Sundanese\r\n  sylo: UniversalShaper, // Syloti Nagri\r\n  tglg: UniversalShaper, // Tagalog\r\n  tagb: UniversalShaper, // Tagbanwa\r\n  tale: UniversalShaper, // Tai Le\r\n  lana: UniversalShaper, // Tai Tham\r\n  tavt: UniversalShaper, // Tai Viet\r\n  takr: UniversalShaper, // Takri\r\n  tibt: UniversalShaper, // Tibetan\r\n  tfng: UniversalShaper, // Tifinagh\r\n  tirh: UniversalShaper, // Tirhuta\r\n\r\n  latn: DefaultShaper,   // Latin\r\n  DFLT: DefaultShaper    // Default\r\n};\r\n\r\nexport function choose(script) {\r\n  if (!Array.isArray(script)) {\r\n    script = [script];\r\n  }\r\n\r\n  for (let s of script) {\r\n    let shaper = SHAPERS[s];\r\n    if (shaper) {\r\n      return shaper;\r\n    }\r\n  }\r\n\r\n  return DefaultShaper;\r\n}\r\n","import OTProcessor from './OTProcessor';\r\nimport GlyphInfo from './GlyphInfo';\r\n\r\nexport default class GSUBProcessor extends OTProcessor {\r\n  applyLookup(lookupType, table) {\r\n    switch (lookupType) {\r\n      case 1: { // Single Substitution\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        let glyph = this.glyphIterator.cur;\r\n        switch (table.version) {\r\n          case 1:\r\n            glyph.id = (glyph.id + table.deltaGlyphID) & 0xffff;\r\n            break;\r\n\r\n          case 2:\r\n            glyph.id = table.substitute.get(index);\r\n            break;\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case 2: { // Multiple Substitution\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index !== -1) {\r\n          let sequence = table.sequences.get(index);\r\n\r\n          if (sequence.length === 0) {\r\n            // If the sequence length is zero, delete the glyph.\r\n            // The OpenType spec disallows this, but seems like Harfbuzz and Uniscribe allow it.\r\n            this.glyphs.splice(this.glyphIterator.index, 1);\r\n            return true;\r\n          }\r\n\r\n          this.glyphIterator.cur.id = sequence[0];\r\n          this.glyphIterator.cur.ligatureComponent = 0;\r\n\r\n          let features = this.glyphIterator.cur.features;\r\n          let curGlyph = this.glyphIterator.cur;\r\n          let replacement = sequence.slice(1).map((gid, i) => {\r\n            let glyph = new GlyphInfo(this.font, gid, undefined, features);\r\n            glyph.shaperInfo = curGlyph.shaperInfo;\r\n            glyph.isLigated = curGlyph.isLigated;\r\n            glyph.ligatureComponent = i + 1;\r\n            glyph.substituted = true;\r\n            glyph.isMultiplied = true;\r\n            return glyph;\r\n          });\r\n\r\n          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      case 3: { // Alternate Substitution\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index !== -1) {\r\n          let USER_INDEX = 0; // TODO\r\n          this.glyphIterator.cur.id = table.alternateSet.get(index)[USER_INDEX];\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      case 4: { // Ligature Substitution\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        for (let ligature of table.ligatureSets.get(index)) {\r\n          let matched = this.sequenceMatchIndices(1, ligature.components);\r\n          if (!matched) {\r\n            continue;\r\n          }\r\n\r\n          let curGlyph = this.glyphIterator.cur;\r\n\r\n          // Concatenate all of the characters the new ligature will represent\r\n          let characters = curGlyph.codePoints.slice();\r\n          for (let index of matched) {\r\n            characters.push(...this.glyphs[index].codePoints);\r\n          }\r\n\r\n          // Create the replacement ligature glyph\r\n          let ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, curGlyph.features);\r\n          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;\r\n          ligatureGlyph.isLigated = true;\r\n          ligatureGlyph.substituted = true;\r\n\r\n          // From Harfbuzz:\r\n          // - If it *is* a mark ligature, we don't allocate a new ligature id, and leave\r\n          //   the ligature to keep its old ligature id.  This will allow it to attach to\r\n          //   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\r\n          //   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA with a\r\n          //   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\r\n          //   later, we don't want them to lose their ligature id/component, otherwise\r\n          //   GPOS will fail to correctly position the mark ligature on top of the\r\n          //   LAM,LAM,HEH ligature. See https://bugzilla.gnome.org/show_bug.cgi?id=676343\r\n          //\r\n          // - If a ligature is formed of components that some of which are also ligatures\r\n          //   themselves, and those ligature components had marks attached to *their*\r\n          //   components, we have to attach the marks to the new ligature component\r\n          //   positions!  Now *that*'s tricky!  And these marks may be following the\r\n          //   last component of the whole sequence, so we should loop forward looking\r\n          //   for them and update them.\r\n          //\r\n          //   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\r\n          //   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\r\n          //   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\r\n          //   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\r\n          //   the new ligature with a component value of 2.\r\n          //\r\n          //   This in fact happened to a font...  See https://bugzilla.gnome.org/show_bug.cgi?id=437633\r\n          let isMarkLigature = curGlyph.isMark;\r\n          for (let i = 0; i < matched.length && isMarkLigature; i++) {\r\n            isMarkLigature = this.glyphs[matched[i]].isMark;\r\n          }\r\n\r\n          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;\r\n\r\n          let lastLigID = curGlyph.ligatureID;\r\n          let lastNumComps = curGlyph.codePoints.length;\r\n          let curComps = lastNumComps;\r\n          let idx = this.glyphIterator.index + 1;\r\n\r\n          // Set ligatureID and ligatureComponent on glyphs that were skipped in the matched sequence.\r\n          // This allows GPOS to attach marks to the correct ligature components.\r\n          for (let matchIndex of matched) {\r\n            // Don't assign new ligature components for mark ligatures (see above)\r\n            if (isMarkLigature) {\r\n              idx = matchIndex;\r\n            } else {\r\n              while (idx < matchIndex) {\r\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);\r\n                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;\r\n                this.glyphs[idx].ligatureComponent = ligatureComponent;\r\n                idx++;\r\n              }\r\n            }\r\n\r\n            lastLigID = this.glyphs[idx].ligatureID;\r\n            lastNumComps = this.glyphs[idx].codePoints.length;\r\n            curComps += lastNumComps;\r\n            idx++; // skip base glyph\r\n          }\r\n\r\n          // Adjust ligature components for any marks following\r\n          if (lastLigID && !isMarkLigature) {\r\n            for (let i = idx; i < this.glyphs.length; i++) {\r\n              if (this.glyphs[i].ligatureID === lastLigID) {\r\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i].ligatureComponent || 1, lastNumComps);\r\n                this.glyphs[i].ligatureComponent = ligatureComponent;\r\n              } else {\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Delete the matched glyphs, and replace the current glyph with the ligature glyph\r\n          for (let i = matched.length - 1; i >= 0; i--) {\r\n            this.glyphs.splice(matched[i], 1);\r\n          }\r\n\r\n          this.glyphs[this.glyphIterator.index] = ligatureGlyph;\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      case 5: // Contextual Substitution\r\n        return this.applyContext(table);\r\n\r\n      case 6: // Chaining Contextual Substitution\r\n        return this.applyChainingContext(table);\r\n\r\n      case 7: // Extension Substitution\r\n        return this.applyLookup(table.lookupType, table.extension);\r\n\r\n      default:\r\n        throw new Error(`GSUB lookupType ${lookupType} is not supported`);\r\n    }\r\n  }\r\n}\r\n","import OTProcessor from './OTProcessor';\r\n\r\nexport default class GPOSProcessor extends OTProcessor {\r\n  applyPositionValue(sequenceIndex, value) {\r\n    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];\r\n    if (value.xAdvance != null) {\r\n      position.xAdvance += value.xAdvance;\r\n    }\r\n\r\n    if (value.yAdvance != null) {\r\n      position.yAdvance += value.yAdvance;\r\n    }\r\n\r\n    if (value.xPlacement != null) {\r\n      position.xOffset += value.xPlacement;\r\n    }\r\n\r\n    if (value.yPlacement != null) {\r\n      position.yOffset += value.yPlacement;\r\n    }\r\n\r\n    // Adjustments for font variations\r\n    let variationProcessor = this.font._variationProcessor;\r\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\r\n    if (variationProcessor && variationStore) {\r\n      if (value.xPlaDevice) {\r\n        position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);\r\n      }\r\n\r\n      if (value.yPlaDevice) {\r\n        position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);\r\n      }\r\n\r\n      if (value.xAdvDevice) {\r\n        position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);\r\n      }\r\n\r\n      if (value.yAdvDevice) {\r\n        position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);\r\n      }\r\n    }\r\n\r\n    // TODO: device tables\r\n  }\r\n\r\n  applyLookup(lookupType, table) {\r\n    switch (lookupType) {\r\n      case 1: { // Single positioning value\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        switch (table.version) {\r\n          case 1:\r\n            this.applyPositionValue(0, table.value);\r\n            break;\r\n\r\n          case 2:\r\n            this.applyPositionValue(0, table.values.get(index));\r\n            break;\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case 2: { // Pair Adjustment Positioning\r\n        let nextGlyph = this.glyphIterator.peek();\r\n        if (!nextGlyph) {\r\n          return false;\r\n        }\r\n\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        switch (table.version) {\r\n          case 1: // Adjustments for glyph pairs\r\n            let set = table.pairSets.get(index);\r\n\r\n            for (let pair of set) {\r\n              if (pair.secondGlyph === nextGlyph.id) {\r\n                this.applyPositionValue(0, pair.value1);\r\n                this.applyPositionValue(1, pair.value2);\r\n                return true;\r\n              }\r\n            }\r\n\r\n            return false;\r\n\r\n          case 2: // Class pair adjustment\r\n            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);\r\n            let class2 = this.getClassID(nextGlyph.id, table.classDef2);\r\n            if (class1 === -1 || class2 === -1) {\r\n              return false;\r\n            }\r\n\r\n            var pair = table.classRecords.get(class1).get(class2);\r\n            this.applyPositionValue(0, pair.value1);\r\n            this.applyPositionValue(1, pair.value2);\r\n            return true;\r\n        }\r\n      }\r\n\r\n      case 3: { // Cursive Attachment Positioning\r\n        let nextIndex = this.glyphIterator.peekIndex();\r\n        let nextGlyph = this.glyphs[nextIndex];\r\n        if (!nextGlyph) {\r\n          return false;\r\n        }\r\n\r\n        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];\r\n        if (!curRecord || !curRecord.exitAnchor) {\r\n          return false;\r\n        }\r\n\r\n        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];\r\n        if (!nextRecord || !nextRecord.entryAnchor) {\r\n          return false;\r\n        }\r\n\r\n        let entry = this.getAnchor(nextRecord.entryAnchor);\r\n        let exit = this.getAnchor(curRecord.exitAnchor);\r\n\r\n        let cur = this.positions[this.glyphIterator.index];\r\n        let next = this.positions[nextIndex];\r\n\r\n        switch (this.direction) {\r\n          case 'ltr':\r\n            cur.xAdvance = exit.x + cur.xOffset;\r\n\r\n            let d = entry.x + next.xOffset;\r\n            next.xAdvance -= d;\r\n            next.xOffset -= d;\r\n            break;\r\n\r\n          case 'rtl':\r\n            d = exit.x + cur.xOffset;\r\n            cur.xAdvance -= d;\r\n            cur.xOffset -= d;\r\n            next.xAdvance = entry.x + next.xOffset;\r\n            break;\r\n        }\r\n\r\n        if (this.glyphIterator.flags.rightToLeft) {\r\n          this.glyphIterator.cur.cursiveAttachment = nextIndex;\r\n          cur.yOffset = entry.y - exit.y;\r\n        } else {\r\n          nextGlyph.cursiveAttachment = this.glyphIterator.index;\r\n          cur.yOffset = exit.y - entry.y;\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case 4: { // Mark to base positioning\r\n        let markIndex = this.coverageIndex(table.markCoverage);\r\n        if (markIndex === -1) {\r\n          return false;\r\n        }\r\n\r\n        // search backward for a base glyph\r\n        let baseGlyphIndex = this.glyphIterator.index;\r\n        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0));\r\n\r\n        if (baseGlyphIndex < 0) {\r\n          return false;\r\n        }\r\n\r\n        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);\r\n        if (baseIndex === -1) {\r\n          return false;\r\n        }\r\n\r\n        let markRecord = table.markArray[markIndex];\r\n        let baseAnchor = table.baseArray[baseIndex][markRecord.class];\r\n        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\r\n        return true;\r\n      }\r\n\r\n      case 5: { // Mark to ligature positioning\r\n        let markIndex = this.coverageIndex(table.markCoverage);\r\n        if (markIndex === -1) {\r\n          return false;\r\n        }\r\n\r\n        // search backward for a base glyph\r\n        let baseGlyphIndex = this.glyphIterator.index;\r\n        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark);\r\n\r\n        if (baseGlyphIndex < 0) {\r\n          return false;\r\n        }\r\n\r\n        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);\r\n        if (ligIndex === -1) {\r\n          return false;\r\n        }\r\n\r\n        let ligAttach = table.ligatureArray[ligIndex];\r\n        let markGlyph = this.glyphIterator.cur;\r\n        let ligGlyph = this.glyphs[baseGlyphIndex];\r\n        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && (markGlyph.ligatureComponent > 0)\r\n          ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1\r\n          : ligGlyph.codePoints.length - 1;\r\n\r\n        let markRecord = table.markArray[markIndex];\r\n        let baseAnchor = ligAttach[compIndex][markRecord.class];\r\n        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\r\n        return true;\r\n      }\r\n\r\n      case 6: { // Mark to mark positioning\r\n        let mark1Index = this.coverageIndex(table.mark1Coverage);\r\n        if (mark1Index === -1) {\r\n          return false;\r\n        }\r\n\r\n        // get the previous mark to attach to\r\n        let prevIndex = this.glyphIterator.peekIndex(-1);\r\n        let prev = this.glyphs[prevIndex];\r\n        if (!prev || !prev.isMark) {\r\n          return false;\r\n        }\r\n\r\n        let cur = this.glyphIterator.cur;\r\n\r\n        // The following logic was borrowed from Harfbuzz\r\n        let good = false;\r\n        if (cur.ligatureID === prev.ligatureID) {\r\n          if (!cur.ligatureID) { // Marks belonging to the same base\r\n            good = true;\r\n          } else if (cur.ligatureComponent === prev.ligatureComponent) { // Marks belonging to the same ligature component\r\n            good = true;\r\n          }\r\n        } else {\r\n          // If ligature ids don't match, it may be the case that one of the marks\r\n          // itself is a ligature, in which case match.\r\n          if ((cur.ligatureID && !cur.ligatureComponent) || (prev.ligatureID && !prev.ligatureComponent)) {\r\n            good = true;\r\n          }\r\n        }\r\n\r\n        if (!good) {\r\n          return false;\r\n        }\r\n\r\n        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);\r\n        if (mark2Index === -1) {\r\n          return false;\r\n        }\r\n\r\n        let markRecord = table.mark1Array[mark1Index];\r\n        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];\r\n        this.applyAnchor(markRecord, baseAnchor, prevIndex);\r\n        return true;\r\n      }\r\n\r\n      case 7: // Contextual positioning\r\n        return this.applyContext(table);\r\n\r\n      case 8: // Chaining contextual positioning\r\n        return this.applyChainingContext(table);\r\n\r\n      case 9: // Extension positioning\r\n        return this.applyLookup(table.lookupType, table.extension);\r\n\r\n      default:\r\n        throw new Error(`Unsupported GPOS table: ${lookupType}`);\r\n    }\r\n  }\r\n\r\n  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {\r\n    let baseCoords = this.getAnchor(baseAnchor);\r\n    let markCoords = this.getAnchor(markRecord.markAnchor);\r\n\r\n    let basePos = this.positions[baseGlyphIndex];\r\n    let markPos = this.positions[this.glyphIterator.index];\r\n\r\n    markPos.xOffset = baseCoords.x - markCoords.x;\r\n    markPos.yOffset = baseCoords.y - markCoords.y;\r\n    this.glyphIterator.cur.markAttachment = baseGlyphIndex;\r\n  }\r\n\r\n  getAnchor(anchor) {\r\n    // TODO: contour point, device tables\r\n    let x = anchor.xCoordinate;\r\n    let y = anchor.yCoordinate;\r\n\r\n    // Adjustments for font variations\r\n    let variationProcessor = this.font._variationProcessor;\r\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\r\n    if (variationProcessor && variationStore) {\r\n      if (anchor.xDeviceTable) {\r\n        x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);\r\n      }\r\n\r\n      if (anchor.yDeviceTable) {\r\n        y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);\r\n      }\r\n    }\r\n\r\n    return {x, y};\r\n  }\r\n\r\n  applyFeatures(userFeatures, glyphs, advances) {\r\n    super.applyFeatures(userFeatures, glyphs, advances);\r\n\r\n    for (var i = 0; i < this.glyphs.length; i++) {\r\n      this.fixCursiveAttachment(i);\r\n    }\r\n\r\n    this.fixMarkAttachment();\r\n  }\r\n\r\n  fixCursiveAttachment(i) {\r\n    let glyph = this.glyphs[i];\r\n    if (glyph.cursiveAttachment != null) {\r\n      let j = glyph.cursiveAttachment;\r\n\r\n      glyph.cursiveAttachment = null;\r\n      this.fixCursiveAttachment(j);\r\n\r\n      this.positions[i].yOffset += this.positions[j].yOffset;\r\n    }\r\n  }\r\n\r\n  fixMarkAttachment() {\r\n    for (let i = 0; i < this.glyphs.length; i++) {\r\n      let glyph = this.glyphs[i];\r\n      if (glyph.markAttachment != null) {\r\n        let j = glyph.markAttachment;\r\n\r\n        this.positions[i].xOffset += this.positions[j].xOffset;\r\n        this.positions[i].yOffset += this.positions[j].yOffset;\r\n\r\n        if (this.direction === 'ltr') {\r\n          for (let k = j; k < i; k++) {\r\n            this.positions[i].xOffset -= this.positions[k].xAdvance;\r\n            this.positions[i].yOffset -= this.positions[k].yAdvance;\r\n          }\r\n        } else {\r\n          for (let k = j + 1; k < i + 1; k++) {\r\n            this.positions[i].xOffset += this.positions[k].xAdvance;\r\n            this.positions[i].yOffset += this.positions[k].yAdvance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import ShapingPlan from './ShapingPlan';\r\nimport * as Shapers from './shapers';\r\nimport GlyphInfo from './GlyphInfo';\r\nimport GSUBProcessor from './GSUBProcessor';\r\nimport GPOSProcessor from './GPOSProcessor';\r\n\r\nexport default class OTLayoutEngine {\r\n  constructor(font) {\r\n    this.font = font;\r\n    this.glyphInfos = null;\r\n    this.plan = null;\r\n    this.GSUBProcessor = null;\r\n    this.GPOSProcessor = null;\r\n    this.fallbackPosition = true;\r\n\r\n    if (font.GSUB) {\r\n      this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);\r\n    }\r\n\r\n    if (font.GPOS) {\r\n      this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);\r\n    }\r\n  }\r\n\r\n  setup(glyphRun) {\r\n    // Map glyphs to GlyphInfo objects so data can be passed between\r\n    // GSUB and GPOS without mutating the real (shared) Glyph objects.\r\n    this.glyphInfos = glyphRun.glyphs.map(glyph => new GlyphInfo(this.font, glyph.id, [...glyph.codePoints]));\r\n\r\n    // Select a script based on what is available in GSUB/GPOS.\r\n    let script = null;\r\n    if (this.GPOSProcessor) {\r\n      script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\r\n    }\r\n\r\n    if (this.GSUBProcessor) {\r\n      script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\r\n    }\r\n\r\n    // Choose a shaper based on the script, and setup a shaping plan.\r\n    // This determines which features to apply to which glyphs.\r\n    this.shaper = Shapers.choose(script);\r\n    this.plan = new ShapingPlan(this.font, script, glyphRun.direction);\r\n    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);\r\n\r\n    // Assign chosen features to output glyph run\r\n    for (let key in this.plan.allFeatures) {\r\n      glyphRun.features[key] = true;\r\n    }\r\n  }\r\n\r\n  substitute(glyphRun) {\r\n    if (this.GSUBProcessor) {\r\n      this.plan.process(this.GSUBProcessor, this.glyphInfos);\r\n\r\n      // Map glyph infos back to normal Glyph objects\r\n      glyphRun.glyphs = this.glyphInfos.map(glyphInfo => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));\r\n    }\r\n  }\r\n\r\n  position(glyphRun) {\r\n    if (this.shaper.zeroMarkWidths === 'BEFORE_GPOS') {\r\n      this.zeroMarkAdvances(glyphRun.positions);\r\n    }\r\n\r\n    if (this.GPOSProcessor) {\r\n      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);\r\n    }\r\n\r\n    if (this.shaper.zeroMarkWidths === 'AFTER_GPOS') {\r\n      this.zeroMarkAdvances(glyphRun.positions);\r\n    }\r\n\r\n    // Reverse the glyphs and positions if the script is right-to-left\r\n    if (glyphRun.direction === 'rtl') {\r\n      glyphRun.glyphs.reverse();\r\n      glyphRun.positions.reverse();\r\n    }\r\n\r\n    return this.GPOSProcessor && this.GPOSProcessor.features;\r\n  }\r\n\r\n  zeroMarkAdvances(positions) {\r\n    for (let i = 0; i < this.glyphInfos.length; i++) {\r\n      if (this.glyphInfos[i].isMark) {\r\n        positions[i].xAdvance = 0;\r\n        positions[i].yAdvance = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  cleanup() {\r\n    this.glyphInfos = null;\r\n    this.plan = null;\r\n    this.shaper = null;\r\n  }\r\n\r\n  getAvailableFeatures(script, language) {\r\n    let features = [];\r\n\r\n    if (this.GSUBProcessor) {\r\n      this.GSUBProcessor.selectScript(script, language);\r\n      features.push(...Object.keys(this.GSUBProcessor.features));\r\n    }\r\n\r\n    if (this.GPOSProcessor) {\r\n      this.GPOSProcessor.selectScript(script, language);\r\n      features.push(...Object.keys(this.GPOSProcessor.features));\r\n    }\r\n\r\n    return features;\r\n  }\r\n}\r\n","import KernProcessor from './KernProcessor';\r\nimport UnicodeLayoutEngine from './UnicodeLayoutEngine';\r\nimport GlyphRun from './GlyphRun';\r\nimport GlyphPosition from './GlyphPosition';\r\nimport * as Script from './Script';\r\nimport unicode from 'unicode-properties';\r\nimport AATLayoutEngine from '../aat/AATLayoutEngine';\r\nimport OTLayoutEngine from '../opentype/OTLayoutEngine';\r\n\r\nexport default class LayoutEngine {\r\n  constructor(font) {\r\n    this.font = font;\r\n    this.unicodeLayoutEngine = null;\r\n    this.kernProcessor = null;\r\n\r\n    // Choose an advanced layout engine. We try the AAT morx table first since more\r\n    // scripts are currently supported because the shaping logic is built into the font.\r\n    if (this.font.morx) {\r\n      this.engine = new AATLayoutEngine(this.font);\r\n\r\n    } else if (this.font.GSUB || this.font.GPOS) {\r\n      this.engine = new OTLayoutEngine(this.font);\r\n    }\r\n  }\r\n\r\n  layout(string, features, script, language, direction) {\r\n    // Make the features parameter optional\r\n    if (typeof features === 'string') {\r\n      direction = language;\r\n      language = script;\r\n      script = features;\r\n      features = [];\r\n    }\r\n\r\n    // Map string to glyphs if needed\r\n    if (typeof string === 'string') {\r\n      // Attempt to detect the script from the string if not provided.\r\n      if (script == null) {\r\n        script = Script.forString(string);\r\n      }\r\n\r\n      var glyphs = this.font.glyphsForString(string);\r\n    } else {\r\n      // Attempt to detect the script from the glyph code points if not provided.\r\n      if (script == null) {\r\n        let codePoints = [];\r\n        for (let glyph of string) {\r\n          codePoints.push(...glyph.codePoints);\r\n        }\r\n\r\n        script = Script.forCodePoints(codePoints);\r\n      }\r\n\r\n      var glyphs = string;\r\n    }\r\n\r\n    let glyphRun = new GlyphRun(glyphs, features, script, language, direction);\r\n\r\n    // Return early if there are no glyphs\r\n    if (glyphs.length === 0) {\r\n      glyphRun.positions = [];\r\n      return glyphRun;\r\n    }\r\n\r\n    // Setup the advanced layout engine\r\n    if (this.engine && this.engine.setup) {\r\n      this.engine.setup(glyphRun);\r\n    }\r\n\r\n    // Substitute and position the glyphs\r\n    this.substitute(glyphRun);\r\n    this.position(glyphRun);\r\n\r\n    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);\r\n\r\n    // Let the layout engine clean up any state it might have\r\n    if (this.engine && this.engine.cleanup) {\r\n      this.engine.cleanup();\r\n    }\r\n\r\n    return glyphRun;\r\n  }\r\n\r\n  substitute(glyphRun) {\r\n    // Call the advanced layout engine to make substitutions\r\n    if (this.engine && this.engine.substitute) {\r\n      this.engine.substitute(glyphRun);\r\n    }\r\n  }\r\n\r\n  position(glyphRun) {\r\n    // Get initial glyph positions\r\n    glyphRun.positions = glyphRun.glyphs.map(glyph => new GlyphPosition(glyph.advanceWidth));\r\n    let positioned = null;\r\n\r\n    // Call the advanced layout engine. Returns the features applied.\r\n    if (this.engine && this.engine.position) {\r\n      positioned = this.engine.position(glyphRun);\r\n    }\r\n\r\n    // if there is no GPOS table, use unicode properties to position marks.\r\n    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {\r\n      if (!this.unicodeLayoutEngine) {\r\n        this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);\r\n      }\r\n\r\n      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);\r\n    }\r\n\r\n    // if kerning is not supported by GPOS, do kerning with the TrueType/AAT kern table\r\n    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {\r\n      if (!this.kernProcessor) {\r\n        this.kernProcessor = new KernProcessor(this.font);\r\n      }\r\n\r\n      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);\r\n      glyphRun.features.kern = true;\r\n    }\r\n  }\r\n\r\n  hideDefaultIgnorables(glyphs, positions) {\r\n    let space = this.font.glyphForCodePoint(0x20);\r\n    for (let i = 0; i < glyphs.length; i++) {\r\n      if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {\r\n        glyphs[i] = space;\r\n        positions[i].xAdvance = 0;\r\n        positions[i].yAdvance = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  isDefaultIgnorable(ch) {\r\n    // From DerivedCoreProperties.txt in the Unicode database,\r\n    // minus U+115F, U+1160, U+3164 and U+FFA0, which is what\r\n    // Harfbuzz and Uniscribe do.\r\n    let plane = ch >> 16;\r\n    if (plane === 0) {\r\n      // BMP\r\n      switch (ch >> 8) {\r\n      \tcase 0x00: return ch === 0x00AD;\r\n      \tcase 0x03: return ch === 0x034F;\r\n      \tcase 0x06: return ch === 0x061C;\r\n      \tcase 0x17: return 0x17B4 <= ch && ch <= 0x17B5;\r\n      \tcase 0x18: return 0x180B <= ch && ch <= 0x180E;\r\n      \tcase 0x20: return (0x200B <= ch && ch <= 0x200F) || (0x202A <= ch && ch <= 0x202E) || (0x2060 <= ch && ch <= 0x206F);\r\n      \tcase 0xFE: return (0xFE00 <= ch && ch <= 0xFE0F) || ch === 0xFEFF;\r\n      \tcase 0xFF: return 0xFFF0 <= ch && ch <= 0xFFF8;\r\n      \tdefault:   return false;\r\n      }\r\n    } else {\r\n      // Other planes\r\n      switch (plane) {\r\n      \tcase 0x01: return (0x1BCA0 <= ch && ch <= 0x1BCA3) || (0x1D173 <= ch && ch <= 0x1D17A);\r\n      \tcase 0x0E: return 0xE0000 <= ch && ch <= 0xE0FFF;\r\n      \tdefault:   return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  getAvailableFeatures(script, language) {\r\n    let features = [];\r\n\r\n    if (this.engine) {\r\n      features.push(...this.engine.getAvailableFeatures(script, language));\r\n    }\r\n\r\n    if (this.font.kern && features.indexOf('kern') === -1) {\r\n      features.push('kern');\r\n    }\r\n\r\n    return features;\r\n  }\r\n\r\n  stringsForGlyph(gid) {\r\n    let result = new Set;\r\n\r\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);\r\n    for (let codePoint of codePoints) {\r\n      result.add(String.fromCodePoint(codePoint));\r\n    }\r\n\r\n    if (this.engine && this.engine.stringsForGlyph) {\r\n      for (let string of this.engine.stringsForGlyph(gid)) {\r\n        result.add(string);\r\n      }\r\n    }\r\n\r\n    return Array.from(result);\r\n  }\r\n}\r\n","import BBox from './BBox';\r\n\r\nconst SVG_COMMANDS = {\r\n  moveTo: 'M',\r\n  lineTo: 'L',\r\n  quadraticCurveTo: 'Q',\r\n  bezierCurveTo: 'C',\r\n  closePath: 'Z'\r\n};\r\n\r\n/**\r\n * Path objects are returned by glyphs and represent the actual\r\n * vector outlines for each glyph in the font. Paths can be converted\r\n * to SVG path data strings, or to functions that can be applied to\r\n * render the path to a graphics context.\r\n */\r\nexport default class Path {\r\n  constructor() {\r\n    this.commands = [];\r\n    this._bbox = null;\r\n    this._cbox = null;\r\n  }\r\n\r\n  /**\r\n   * Compiles the path to a JavaScript function that can be applied with\r\n   * a graphics context in order to render the path.\r\n   * @return {string}\r\n   */\r\n  toFunction() {\r\n    return ctx => {\r\n      this.commands.forEach(c => {\r\n        return ctx[c.command].apply(ctx, c.args)\r\n      })\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Converts the path to an SVG path data string\r\n   * @return {string}\r\n   */\r\n  toSVG() {\r\n    let cmds = this.commands.map(c => {\r\n      let args = c.args.map(arg => Math.round(arg * 100) / 100);\r\n      return `${SVG_COMMANDS[c.command]}${args.join(' ')}`;\r\n    });\r\n\r\n    return cmds.join('');\r\n  }\r\n\r\n  /**\r\n   * Gets the \"control box\" of a path.\r\n   * This is like the bounding box, but it includes all points including\r\n   * control points of bezier segments and is much faster to compute than\r\n   * the real bounding box.\r\n   * @type {BBox}\r\n   */\r\n  get cbox() {\r\n    if (!this._cbox) {\r\n      let cbox = new BBox;\r\n      for (let command of this.commands) {\r\n        for (let i = 0; i < command.args.length; i += 2) {\r\n          cbox.addPoint(command.args[i], command.args[i + 1]);\r\n        }\r\n      }\r\n\r\n      this._cbox = Object.freeze(cbox);\r\n    }\r\n\r\n    return this._cbox;\r\n  }\r\n\r\n  /**\r\n   * Gets the exact bounding box of the path by evaluating curve segments.\r\n   * Slower to compute than the control box, but more accurate.\r\n   * @type {BBox}\r\n   */\r\n  get bbox() {\r\n    if (this._bbox) {\r\n      return this._bbox;\r\n    }\r\n\r\n    let bbox = new BBox;\r\n    let cx = 0, cy = 0;\r\n\r\n    let f = t => (\r\n      Math.pow(1 - t, 3) * p0[i]\r\n        + 3 * Math.pow(1 - t, 2) * t * p1[i]\r\n        + 3 * (1 - t) * Math.pow(t, 2) * p2[i]\r\n        + Math.pow(t, 3) * p3[i]\r\n    );\r\n\r\n    for (let c of this.commands) {\r\n      switch (c.command) {\r\n        case 'moveTo':\r\n        case 'lineTo':\r\n          let [x, y] = c.args;\r\n          bbox.addPoint(x, y);\r\n          cx = x;\r\n          cy = y;\r\n          break;\r\n\r\n        case 'quadraticCurveTo':\r\n        case 'bezierCurveTo':\r\n          if (c.command === 'quadraticCurveTo') {\r\n            // http://fontforge.org/bezier.html\r\n            var [qp1x, qp1y, p3x, p3y] = c.args;\r\n            var cp1x = cx + 2 / 3 * (qp1x - cx);    // CP1 = QP0 + 2/3 * (QP1-QP0)\r\n            var cp1y = cy + 2 / 3 * (qp1y - cy);\r\n            var cp2x = p3x + 2 / 3 * (qp1x - p3x);  // CP2 = QP2 + 2/3 * (QP1-QP2)\r\n            var cp2y = p3y + 2 / 3 * (qp1y - p3y);\r\n          } else {\r\n            var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c.args;\r\n          }\r\n\r\n          // http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\r\n          bbox.addPoint(p3x, p3y);\r\n\r\n          var p0 = [cx, cy];\r\n          var p1 = [cp1x, cp1y];\r\n          var p2 = [cp2x, cp2y];\r\n          var p3 = [p3x, p3y];\r\n\r\n          for (var i = 0; i <= 1; i++) {\r\n            let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\r\n            let a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\r\n            c = 3 * p1[i] - 3 * p0[i];\r\n\r\n            if (a === 0) {\r\n              if (b === 0) {\r\n                continue;\r\n              }\r\n\r\n              let t = -c / b;\r\n              if (0 < t && t < 1) {\r\n                if (i === 0) {\r\n                  bbox.addPoint(f(t), bbox.maxY);\r\n                } else if (i === 1) {\r\n                  bbox.addPoint(bbox.maxX, f(t));\r\n                }\r\n              }\r\n\r\n              continue;\r\n            }\r\n\r\n            let b2ac = Math.pow(b, 2) - 4 * c * a;\r\n            if (b2ac < 0) {\r\n              continue;\r\n            }\r\n\r\n            let t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\r\n            if (0 < t1 && t1 < 1) {\r\n              if (i === 0) {\r\n                bbox.addPoint(f(t1), bbox.maxY);\r\n              } else if (i === 1) {\r\n                bbox.addPoint(bbox.maxX, f(t1));\r\n              }\r\n            }\r\n\r\n            let t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\r\n            if (0 < t2 && t2 < 1) {\r\n              if (i === 0) {\r\n                bbox.addPoint(f(t2), bbox.maxY);\r\n              } else if (i === 1) {\r\n                bbox.addPoint(bbox.maxX, f(t2));\r\n              }\r\n            }\r\n          }\r\n\r\n          cx = p3x;\r\n          cy = p3y;\r\n          break;\r\n      }\r\n    }\r\n\r\n    return this._bbox = Object.freeze(bbox);\r\n  }\r\n\r\n  /**\r\n   * Applies a mapping function to each point in the path.\r\n   * @param {function} fn\r\n   * @return {Path}\r\n   */\r\n  mapPoints(fn) {\r\n    let path = new Path;\r\n\r\n    for (let c of this.commands) {\r\n      let args = [];\r\n      for (let i = 0; i < c.args.length; i += 2) {\r\n        let [x, y] = fn(c.args[i], c.args[i + 1]);\r\n        args.push(x, y);\r\n      }\r\n\r\n      path[c.command](...args);\r\n    }\r\n\r\n    return path;\r\n  }\r\n\r\n  /**\r\n   * Transforms the path by the given matrix.\r\n   */\r\n  transform(m0, m1, m2, m3, m4, m5) {\r\n    return this.mapPoints((x, y) => {\r\n      x = m0 * x + m2 * y + m4;\r\n      y = m1 * x + m3 * y + m5;\r\n      return [x, y];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Translates the path by the given offset.\r\n   */\r\n  translate(x, y) {\r\n    return this.transform(1, 0, 0, 1, x, y);\r\n  }\r\n\r\n  /**\r\n   * Rotates the path by the given angle (in radians).\r\n   */\r\n  rotate(angle) {\r\n    let cos = Math.cos(angle);\r\n    let sin = Math.sin(angle);\r\n    return this.transform(cos, sin, -sin, cos, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Scales the path.\r\n   */\r\n  scale(scaleX, scaleY = scaleX) {\r\n    return this.transform(scaleX, 0, 0, scaleY, 0, 0);\r\n  }\r\n}\r\n\r\nfor (let command of ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath']) {\r\n  Path.prototype[command] = function(...args) {\r\n    this._bbox = this._cbox = null;\r\n    this.commands.push({\r\n      command,\r\n      args\r\n    });\r\n\r\n    return this;\r\n  };\r\n}\r\n","export default [\r\n  '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\r\n  'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\r\n  'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\r\n  'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\r\n  'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\r\n  'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\r\n  'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\r\n  'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\r\n  'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\r\n  'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\r\n  'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\r\n  'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\r\n  'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\r\n  'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\r\n  'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\r\n  'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\r\n  'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\r\n  'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\r\n  'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\r\n  'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\r\n  'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\r\n  'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\r\n  'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\r\n  'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\r\n  'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'\r\n];\r\n","import { cache } from '../decorators';\r\nimport Path from './Path';\r\nimport unicode from 'unicode-properties';\r\nimport StandardNames from './StandardNames';\r\n\r\n/**\r\n * Glyph objects represent a glyph in the font. They have various properties for accessing metrics and\r\n * the actual vector path the glyph represents, and methods for rendering the glyph to a graphics context.\r\n *\r\n * You do not create glyph objects directly. They are created by various methods on the font object.\r\n * There are several subclasses of the base Glyph class internally that may be returned depending\r\n * on the font format, but they all inherit from this class.\r\n */\r\nexport default class Glyph {\r\n  constructor(id, codePoints, font) {\r\n    /**\r\n     * The glyph id in the font\r\n     * @type {number}\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * An array of unicode code points that are represented by this glyph.\r\n     * There can be multiple code points in the case of ligatures and other glyphs\r\n     * that represent multiple visual characters.\r\n     * @type {number[]}\r\n     */\r\n    this.codePoints = codePoints;\r\n    this._font = font;\r\n\r\n    // TODO: get this info from GDEF if available\r\n    this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);\r\n    this.isLigature = this.codePoints.length > 1;\r\n  }\r\n\r\n  _getPath() {\r\n    return new Path();\r\n  }\r\n\r\n  _getCBox() {\r\n    return this.path.cbox;\r\n  }\r\n\r\n  _getBBox() {\r\n    return this.path.bbox;\r\n  }\r\n\r\n  _getTableMetrics(table) {\r\n    if (this.id < table.metrics.length) {\r\n      return table.metrics.get(this.id);\r\n    }\r\n\r\n    let metric = table.metrics.get(table.metrics.length - 1);\r\n    let res = {\r\n      advance: metric ? metric.advance : 0,\r\n      bearing: table.bearings.get(this.id - table.metrics.length) || 0\r\n    };\r\n\r\n    return res;\r\n  }\r\n\r\n  _getMetrics(cbox) {\r\n    if (this._metrics) { return this._metrics; }\r\n\r\n    let {advance:advanceWidth, bearing:leftBearing} = this._getTableMetrics(this._font.hmtx);\r\n\r\n    // For vertical metrics, use vmtx if available, or fall back to global data from OS/2 or hhea\r\n    if (this._font.vmtx) {\r\n      var {advance:advanceHeight, bearing:topBearing} = this._getTableMetrics(this._font.vmtx);\r\n\r\n    } else {\r\n      let os2;\r\n      if (typeof cbox === 'undefined' || cbox === null) { ({ cbox } = this); }\r\n\r\n      if ((os2 = this._font['OS/2']) && os2.version > 0) {\r\n        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);\r\n        var topBearing = os2.typoAscender - cbox.maxY;\r\n\r\n      } else {\r\n        let { hhea } = this._font;\r\n        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);\r\n        var topBearing = hhea.ascent - cbox.maxY;\r\n      }\r\n    }\r\n\r\n    if (this._font._variationProcessor && this._font.HVAR) {\r\n      advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);\r\n    }\r\n\r\n    return this._metrics = { advanceWidth, advanceHeight, leftBearing, topBearing };\r\n  }\r\n\r\n  /**\r\n   * The glyph’s control box.\r\n   * This is often the same as the bounding box, but is faster to compute.\r\n   * Because of the way bezier curves are defined, some of the control points\r\n   * can be outside of the bounding box. Where `bbox` takes this into account,\r\n   * `cbox` does not. Thus, cbox is less accurate, but faster to compute.\r\n   * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)\r\n   * for a more detailed description.\r\n   *\r\n   * @type {BBox}\r\n   */\r\n  @cache\r\n  get cbox() {\r\n    return this._getCBox();\r\n  }\r\n\r\n  /**\r\n   * The glyph’s bounding box, i.e. the rectangle that encloses the\r\n   * glyph outline as tightly as possible.\r\n   * @type {BBox}\r\n   */\r\n  @cache\r\n  get bbox() {\r\n    return this._getBBox();\r\n  }\r\n\r\n  /**\r\n   * A vector Path object representing the glyph outline.\r\n   * @type {Path}\r\n   */\r\n  @cache\r\n  get path() {\r\n    // Cache the path so we only decode it once\r\n    // Decoding is actually performed by subclasses\r\n    return this._getPath();\r\n  }\r\n\r\n  /**\r\n   * Returns a path scaled to the given font size.\r\n   * @param {number} size\r\n   * @return {Path}\r\n   */\r\n  getScaledPath(size) {\r\n    let scale = 1 / this._font.unitsPerEm * size;\r\n    return this.path.scale(scale);\r\n  }\r\n\r\n  /**\r\n   * The glyph's advance width.\r\n   * @type {number}\r\n   */\r\n  @cache\r\n  get advanceWidth() {\r\n    return this._getMetrics().advanceWidth;\r\n  }\r\n\r\n  /**\r\n   * The glyph's advance height.\r\n   * @type {number}\r\n   */\r\n  @cache\r\n  get advanceHeight() {\r\n    return this._getMetrics().advanceHeight;\r\n  }\r\n\r\n  get ligatureCaretPositions() {}\r\n\r\n  _getName() {\r\n    let { post } = this._font;\r\n    if (!post) {\r\n      return null;\r\n    }\r\n\r\n    switch (post.version) {\r\n      case 1:\r\n        return StandardNames[this.id];\r\n\r\n      case 2:\r\n        let id = post.glyphNameIndex[this.id];\r\n        if (id < StandardNames.length) {\r\n          return StandardNames[id];\r\n        }\r\n\r\n        return post.names[id - StandardNames.length];\r\n\r\n      case 2.5:\r\n        return StandardNames[this.id + post.offsets[this.id]];\r\n\r\n      case 4:\r\n        return String.fromCharCode(post.map[this.id]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The glyph's name\r\n   * @type {string}\r\n   */\r\n  @cache\r\n  get name() {\r\n    return this._getName();\r\n  }\r\n\r\n  /**\r\n   * Renders the glyph to the given graphics context, at the specified font size.\r\n   * @param {CanvasRenderingContext2d} ctx\r\n   * @param {number} size\r\n   */\r\n  render(ctx, size) {\r\n    ctx.save();\r\n\r\n    let scale = 1 / this._font.head.unitsPerEm * size;\r\n    ctx.scale(scale, scale);\r\n\r\n    let fn = this.path.toFunction();\r\n    fn(ctx);\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n","import Glyph from './Glyph';\r\nimport Path from './Path';\r\nimport BBox from './BBox';\r\nimport r from '@foliojs-fork/restructure';\r\n\r\n// The header for both simple and composite glyphs\r\nlet GlyfHeader = new r.Struct({\r\n  numberOfContours: r.int16, // if negative, this is a composite glyph\r\n  xMin:             r.int16,\r\n  yMin:             r.int16,\r\n  xMax:             r.int16,\r\n  yMax:             r.int16\r\n});\r\n\r\n// Flags for simple glyphs\r\nconst ON_CURVE        = 1 << 0;\r\nconst X_SHORT_VECTOR  = 1 << 1;\r\nconst Y_SHORT_VECTOR  = 1 << 2;\r\nconst REPEAT          = 1 << 3;\r\nconst SAME_X          = 1 << 4;\r\nconst SAME_Y          = 1 << 5;\r\n\r\n// Flags for composite glyphs\r\nconst ARG_1_AND_2_ARE_WORDS     = 1 << 0;\r\nconst ARGS_ARE_XY_VALUES        = 1 << 1;\r\nconst ROUND_XY_TO_GRID          = 1 << 2;\r\nconst WE_HAVE_A_SCALE           = 1 << 3;\r\nconst MORE_COMPONENTS           = 1 << 5;\r\nconst WE_HAVE_AN_X_AND_Y_SCALE  = 1 << 6;\r\nconst WE_HAVE_A_TWO_BY_TWO      = 1 << 7;\r\nconst WE_HAVE_INSTRUCTIONS      = 1 << 8;\r\nconst USE_MY_METRICS            = 1 << 9;\r\nconst OVERLAP_COMPOUND          = 1 << 10;\r\nconst SCALED_COMPONENT_OFFSET   = 1 << 11;\r\nconst UNSCALED_COMPONENT_OFFSET = 1 << 12;\r\n\r\n// Represents a point in a simple glyph\r\nexport class Point {\r\n  constructor(onCurve, endContour, x = 0, y = 0) {\r\n    this.onCurve = onCurve;\r\n    this.endContour = endContour;\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  copy() {\r\n    return new Point(this.onCurve, this.endContour, this.x, this.y);\r\n  }\r\n}\r\n\r\n// Represents a component in a composite glyph\r\nclass Component {\r\n  constructor(glyphID, dx, dy) {\r\n    this.glyphID = glyphID;\r\n    this.dx = dx;\r\n    this.dy = dy;\r\n    this.pos = 0;\r\n    this.scaleX = this.scaleY = 1;\r\n    this.scale01 = this.scale10 = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a TrueType glyph.\r\n */\r\nexport default class TTFGlyph extends Glyph {\r\n  // Parses just the glyph header and returns the bounding box\r\n  _getCBox(internal) {\r\n    // We need to decode the glyph if variation processing is requested,\r\n    // so it's easier just to recompute the path's cbox after decoding.\r\n    if (this._font._variationProcessor && !internal) {\r\n      return this.path.cbox;\r\n    }\r\n\r\n    let stream = this._font._getTableStream('glyf');\r\n    stream.pos += this._font.loca.offsets[this.id];\r\n    let glyph = GlyfHeader.decode(stream);\r\n\r\n    let cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);\r\n    return Object.freeze(cbox);\r\n  }\r\n\r\n  // Parses a single glyph coordinate\r\n  _parseGlyphCoord(stream, prev, short, same) {\r\n    if (short) {\r\n      var val = stream.readUInt8();\r\n      if (!same) {\r\n        val = -val;\r\n      }\r\n\r\n      val += prev;\r\n    } else {\r\n      if (same) {\r\n        var val = prev;\r\n      } else {\r\n        var val = prev + stream.readInt16BE();\r\n      }\r\n    }\r\n\r\n    return val;\r\n  }\r\n\r\n  // Decodes the glyph data into points for simple glyphs,\r\n  // or components for composite glyphs\r\n  _decode() {\r\n    let glyfPos = this._font.loca.offsets[this.id];\r\n    let nextPos = this._font.loca.offsets[this.id + 1];\r\n\r\n    // Nothing to do if there is no data for this glyph\r\n    if (glyfPos === nextPos) { return null; }\r\n\r\n    let stream = this._font._getTableStream('glyf');\r\n    stream.pos += glyfPos;\r\n    let startPos = stream.pos;\r\n\r\n    let glyph = GlyfHeader.decode(stream);\r\n\r\n    if (glyph.numberOfContours > 0) {\r\n      this._decodeSimple(glyph, stream);\r\n\r\n    } else if (glyph.numberOfContours < 0) {\r\n      this._decodeComposite(glyph, stream, startPos);\r\n    }\r\n\r\n    return glyph;\r\n  }\r\n\r\n  _decodeSimple(glyph, stream) {\r\n    // this is a simple glyph\r\n    glyph.points = [];\r\n\r\n    let endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);\r\n    glyph.instructions = new r.Array(r.uint8, r.uint16).decode(stream);\r\n\r\n    let flags = [];\r\n    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;\r\n\r\n    while (flags.length < numCoords) {\r\n      var flag = stream.readUInt8();\r\n      flags.push(flag);\r\n\r\n      // check for repeat flag\r\n      if (flag & REPEAT) {\r\n        let count = stream.readUInt8();\r\n        for (let j = 0; j < count; j++) {\r\n          flags.push(flag);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < flags.length; i++) {\r\n      var flag = flags[i];\r\n      let point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);\r\n      glyph.points.push(point);\r\n    }\r\n\r\n    let px = 0;\r\n    for (var i = 0; i < flags.length; i++) {\r\n      var flag = flags[i];\r\n      glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);\r\n    }\r\n\r\n    let py = 0;\r\n    for (var i = 0; i < flags.length; i++) {\r\n      var flag = flags[i];\r\n      glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);\r\n    }\r\n\r\n    if (this._font._variationProcessor) {\r\n      let points = glyph.points.slice();\r\n      points.push(...this._getPhantomPoints(glyph));\r\n\r\n      this._font._variationProcessor.transformPoints(this.id, points);\r\n      glyph.phantomPoints = points.slice(-4);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  _decodeComposite(glyph, stream, offset = 0) {\r\n    // this is a composite glyph\r\n    glyph.components = [];\r\n    let haveInstructions = false;\r\n    let flags = MORE_COMPONENTS;\r\n\r\n    while (flags & MORE_COMPONENTS) {\r\n      flags = stream.readUInt16BE();\r\n      let gPos = stream.pos - offset;\r\n      let glyphID = stream.readUInt16BE();\r\n      if (!haveInstructions) {\r\n        haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;\r\n      }\r\n\r\n      if (flags & ARG_1_AND_2_ARE_WORDS) {\r\n        var dx = stream.readInt16BE();\r\n        var dy = stream.readInt16BE();\r\n      } else {\r\n        var dx = stream.readInt8();\r\n        var dy = stream.readInt8();\r\n      }\r\n\r\n      var component = new Component(glyphID, dx, dy);\r\n      component.pos = gPos;\r\n\r\n      if (flags & WE_HAVE_A_SCALE) {\r\n        // fixed number with 14 bits of fraction\r\n        component.scaleX =\r\n        component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n\r\n      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {\r\n        component.scaleX = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n        component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n\r\n      } else if (flags & WE_HAVE_A_TWO_BY_TWO) {\r\n        component.scaleX  = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n        component.scale01 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n        component.scale10 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n        component.scaleY  = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n      }\r\n\r\n      glyph.components.push(component);\r\n    }\r\n\r\n    if (this._font._variationProcessor) {\r\n      let points = [];\r\n      for (let j = 0; j < glyph.components.length; j++) {\r\n        var component = glyph.components[j];\r\n        points.push(new Point(true, true, component.dx, component.dy));\r\n      }\r\n\r\n      points.push(...this._getPhantomPoints(glyph));\r\n\r\n      this._font._variationProcessor.transformPoints(this.id, points);\r\n      glyph.phantomPoints = points.splice(-4, 4);\r\n\r\n      for (let i = 0; i < points.length; i++) {\r\n        let point = points[i];\r\n        glyph.components[i].dx = point.x;\r\n        glyph.components[i].dy = point.y;\r\n      }\r\n    }\r\n\r\n    return haveInstructions;\r\n  }\r\n\r\n  _getPhantomPoints(glyph) {\r\n    let cbox = this._getCBox(true);\r\n    if (this._metrics == null) {\r\n      this._metrics = Glyph.prototype._getMetrics.call(this, cbox);\r\n    }\r\n\r\n    let { advanceWidth, advanceHeight, leftBearing, topBearing } = this._metrics;\r\n\r\n    return [\r\n      new Point(false, true, glyph.xMin - leftBearing, 0),\r\n      new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0),\r\n      new Point(false, true, 0, glyph.yMax + topBearing),\r\n      new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)\r\n    ];\r\n  }\r\n\r\n  // Decodes font data, resolves composite glyphs, and returns an array of contours\r\n  _getContours() {\r\n    let glyph = this._decode();\r\n    if (!glyph) {\r\n      return [];\r\n    }\r\n\r\n    let points = [];\r\n\r\n    if (glyph.numberOfContours < 0) {\r\n      // resolve composite glyphs\r\n      for (let component of glyph.components) {\r\n        let contours = this._font.getGlyph(component.glyphID)._getContours();\r\n        for (let i = 0; i < contours.length; i++) {\r\n          let contour = contours[i];\r\n          for (let j = 0; j < contour.length; j++) {\r\n            let point = contour[j];\r\n            let x = point.x * component.scaleX + point.y * component.scale01 + component.dx;\r\n            let y = point.y * component.scaleY + point.x * component.scale10 + component.dy;\r\n            points.push(new Point(point.onCurve, point.endContour, x, y));\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      points = glyph.points || [];\r\n    }\r\n\r\n    // Recompute and cache metrics if we performed variation processing, and don't have an HVAR table\r\n    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {\r\n      this._metrics.advanceWidth  = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;\r\n      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;\r\n      this._metrics.leftBearing   = glyph.xMin - glyph.phantomPoints[0].x;\r\n      this._metrics.topBearing    = glyph.phantomPoints[2].y - glyph.yMax;\r\n    }\r\n\r\n    let contours = [];\r\n    let cur = [];\r\n    for (let k = 0; k < points.length; k++) {\r\n      var point = points[k];\r\n      cur.push(point);\r\n      if (point.endContour) {\r\n        contours.push(cur);\r\n        cur = [];\r\n      }\r\n    }\r\n\r\n    return contours;\r\n  }\r\n\r\n  _getMetrics() {\r\n    if (this._metrics) {\r\n      return this._metrics;\r\n    }\r\n\r\n    let cbox = this._getCBox(true);\r\n    super._getMetrics(cbox);\r\n\r\n    if (this._font._variationProcessor && !this._font.HVAR) {\r\n      // No HVAR table, decode the glyph. This triggers recomputation of metrics.\r\n      this.path;\r\n    }\r\n\r\n    return this._metrics;\r\n  }\r\n\r\n  // Converts contours to a Path object that can be rendered\r\n  _getPath() {\r\n    let contours = this._getContours();\r\n    let path = new Path;\r\n\r\n    for (let i = 0; i < contours.length; i++) {\r\n      let contour = contours[i];\r\n      let firstPt = contour[0];\r\n      let lastPt = contour[contour.length - 1];\r\n      let start = 0;\r\n\r\n      if (firstPt.onCurve) {\r\n        // The first point will be consumed by the moveTo command, so skip in the loop\r\n        var curvePt = null;\r\n        start = 1;\r\n      } else {\r\n        if (lastPt.onCurve) {\r\n          // Start at the last point if the first point is off curve and the last point is on curve\r\n          firstPt = lastPt;\r\n        } else {\r\n          // Start at the middle if both the first and last points are off curve\r\n          firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);\r\n        }\r\n\r\n        var curvePt = firstPt;\r\n      }\r\n\r\n      path.moveTo(firstPt.x, firstPt.y);\r\n\r\n      for (let j = start; j < contour.length; j++) {\r\n        let pt = contour[j];\r\n        let prevPt = j === 0 ? firstPt : contour[j - 1];\r\n\r\n        if (prevPt.onCurve && pt.onCurve) {\r\n          path.lineTo(pt.x, pt.y);\r\n\r\n        } else if (prevPt.onCurve && !pt.onCurve) {\r\n          var curvePt = pt;\r\n\r\n        } else if (!prevPt.onCurve && !pt.onCurve) {\r\n          let midX = (prevPt.x + pt.x) / 2;\r\n          let midY = (prevPt.y + pt.y) / 2;\r\n          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);\r\n          var curvePt = pt;\r\n\r\n        } else if (!prevPt.onCurve && pt.onCurve) {\r\n          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);\r\n          var curvePt = null;\r\n\r\n        } else {\r\n          throw new Error(\"Unknown TTF path state\");\r\n        }\r\n      }\r\n\r\n      // Connect the first and last points\r\n      if (curvePt) {\r\n        path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);\r\n      }\r\n\r\n      path.closePath();\r\n    }\r\n\r\n    return path;\r\n  }\r\n}\r\n","import Glyph from './Glyph';\r\nimport Path from './Path';\r\n\r\n/**\r\n * Represents an OpenType PostScript glyph, in the Compact Font Format.\r\n */\r\nexport default class CFFGlyph extends Glyph {\r\n  _getName() {\r\n    if (this._font.CFF2) {\r\n      return super._getName();\r\n    }\r\n\r\n    return this._font['CFF '].getGlyphName(this.id);\r\n  }\r\n\r\n  bias(s) {\r\n    if (s.length < 1240) {\r\n      return 107;\r\n    } else if (s.length < 33900) {\r\n      return 1131;\r\n    } else {\r\n      return 32768;\r\n    }\r\n  }\r\n\r\n  _getPath() {\r\n    let cff = this._font.CFF2 || this._font['CFF '];\r\n    let { stream } = cff;\r\n    let str = cff.topDict.CharStrings[this.id];\r\n    let end = str.offset + str.length;\r\n    stream.pos = str.offset;\r\n\r\n    let path = new Path;\r\n    let stack = [];\r\n    let trans = [];\r\n\r\n    let width = null;\r\n    let nStems = 0;\r\n    let x = 0, y = 0;\r\n    let usedGsubrs;\r\n    let usedSubrs;\r\n    let open = false;\r\n\r\n    this._usedGsubrs = usedGsubrs = {};\r\n    this._usedSubrs = usedSubrs = {};\r\n\r\n    let gsubrs = cff.globalSubrIndex || [];\r\n    let gsubrsBias = this.bias(gsubrs);\r\n\r\n    let privateDict = cff.privateDictForGlyph(this.id) || {};\r\n    let subrs = privateDict.Subrs || [];\r\n    let subrsBias = this.bias(subrs);\r\n\r\n    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;\r\n    let vsindex = privateDict.vsindex;\r\n    let variationProcessor = this._font._variationProcessor;\r\n\r\n    function checkWidth() {\r\n      if (width == null) {\r\n        width = stack.shift() + privateDict.nominalWidthX;\r\n      }\r\n    }\r\n\r\n    function parseStems() {\r\n      if (stack.length % 2 !== 0) {\r\n        checkWidth();\r\n      }\r\n\r\n      nStems += stack.length >> 1;\r\n      return stack.length = 0;\r\n    }\r\n\r\n    function moveTo(x, y) {\r\n      if (open) {\r\n        path.closePath();\r\n      }\r\n\r\n      path.moveTo(x, y);\r\n      open = true;\r\n    }\r\n\r\n    let parse = function() {\r\n      while (stream.pos < end) {\r\n        let op = stream.readUInt8();\r\n        if (op < 32) {\r\n          switch (op) {\r\n            case 1:  // hstem\r\n            case 3:  // vstem\r\n            case 18: // hstemhm\r\n            case 23: // vstemhm\r\n              parseStems();\r\n              break;\r\n\r\n            case 4: // vmoveto\r\n              if (stack.length > 1) {\r\n                checkWidth();\r\n              }\r\n\r\n              y += stack.shift();\r\n              moveTo(x, y);\r\n              break;\r\n\r\n            case 5: // rlineto\r\n              while (stack.length >= 2) {\r\n                x += stack.shift();\r\n                y += stack.shift();\r\n                path.lineTo(x, y);\r\n              }\r\n              break;\r\n\r\n            case 6: // hlineto\r\n            case 7: // vlineto\r\n              let phase = op === 6;\r\n              while (stack.length >= 1) {\r\n                if (phase) {\r\n                  x += stack.shift();\r\n                } else {\r\n                  y += stack.shift();\r\n                }\r\n\r\n                path.lineTo(x, y);\r\n                phase = !phase;\r\n              }\r\n              break;\r\n\r\n            case 8: // rrcurveto\r\n              while (stack.length > 0) {\r\n                var c1x = x + stack.shift();\r\n                var c1y = y + stack.shift();\r\n                var c2x = c1x + stack.shift();\r\n                var c2y = c1y + stack.shift();\r\n                x = c2x + stack.shift();\r\n                y = c2y + stack.shift();\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              }\r\n              break;\r\n\r\n            case 10: // callsubr\r\n              let index = stack.pop() + subrsBias;\r\n              let subr = subrs[index];\r\n              if (subr) {\r\n                usedSubrs[index] = true;\r\n                var p = stream.pos;\r\n                var e = end;\r\n                stream.pos = subr.offset;\r\n                end = subr.offset + subr.length;\r\n                parse();\r\n                stream.pos = p;\r\n                end = e;\r\n              }\r\n              break;\r\n\r\n            case 11: // return\r\n              if (cff.version >= 2) {\r\n                break;\r\n              }\r\n              return;\r\n\r\n            case 14: // endchar\r\n              if (cff.version >= 2) {\r\n                break;\r\n              }\r\n\r\n              if (stack.length > 0) {\r\n                checkWidth();\r\n              }\r\n\r\n              if (open) {\r\n                path.closePath();\r\n                open = false;\r\n              }\r\n              break;\r\n\r\n            case 15: { // vsindex\r\n              if (cff.version < 2) {\r\n                throw new Error('vsindex operator not supported in CFF v1');\r\n              }\r\n\r\n              vsindex = stack.pop();\r\n              break;\r\n            }\r\n\r\n            case 16: { // blend\r\n              if (cff.version < 2) {\r\n                throw new Error('blend operator not supported in CFF v1');\r\n              }\r\n\r\n              if (!variationProcessor) {\r\n                throw new Error('blend operator in non-variation font');\r\n              }\r\n\r\n              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);\r\n              let numBlends = stack.pop();\r\n              let numOperands = numBlends * blendVector.length;\r\n              let delta = stack.length - numOperands;\r\n              let base = delta - numBlends;\r\n\r\n              for (let i = 0; i < numBlends; i++) {\r\n                let sum = stack[base + i];\r\n                for (let j = 0; j < blendVector.length; j++) {\r\n                  sum += blendVector[j] * stack[delta++];\r\n                }\r\n\r\n                stack[base + i] = sum;\r\n              }\r\n\r\n              while (numOperands--) {\r\n                stack.pop();\r\n              }\r\n\r\n              break;\r\n            }\r\n\r\n            case 19: // hintmask\r\n            case 20: // cntrmask\r\n              parseStems();\r\n              stream.pos += (nStems + 7) >> 3;\r\n              break;\r\n\r\n            case 21: // rmoveto\r\n              if (stack.length > 2) {\r\n                checkWidth();\r\n              }\r\n\r\n              x += stack.shift();\r\n              y += stack.shift();\r\n              moveTo(x, y);\r\n              break;\r\n\r\n            case 22: // hmoveto\r\n              if (stack.length > 1) {\r\n                checkWidth();\r\n              }\r\n\r\n              x += stack.shift();\r\n              moveTo(x, y);\r\n              break;\r\n\r\n            case 24: // rcurveline\r\n              while (stack.length >= 8) {\r\n                var c1x = x + stack.shift();\r\n                var c1y = y + stack.shift();\r\n                var c2x = c1x + stack.shift();\r\n                var c2y = c1y + stack.shift();\r\n                x = c2x + stack.shift();\r\n                y = c2y + stack.shift();\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              }\r\n\r\n              x += stack.shift();\r\n              y += stack.shift();\r\n              path.lineTo(x, y);\r\n              break;\r\n\r\n            case 25: // rlinecurve\r\n              while (stack.length >= 8) {\r\n                x += stack.shift();\r\n                y += stack.shift();\r\n                path.lineTo(x, y);\r\n              }\r\n\r\n              var c1x = x + stack.shift();\r\n              var c1y = y + stack.shift();\r\n              var c2x = c1x + stack.shift();\r\n              var c2y = c1y + stack.shift();\r\n              x = c2x + stack.shift();\r\n              y = c2y + stack.shift();\r\n              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              break;\r\n\r\n            case 26: // vvcurveto\r\n              if (stack.length % 2) {\r\n                x += stack.shift();\r\n              }\r\n\r\n              while (stack.length >= 4) {\r\n                c1x = x;\r\n                c1y = y + stack.shift();\r\n                c2x = c1x + stack.shift();\r\n                c2y = c1y + stack.shift();\r\n                x = c2x;\r\n                y = c2y + stack.shift();\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              }\r\n              break;\r\n\r\n            case 27: // hhcurveto\r\n              if (stack.length % 2) {\r\n                y += stack.shift();\r\n              }\r\n\r\n              while (stack.length >= 4) {\r\n                c1x = x + stack.shift();\r\n                c1y = y;\r\n                c2x = c1x + stack.shift();\r\n                c2y = c1y + stack.shift();\r\n                x = c2x + stack.shift();\r\n                y = c2y;\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              }\r\n              break;\r\n\r\n            case 28: // shortint\r\n              stack.push(stream.readInt16BE());\r\n              break;\r\n\r\n            case 29: // callgsubr\r\n              index = stack.pop() + gsubrsBias;\r\n              subr = gsubrs[index];\r\n              if (subr) {\r\n                usedGsubrs[index] = true;\r\n                var p = stream.pos;\r\n                var e = end;\r\n                stream.pos = subr.offset;\r\n                end = subr.offset + subr.length;\r\n                parse();\r\n                stream.pos = p;\r\n                end = e;\r\n              }\r\n              break;\r\n\r\n            case 30: // vhcurveto\r\n            case 31: // hvcurveto\r\n              phase = op === 31;\r\n              while (stack.length >= 4) {\r\n                if (phase) {\r\n                  c1x = x + stack.shift();\r\n                  c1y = y;\r\n                  c2x = c1x + stack.shift();\r\n                  c2y = c1y + stack.shift();\r\n                  y = c2y + stack.shift();\r\n                  x = c2x + (stack.length === 1 ? stack.shift() : 0);\r\n                } else {\r\n                  c1x = x;\r\n                  c1y = y + stack.shift();\r\n                  c2x = c1x + stack.shift();\r\n                  c2y = c1y + stack.shift();\r\n                  x = c2x + stack.shift();\r\n                  y = c2y + (stack.length === 1 ? stack.shift() : 0);\r\n                }\r\n\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n                phase = !phase;\r\n              }\r\n              break;\r\n\r\n            case 12:\r\n              op = stream.readUInt8();\r\n              switch (op) {\r\n                case 3: // and\r\n                  let a = stack.pop();\r\n                  let b = stack.pop();\r\n                  stack.push(a && b ? 1 : 0);\r\n                  break;\r\n\r\n                case 4: // or\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a || b ? 1 : 0);\r\n                  break;\r\n\r\n                case 5: // not\r\n                  a = stack.pop();\r\n                  stack.push(a ? 0 : 1);\r\n                  break;\r\n\r\n                case 9: // abs\r\n                  a = stack.pop();\r\n                  stack.push(Math.abs(a));\r\n                  break;\r\n\r\n                case 10: // add\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a + b);\r\n                  break;\r\n\r\n                case 11: // sub\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a - b);\r\n                  break;\r\n\r\n                case 12: // div\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a / b);\r\n                  break;\r\n\r\n                case 14: // neg\r\n                  a = stack.pop();\r\n                  stack.push(-a);\r\n                  break;\r\n\r\n                case 15: // eq\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a === b ? 1 : 0);\r\n                  break;\r\n\r\n                case 18: // drop\r\n                  stack.pop();\r\n                  break;\r\n\r\n                case 20: // put\r\n                  let val = stack.pop();\r\n                  let idx = stack.pop();\r\n                  trans[idx] = val;\r\n                  break;\r\n\r\n                case 21: // get\r\n                  idx = stack.pop();\r\n                  stack.push(trans[idx] || 0);\r\n                  break;\r\n\r\n                case 22: // ifelse\r\n                  let s1 = stack.pop();\r\n                  let s2 = stack.pop();\r\n                  let v1 = stack.pop();\r\n                  let v2 = stack.pop();\r\n                  stack.push(v1 <= v2 ? s1 : s2);\r\n                  break;\r\n\r\n                case 23: // random\r\n                  stack.push(Math.random());\r\n                  break;\r\n\r\n                case 24: // mul\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a * b);\r\n                  break;\r\n\r\n                case 26: // sqrt\r\n                  a = stack.pop();\r\n                  stack.push(Math.sqrt(a));\r\n                  break;\r\n\r\n                case 27: // dup\r\n                  a = stack.pop();\r\n                  stack.push(a, a);\r\n                  break;\r\n\r\n                case 28: // exch\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(b, a);\r\n                  break;\r\n\r\n                case 29: // index\r\n                  idx = stack.pop();\r\n                  if (idx < 0) {\r\n                    idx = 0;\r\n                  } else if (idx > stack.length - 1) {\r\n                    idx = stack.length - 1;\r\n                  }\r\n\r\n                  stack.push(stack[idx]);\r\n                  break;\r\n\r\n                case 30: // roll\r\n                  let n = stack.pop();\r\n                  let j = stack.pop();\r\n\r\n                  if (j >= 0) {\r\n                    while (j > 0) {\r\n                      var t = stack[n - 1];\r\n                      for (let i = n - 2; i >= 0; i--) {\r\n                        stack[i + 1] = stack[i];\r\n                      }\r\n\r\n                      stack[0] = t;\r\n                      j--;\r\n                    }\r\n                  } else {\r\n                    while (j < 0) {\r\n                      var t = stack[0];\r\n                      for (let i = 0; i <= n; i++) {\r\n                        stack[i] = stack[i + 1];\r\n                      }\r\n\r\n                      stack[n - 1] = t;\r\n                      j++;\r\n                    }\r\n                  }\r\n                  break;\r\n\r\n                case 34: // hflex\r\n                  c1x = x + stack.shift();\r\n                  c1y = y;\r\n                  c2x = c1x + stack.shift();\r\n                  c2y = c1y + stack.shift();\r\n                  let c3x = c2x + stack.shift();\r\n                  let c3y = c2y;\r\n                  let c4x = c3x + stack.shift();\r\n                  let c4y = c3y;\r\n                  let c5x = c4x + stack.shift();\r\n                  let c5y = c4y;\r\n                  let c6x = c5x + stack.shift();\r\n                  let c6y = c5y;\r\n                  x = c6x;\r\n                  y = c6y;\r\n\r\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\r\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\r\n                  break;\r\n\r\n                case 35: // flex\r\n                  let pts = [];\r\n\r\n                  for (let i = 0; i <= 5; i++) {\r\n                    x += stack.shift();\r\n                    y += stack.shift();\r\n                    pts.push(x, y);\r\n                  }\r\n\r\n                  path.bezierCurveTo(...pts.slice(0, 6));\r\n                  path.bezierCurveTo(...pts.slice(6));\r\n                  stack.shift(); // fd\r\n                  break;\r\n\r\n                case 36: // hflex1\r\n                  c1x = x + stack.shift();\r\n                  c1y = y + stack.shift();\r\n                  c2x = c1x + stack.shift();\r\n                  c2y = c1y + stack.shift();\r\n                  c3x = c2x + stack.shift();\r\n                  c3y = c2y;\r\n                  c4x = c3x + stack.shift();\r\n                  c4y = c3y;\r\n                  c5x = c4x + stack.shift();\r\n                  c5y = c4y + stack.shift();\r\n                  c6x = c5x + stack.shift();\r\n                  c6y = c5y;\r\n                  x = c6x;\r\n                  y = c6y;\r\n\r\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\r\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\r\n                  break;\r\n\r\n                case 37: // flex1\r\n                  let startx = x;\r\n                  let starty = y;\r\n\r\n                  pts = [];\r\n                  for (let i = 0; i <= 4; i++) {\r\n                    x += stack.shift();\r\n                    y += stack.shift();\r\n                    pts.push(x, y);\r\n                  }\r\n\r\n                  if (Math.abs(x - startx) > Math.abs(y - starty)) { // horizontal\r\n                    x += stack.shift();\r\n                    y = starty;\r\n                  } else {\r\n                    x = startx;\r\n                    y += stack.shift();\r\n                  }\r\n\r\n                  pts.push(x, y);\r\n                  path.bezierCurveTo(...pts.slice(0, 6));\r\n                  path.bezierCurveTo(...pts.slice(6));\r\n                  break;\r\n\r\n                default:\r\n                  throw new Error(`Unknown op: 12 ${op}`);\r\n              }\r\n              break;\r\n\r\n            default:\r\n              throw new Error(`Unknown op: ${op}`);\r\n          }\r\n\r\n        } else if (op < 247) {\r\n          stack.push(op - 139);\r\n        } else if (op < 251) {\r\n          var b1 = stream.readUInt8();\r\n          stack.push((op - 247) * 256 + b1 + 108);\r\n        } else if (op < 255) {\r\n          var b1 = stream.readUInt8();\r\n          stack.push(-(op - 251) * 256 - b1 - 108);\r\n        } else {\r\n          stack.push(stream.readInt32BE() / 65536);\r\n        }\r\n      }\r\n    };\r\n\r\n    parse();\r\n\r\n    if (open) {\r\n      path.closePath();\r\n    }\r\n\r\n    return path;\r\n  }\r\n}\r\n","import TTFGlyph from './TTFGlyph';\r\nimport r from '@foliojs-fork/restructure';\r\n\r\nlet SBIXImage = new r.Struct({\r\n  originX: r.uint16,\r\n  originY: r.uint16,\r\n  type: new r.String(4),\r\n  data: new r.Buffer(t => t.parent.buflen - t._currentOffset)\r\n});\r\n\r\n/**\r\n * Represents a color (e.g. emoji) glyph in Apple's SBIX format.\r\n */\r\nexport default class SBIXGlyph extends TTFGlyph {\r\n  /**\r\n   * Returns an object representing a glyph image at the given point size.\r\n   * The object has a data property with a Buffer containing the actual image data,\r\n   * along with the image type, and origin.\r\n   *\r\n   * @param {number} size\r\n   * @return {object}\r\n   */\r\n  getImageForSize(size) {\r\n    for (let i = 0; i < this._font.sbix.imageTables.length; i++) {\r\n      var table = this._font.sbix.imageTables[i];\r\n      if (table.ppem >= size) { break; }\r\n    }\r\n\r\n    let offsets = table.imageOffsets;\r\n    let start = offsets[this.id];\r\n    let end = offsets[this.id + 1];\r\n\r\n    if (start === end) {\r\n      return null;\r\n    }\r\n\r\n    this._font.stream.pos = start;\r\n    return SBIXImage.decode(this._font.stream, {buflen: end - start});\r\n  }\r\n\r\n  render(ctx, size) {\r\n    let img = this.getImageForSize(size);\r\n    if (img != null) {\r\n      let scale = size / this._font.unitsPerEm;\r\n      ctx.image(img.data, {height: size, x: img.originX, y: (this.bbox.minY - img.originY) * scale});\r\n    }\r\n\r\n    if (this._font.sbix.flags.renderOutlines) {\r\n      super.render(ctx, size);\r\n    }\r\n  }\r\n}\r\n","import Glyph from './Glyph';\r\nimport BBox from './BBox';\r\n\r\nclass COLRLayer {\r\n  constructor(glyph, color) {\r\n    this.glyph = glyph;\r\n    this.color = color;\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a color (e.g. emoji) glyph in Microsoft's COLR format.\r\n * Each glyph in this format contain a list of colored layers, each\r\n * of which  is another vector glyph.\r\n */\r\nexport default class COLRGlyph extends Glyph {\r\n  _getBBox() {\r\n    let bbox = new BBox;\r\n    for (let i = 0; i < this.layers.length; i++) {\r\n      let layer = this.layers[i];\r\n      let b = layer.glyph.bbox;\r\n      bbox.addPoint(b.minX, b.minY);\r\n      bbox.addPoint(b.maxX, b.maxY);\r\n    }\r\n\r\n    return bbox;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of objects containing the glyph and color for\r\n   * each layer in the composite color glyph.\r\n   * @type {object[]}\r\n   */\r\n  get layers() {\r\n    let cpal = this._font.CPAL;\r\n    let colr = this._font.COLR;\r\n    let low = 0;\r\n    let high = colr.baseGlyphRecord.length - 1;\r\n\r\n    while (low <= high) {\r\n      let mid = (low + high) >> 1;\r\n      var rec = colr.baseGlyphRecord[mid];\r\n\r\n      if (this.id < rec.gid) {\r\n        high = mid - 1;\r\n      } else if (this.id > rec.gid) {\r\n        low = mid + 1;\r\n      } else {\r\n        var baseLayer = rec;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // if base glyph not found in COLR table,\r\n    // default to normal glyph from glyf or CFF\r\n    if (baseLayer == null) {\r\n      var g = this._font._getBaseGlyph(this.id);\r\n      var color = {\r\n        red: 0,\r\n        green: 0,\r\n        blue: 0,\r\n        alpha: 255\r\n      };\r\n\r\n      return [new COLRLayer(g, color)];\r\n    }\r\n\r\n    // otherwise, return an array of all the layers\r\n    let layers = [];\r\n    for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {\r\n      var rec = colr.layerRecords[i];\r\n      var color = cpal.colorRecords[rec.paletteIndex];\r\n      var g = this._font._getBaseGlyph(rec.gid);\r\n      layers.push(new COLRLayer(g, color));\r\n    }\r\n\r\n    return layers;\r\n  }\r\n\r\n  render(ctx, size) {\r\n    for (let {glyph, color} of this.layers) {\r\n      ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);\r\n      glyph.render(ctx, size);\r\n    }\r\n\r\n    return;\r\n  }\r\n}\r\n","const TUPLES_SHARE_POINT_NUMBERS = 0x8000;\r\nconst TUPLE_COUNT_MASK           = 0x0fff;\r\nconst EMBEDDED_TUPLE_COORD       = 0x8000;\r\nconst INTERMEDIATE_TUPLE         = 0x4000;\r\nconst PRIVATE_POINT_NUMBERS      = 0x2000;\r\nconst TUPLE_INDEX_MASK           = 0x0fff;\r\nconst POINTS_ARE_WORDS           = 0x80;\r\nconst POINT_RUN_COUNT_MASK       = 0x7f;\r\nconst DELTAS_ARE_ZERO            = 0x80;\r\nconst DELTAS_ARE_WORDS           = 0x40;\r\nconst DELTA_RUN_COUNT_MASK       = 0x3f;\r\n\r\n/**\r\n * This class is transforms TrueType glyphs according to the data from\r\n * the Apple Advanced Typography variation tables (fvar, gvar, and avar).\r\n * These tables allow infinite adjustments to glyph weight, width, slant,\r\n * and optical size without the designer needing to specify every exact style.\r\n *\r\n * Apple's documentation for these tables is not great, so thanks to the\r\n * Freetype project for figuring much of this out.\r\n *\r\n * @private\r\n */\r\nexport default class GlyphVariationProcessor {\r\n  constructor(font, coords) {\r\n    this.font = font;\r\n    this.normalizedCoords = this.normalizeCoords(coords);\r\n    this.blendVectors = new Map;\r\n  }\r\n\r\n  normalizeCoords(coords) {\r\n    // the default mapping is linear along each axis, in two segments:\r\n    // from the minValue to defaultValue, and from defaultValue to maxValue.\r\n    let normalized = [];\r\n    for (var i = 0; i < this.font.fvar.axis.length; i++) {\r\n      let axis = this.font.fvar.axis[i];\r\n      if (coords[i] < axis.defaultValue) {\r\n        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));\r\n      } else {\r\n        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));\r\n      }\r\n    }\r\n\r\n    // if there is an avar table, the normalized value is calculated\r\n    // by interpolating between the two nearest mapped values.\r\n    if (this.font.avar) {\r\n      for (var i = 0; i < this.font.avar.segment.length; i++) {\r\n        let segment = this.font.avar.segment[i];\r\n        for (let j = 0; j < segment.correspondence.length; j++) {\r\n          let pair = segment.correspondence[j];\r\n          if (j >= 1 && normalized[i] < pair.fromCoord) {\r\n            let prev = segment.correspondence[j - 1];\r\n            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) /\r\n              (pair.fromCoord - prev.fromCoord + Number.EPSILON) +\r\n              prev.toCoord;\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return normalized;\r\n  }\r\n\r\n  transformPoints(gid, glyphPoints) {\r\n    if (!this.font.fvar || !this.font.gvar) { return; }\r\n\r\n    let { gvar } = this.font;\r\n    if (gid >= gvar.glyphCount) { return; }\r\n\r\n    let offset = gvar.offsets[gid];\r\n    if (offset === gvar.offsets[gid + 1]) { return; }\r\n\r\n    // Read the gvar data for this glyph\r\n    let { stream } = this.font;\r\n    stream.pos = offset;\r\n    if (stream.pos >= stream.length) {\r\n      return;\r\n    }\r\n\r\n    let tupleCount = stream.readUInt16BE();\r\n    let offsetToData = offset + stream.readUInt16BE();\r\n\r\n    if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {\r\n      var here = stream.pos;\r\n      stream.pos = offsetToData;\r\n      var sharedPoints = this.decodePoints();\r\n      offsetToData = stream.pos;\r\n      stream.pos = here;\r\n    }\r\n\r\n    let origPoints = glyphPoints.map(pt => pt.copy());\r\n\r\n    tupleCount &= TUPLE_COUNT_MASK;\r\n    for (let i = 0; i < tupleCount; i++) {\r\n      let tupleDataSize = stream.readUInt16BE();\r\n      let tupleIndex = stream.readUInt16BE();\r\n\r\n      if (tupleIndex & EMBEDDED_TUPLE_COORD) {\r\n        var tupleCoords = [];\r\n        for (let a = 0; a < gvar.axisCount; a++) {\r\n          tupleCoords.push(stream.readInt16BE() / 16384);\r\n        }\r\n\r\n      } else {\r\n        if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {\r\n          throw new Error('Invalid gvar table');\r\n        }\r\n\r\n        var tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK];\r\n      }\r\n\r\n      if (tupleIndex & INTERMEDIATE_TUPLE) {\r\n        var startCoords = [];\r\n        for (let a = 0; a < gvar.axisCount; a++) {\r\n          startCoords.push(stream.readInt16BE() / 16384);\r\n        }\r\n\r\n        var endCoords = [];\r\n        for (let a = 0; a < gvar.axisCount; a++) {\r\n          endCoords.push(stream.readInt16BE() / 16384);\r\n        }\r\n      }\r\n\r\n      // Get the factor at which to apply this tuple\r\n      let factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);\r\n      if (factor === 0) {\r\n        offsetToData += tupleDataSize;\r\n        continue;\r\n      }\r\n\r\n      var here = stream.pos;\r\n      stream.pos = offsetToData;\r\n\r\n      if (tupleIndex & PRIVATE_POINT_NUMBERS) {\r\n        var points = this.decodePoints();\r\n      } else {\r\n        var points = sharedPoints;\r\n      }\r\n\r\n      // points.length = 0 means there are deltas for all points\r\n      let nPoints = points.length === 0 ? glyphPoints.length : points.length;\r\n      let xDeltas = this.decodeDeltas(nPoints);\r\n      let yDeltas = this.decodeDeltas(nPoints);\r\n\r\n      if (points.length === 0) { // all points\r\n        for (let i = 0; i < glyphPoints.length; i++) {\r\n          var point = glyphPoints[i];\r\n          point.x += Math.round(xDeltas[i] * factor);\r\n          point.y += Math.round(yDeltas[i] * factor);\r\n        }\r\n      } else {\r\n        let outPoints = origPoints.map(pt => pt.copy());\r\n        let hasDelta = glyphPoints.map(() => false);\r\n\r\n        for (let i = 0; i < points.length; i++) {\r\n          let idx = points[i];\r\n          if (idx < glyphPoints.length) {\r\n            let point = outPoints[idx];\r\n            hasDelta[idx] = true;\r\n\r\n            point.x += Math.round(xDeltas[i] * factor);\r\n            point.y += Math.round(yDeltas[i] * factor);\r\n          }\r\n        }\r\n\r\n        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);\r\n\r\n        for (let i = 0; i < glyphPoints.length; i++) {\r\n          let deltaX = outPoints[i].x - origPoints[i].x;\r\n          let deltaY = outPoints[i].y - origPoints[i].y;\r\n\r\n          glyphPoints[i].x += deltaX;\r\n          glyphPoints[i].y += deltaY;\r\n        }\r\n      }\r\n\r\n      offsetToData += tupleDataSize;\r\n      stream.pos = here;\r\n    }\r\n  }\r\n\r\n  decodePoints() {\r\n    let stream = this.font.stream;\r\n    let count = stream.readUInt8();\r\n\r\n    if (count & POINTS_ARE_WORDS) {\r\n      count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();\r\n    }\r\n\r\n    let points = new Uint16Array(count);\r\n    let i = 0;\r\n    let point = 0;\r\n    while (i < count) {\r\n      let run = stream.readUInt8();\r\n      let runCount = (run & POINT_RUN_COUNT_MASK) + 1;\r\n      let fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;\r\n\r\n      for (let j = 0; j < runCount && i < count; j++) {\r\n        point += fn.call(stream);\r\n        points[i++] = point;\r\n      }\r\n    }\r\n\r\n    return points;\r\n  }\r\n\r\n  decodeDeltas(count) {\r\n    let stream = this.font.stream;\r\n    let i = 0;\r\n    let deltas = new Int16Array(count);\r\n\r\n    while (i < count) {\r\n      let run = stream.readUInt8();\r\n      let runCount = (run & DELTA_RUN_COUNT_MASK) + 1;\r\n\r\n      if (run & DELTAS_ARE_ZERO) {\r\n        i += runCount;\r\n\r\n      } else {\r\n        let fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;\r\n        for (let j = 0; j < runCount && i < count; j++) {\r\n          deltas[i++] = fn.call(stream);\r\n        }\r\n      }\r\n    }\r\n\r\n    return deltas;\r\n  }\r\n\r\n  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {\r\n    let normalized = this.normalizedCoords;\r\n    let { gvar } = this.font;\r\n    let factor = 1;\r\n\r\n    for (let i = 0; i < gvar.axisCount; i++) {\r\n      if (tupleCoords[i] === 0) {\r\n        continue;\r\n      }\r\n\r\n      if (normalized[i] === 0) {\r\n        return 0;\r\n      }\r\n\r\n      if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {\r\n        if ((normalized[i] < Math.min(0, tupleCoords[i])) ||\r\n            (normalized[i] > Math.max(0, tupleCoords[i]))) {\r\n          return 0;\r\n        }\r\n\r\n        factor = (factor * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);\r\n      } else {\r\n        if ((normalized[i] < startCoords[i]) ||\r\n            (normalized[i] > endCoords[i])) {\r\n          return 0;\r\n\r\n        } else if (normalized[i] < tupleCoords[i]) {\r\n          factor = factor * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);\r\n\r\n        } else {\r\n          factor = factor * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);\r\n        }\r\n      }\r\n    }\r\n\r\n    return factor;\r\n  }\r\n\r\n  // Interpolates points without delta values.\r\n  // Needed for the Ø and Q glyphs in Skia.\r\n  // Algorithm from Freetype.\r\n  interpolateMissingDeltas(points, inPoints, hasDelta) {\r\n    if (points.length === 0) {\r\n      return;\r\n    }\r\n\r\n    let point = 0;\r\n    while (point < points.length) {\r\n      let firstPoint = point;\r\n\r\n      // find the end point of the contour\r\n      let endPoint = point;\r\n      let pt = points[endPoint];\r\n      while (!pt.endContour) {\r\n        pt = points[++endPoint];\r\n      }\r\n\r\n      // find the first point that has a delta\r\n      while (point <= endPoint && !hasDelta[point]) {\r\n        point++;\r\n      }\r\n\r\n      if (point > endPoint) {\r\n        continue;\r\n      }\r\n\r\n      let firstDelta = point;\r\n      let curDelta = point;\r\n      point++;\r\n\r\n      while (point <= endPoint) {\r\n        // find the next point with a delta, and interpolate intermediate points\r\n        if (hasDelta[point]) {\r\n          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);\r\n          curDelta = point;\r\n        }\r\n\r\n        point++;\r\n      }\r\n\r\n      // shift contour if we only have a single delta\r\n      if (curDelta === firstDelta) {\r\n        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);\r\n      } else {\r\n        // otherwise, handle the remaining points at the end and beginning of the contour\r\n        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);\r\n\r\n        if (firstDelta > 0) {\r\n          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);\r\n        }\r\n      }\r\n\r\n      point = endPoint + 1;\r\n    }\r\n  }\r\n\r\n  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {\r\n    if (p1 > p2) {\r\n      return;\r\n    }\r\n\r\n    let iterable = ['x', 'y'];\r\n    for (let i = 0; i < iterable.length; i++) {\r\n      let k = iterable[i];\r\n      if (inPoints[ref1][k] > inPoints[ref2][k]) {\r\n        var p = ref1;\r\n        ref1 = ref2;\r\n        ref2 = p;\r\n      }\r\n\r\n      let in1 = inPoints[ref1][k];\r\n      let in2 = inPoints[ref2][k];\r\n      let out1 = outPoints[ref1][k];\r\n      let out2 = outPoints[ref2][k];\r\n\r\n      // If the reference points have the same coordinate but different\r\n      // delta, inferred delta is zero.  Otherwise interpolate.\r\n      if (in1 !== in2 || out1 === out2) {\r\n        let scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);\r\n\r\n        for (let p = p1; p <= p2; p++) {\r\n          let out = inPoints[p][k];\r\n\r\n          if (out <= in1) {\r\n            out += out1 - in1;\r\n          } else if (out >= in2) {\r\n            out += out2 - in2;\r\n          } else {\r\n            out = out1 + (out - in1) * scale;\r\n          }\r\n\r\n          outPoints[p][k] = out;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  deltaShift(p1, p2, ref, inPoints, outPoints) {\r\n    let deltaX = outPoints[ref].x - inPoints[ref].x;\r\n    let deltaY = outPoints[ref].y - inPoints[ref].y;\r\n\r\n    if (deltaX === 0 && deltaY === 0) {\r\n      return;\r\n    }\r\n\r\n    for (let p = p1; p <= p2; p++) {\r\n      if (p !== ref) {\r\n        outPoints[p].x += deltaX;\r\n        outPoints[p].y += deltaY;\r\n      }\r\n    }\r\n  }\r\n\r\n  getAdvanceAdjustment(gid, table) {\r\n    let outerIndex, innerIndex;\r\n\r\n    if (table.advanceWidthMapping) {\r\n      let idx = gid;\r\n      if (idx >= table.advanceWidthMapping.mapCount) {\r\n        idx = table.advanceWidthMapping.mapCount - 1;\r\n      }\r\n\r\n      let entryFormat = table.advanceWidthMapping.entryFormat;\r\n      ({outerIndex, innerIndex} = table.advanceWidthMapping.mapData[idx]);\r\n    } else {\r\n      outerIndex = 0;\r\n      innerIndex = gid;\r\n    }\r\n\r\n    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);\r\n  }\r\n\r\n  // See pseudo code from `Font Variations Overview'\r\n  // in the OpenType specification.\r\n  getDelta(itemStore, outerIndex, innerIndex) {\r\n    if (outerIndex >= itemStore.itemVariationData.length) {\r\n      return 0;\r\n    }\r\n\r\n    let varData = itemStore.itemVariationData[outerIndex];\r\n    if (innerIndex >= varData.deltaSets.length) {\r\n      return 0;\r\n    }\r\n\r\n    let deltaSet = varData.deltaSets[innerIndex];\r\n    let blendVector = this.getBlendVector(itemStore, outerIndex);\r\n    let netAdjustment = 0;\r\n\r\n    for (let master = 0; master < varData.regionIndexCount; master++) {\r\n      netAdjustment += deltaSet.deltas[master] * blendVector[master];\r\n    }\r\n\r\n    return netAdjustment;\r\n  }\r\n\r\n  getBlendVector(itemStore, outerIndex) {\r\n    let varData = itemStore.itemVariationData[outerIndex];\r\n    if (this.blendVectors.has(varData)) {\r\n      return this.blendVectors.get(varData);\r\n    }\r\n\r\n    let normalizedCoords = this.normalizedCoords;\r\n    let blendVector = [];\r\n\r\n    // outer loop steps through master designs to be blended\r\n    for (let master = 0; master < varData.regionIndexCount; master++) {\r\n      let scalar = 1;\r\n      let regionIndex = varData.regionIndexes[master];\r\n      let axes = itemStore.variationRegionList.variationRegions[regionIndex];\r\n\r\n      // inner loop steps through axes in this region\r\n      for (let j = 0; j < axes.length; j++) {\r\n        let axis = axes[j];\r\n        let axisScalar;\r\n\r\n        // compute the scalar contribution of this axis\r\n        // ignore invalid ranges\r\n        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {\r\n          axisScalar = 1;\r\n\r\n        } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {\r\n          axisScalar = 1;\r\n\r\n        // peak of 0 means ignore this axis\r\n        } else if (axis.peakCoord === 0) {\r\n          axisScalar = 1;\r\n\r\n        // ignore this region if coords are out of range\r\n        } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {\r\n          axisScalar = 0;\r\n\r\n        // calculate a proportional factor\r\n        } else {\r\n          if (normalizedCoords[j] === axis.peakCoord) {\r\n            axisScalar = 1;\r\n          } else if (normalizedCoords[j] < axis.peakCoord) {\r\n            axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) /\r\n              (axis.peakCoord - axis.startCoord + Number.EPSILON);\r\n          } else {\r\n            axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) /\r\n              (axis.endCoord - axis.peakCoord + Number.EPSILON);\r\n          }\r\n        }\r\n\r\n        // take product of all the axis scalars\r\n        scalar *= axisScalar;\r\n      }\r\n\r\n      blendVector[master] = scalar;\r\n    }\r\n\r\n    this.blendVectors.set(varData, blendVector);\r\n    return blendVector;\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nconst resolved = Promise.resolve();\r\n\r\nexport default class Subset {\r\n  constructor(font) {\r\n    this.font = font;\r\n    this.glyphs = [];\r\n    this.mapping = {};\r\n\r\n    // always include the missing glyph\r\n    this.includeGlyph(0);\r\n  }\r\n\r\n  includeGlyph(glyph) {\r\n    if (typeof glyph === 'object') {\r\n      glyph = glyph.id;\r\n    }\r\n\r\n    if (this.mapping[glyph] == null) {\r\n      this.glyphs.push(glyph);\r\n      this.mapping[glyph] = this.glyphs.length - 1;\r\n    }\r\n\r\n    return this.mapping[glyph];\r\n  }\r\n\r\n  encodeStream() {\r\n    let s = new r.EncodeStream();\r\n\r\n    resolved.then(() => {\r\n      this.encode(s);\r\n      return s.end();\r\n    });\r\n\r\n    return s;\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// Flags for simple glyphs\r\nconst ON_CURVE        = 1 << 0;\r\nconst X_SHORT_VECTOR  = 1 << 1;\r\nconst Y_SHORT_VECTOR  = 1 << 2;\r\nconst REPEAT          = 1 << 3;\r\nconst SAME_X          = 1 << 4;\r\nconst SAME_Y          = 1 << 5;\r\n\r\nclass Point {\r\n  static size(val) {\r\n    return val >= 0 && val <= 255 ? 1 : 2;\r\n  }\r\n\r\n  static encode(stream, value) {\r\n    if (value >= 0 && value <= 255) {\r\n      stream.writeUInt8(value);\r\n    } else {\r\n      stream.writeInt16BE(value);\r\n    }\r\n  }\r\n}\r\n\r\nlet Glyf = new r.Struct({\r\n  numberOfContours: r.int16, // if negative, this is a composite glyph\r\n  xMin: r.int16,\r\n  yMin: r.int16,\r\n  xMax: r.int16,\r\n  yMax: r.int16,\r\n  endPtsOfContours: new r.Array(r.uint16, 'numberOfContours'),\r\n  instructions: new r.Array(r.uint8, r.uint16),\r\n  flags: new r.Array(r.uint8, 0),\r\n  xPoints: new r.Array(Point, 0),\r\n  yPoints: new r.Array(Point, 0)\r\n});\r\n\r\n/**\r\n * Encodes TrueType glyph outlines\r\n */\r\nexport default class TTFGlyphEncoder {\r\n  encodeSimple(path, instructions = []) {\r\n    let endPtsOfContours = [];\r\n    let xPoints = [];\r\n    let yPoints = [];\r\n    let flags = [];\r\n    let same = 0;\r\n    let lastX = 0, lastY = 0, lastFlag = 0;\r\n    let pointCount = 0;\r\n\r\n    for (let i = 0; i < path.commands.length; i++) {\r\n      let c = path.commands[i];\r\n\r\n      for (let j = 0; j < c.args.length; j += 2) {\r\n        let x = c.args[j];\r\n        let y = c.args[j + 1];\r\n        let flag = 0;\r\n\r\n        // If the ending point of a quadratic curve is the midpoint\r\n        // between the control point and the control point of the next\r\n        // quadratic curve, we can omit the ending point.\r\n        if (c.command === 'quadraticCurveTo' && j === 2) {\r\n          let next = path.commands[i + 1];\r\n          if (next && next.command === 'quadraticCurveTo') {\r\n            let midX = (lastX + next.args[0]) / 2;\r\n            let midY = (lastY + next.args[1]) / 2;\r\n\r\n            if (x === midX && y === midY) {\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n\r\n        // All points except control points are on curve.\r\n        if (!(c.command === 'quadraticCurveTo' && j === 0)) {\r\n          flag |= ON_CURVE;\r\n        }\r\n\r\n        flag = this._encodePoint(x, lastX, xPoints, flag, X_SHORT_VECTOR, SAME_X);\r\n        flag = this._encodePoint(y, lastY, yPoints, flag, Y_SHORT_VECTOR, SAME_Y);\r\n\r\n        if (flag === lastFlag && same < 255) {\r\n          flags[flags.length - 1] |= REPEAT;\r\n          same++;\r\n        } else {\r\n          if (same > 0) {\r\n            flags.push(same);\r\n            same = 0;\r\n          }\r\n\r\n          flags.push(flag);\r\n          lastFlag = flag;\r\n        }\r\n\r\n        lastX = x;\r\n        lastY = y;\r\n        pointCount++;\r\n      }\r\n\r\n      if (c.command === 'closePath') {\r\n        endPtsOfContours.push(pointCount - 1);\r\n      }\r\n    }\r\n\r\n    // Close the path if the last command didn't already\r\n    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== 'closePath') {\r\n      endPtsOfContours.push(pointCount - 1);\r\n    }\r\n\r\n    let bbox = path.bbox;\r\n    let glyf = {\r\n      numberOfContours: endPtsOfContours.length,\r\n      xMin: bbox.minX,\r\n      yMin: bbox.minY,\r\n      xMax: bbox.maxX,\r\n      yMax: bbox.maxY,\r\n      endPtsOfContours: endPtsOfContours,\r\n      instructions: instructions,\r\n      flags: flags,\r\n      xPoints: xPoints,\r\n      yPoints: yPoints\r\n    };\r\n\r\n    let size = Glyf.size(glyf);\r\n    let tail = 4 - (size % 4);\r\n\r\n    let stream = new r.EncodeStream(size + tail);\r\n    Glyf.encode(stream, glyf);\r\n\r\n    // Align to 4-byte length\r\n    if (tail !== 0) {\r\n      stream.fill(0, tail);\r\n    }\r\n\r\n    return stream.buffer;\r\n  }\r\n\r\n  _encodePoint(value, last, points, flag, shortFlag, sameFlag) {\r\n    let diff = value - last;\r\n\r\n    if (value === last) {\r\n      flag |= sameFlag;\r\n    } else {\r\n      if (-255 <= diff && diff <= 255) {\r\n        flag |= shortFlag;\r\n        if (diff < 0) {\r\n          diff = -diff;\r\n        } else {\r\n          flag |= sameFlag;\r\n        }\r\n      }\r\n\r\n      points.push(diff);\r\n    }\r\n\r\n    return flag;\r\n  }\r\n}\r\n","import cloneDeep from 'clone';\r\nimport Subset from './Subset';\r\nimport Directory from '../tables/directory';\r\nimport Tables from '../tables';\r\nimport TTFGlyphEncoder from '../glyph/TTFGlyphEncoder';\r\n\r\nexport default class TTFSubset extends Subset {\r\n  constructor(font) {\r\n    super(font);\r\n    this.glyphEncoder = new TTFGlyphEncoder;\r\n  }\r\n\r\n  _addGlyph(gid) {\r\n    let glyph = this.font.getGlyph(gid);\r\n    let glyf = glyph._decode();\r\n\r\n    // get the offset to the glyph from the loca table\r\n    let curOffset = this.font.loca.offsets[gid];\r\n    let nextOffset = this.font.loca.offsets[gid + 1];\r\n\r\n    let stream = this.font._getTableStream('glyf');\r\n    stream.pos += curOffset;\r\n\r\n    let buffer = stream.readBuffer(nextOffset - curOffset);\r\n\r\n    // if it is a compound glyph, include its components\r\n    if (glyf && glyf.numberOfContours < 0) {\r\n      buffer = Buffer.from(buffer);\r\n      for (let component of glyf.components) {\r\n        gid = this.includeGlyph(component.glyphID);\r\n        buffer.writeUInt16BE(gid, component.pos);\r\n      }\r\n    } else if (glyf && this.font._variationProcessor) {\r\n      // If this is a TrueType variation glyph, re-encode the path\r\n      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);\r\n    }\r\n\r\n    this.glyf.push(buffer);\r\n    this.loca.offsets.push(this.offset);\r\n\r\n    this.hmtx.metrics.push({\r\n      advance: glyph.advanceWidth,\r\n      bearing: glyph._getMetrics().leftBearing\r\n    });\r\n\r\n    this.offset += buffer.length;\r\n    return this.glyf.length - 1;\r\n  }\r\n\r\n  encode(stream) {\r\n    // tables required by PDF spec:\r\n    //   head, hhea, loca, maxp, cvt , prep, glyf, hmtx, fpgm\r\n    //\r\n    // additional tables required for standalone fonts:\r\n    //   name, cmap, OS/2, post\r\n\r\n    this.glyf = [];\r\n    this.offset = 0;\r\n    this.loca = {\r\n      offsets: [],\r\n      version: this.font.loca.version\r\n    };\r\n\r\n    this.hmtx = {\r\n      metrics: [],\r\n      bearings: []\r\n    };\r\n\r\n    // include all the glyphs\r\n    // not using a for loop because we need to support adding more\r\n    // glyphs to the array as we go, and CoffeeScript caches the length.\r\n    let i = 0;\r\n    while (i < this.glyphs.length) {\r\n      this._addGlyph(this.glyphs[i++]);\r\n    }\r\n\r\n    let maxp = cloneDeep(this.font.maxp);\r\n    maxp.numGlyphs = this.glyf.length;\r\n\r\n    this.loca.offsets.push(this.offset);\r\n\r\n    let head = cloneDeep(this.font.head);\r\n    head.indexToLocFormat = this.loca.version;\r\n\r\n    let hhea = cloneDeep(this.font.hhea);\r\n    hhea.numberOfMetrics = this.hmtx.metrics.length;\r\n\r\n    // map = []\r\n    // for index in [0...256]\r\n    //     if index < @numGlyphs\r\n    //         map[index] = index\r\n    //     else\r\n    //         map[index] = 0\r\n    //\r\n    // cmapTable =\r\n    //     version: 0\r\n    //     length: 262\r\n    //     language: 0\r\n    //     codeMap: map\r\n    //\r\n    // cmap =\r\n    //     version: 0\r\n    //     numSubtables: 1\r\n    //     tables: [\r\n    //         platformID: 1\r\n    //         encodingID: 0\r\n    //         table: cmapTable\r\n    //     ]\r\n\r\n    // TODO: subset prep, cvt, fpgm?\r\n    Directory.encode(stream, {\r\n      tables: {\r\n        head,\r\n        hhea,\r\n        loca: this.loca,\r\n        maxp,\r\n        'cvt ': this.font['cvt '],\r\n        prep: this.font.prep,\r\n        glyf: this.glyf,\r\n        hmtx: this.hmtx,\r\n        fpgm: this.font.fpgm\r\n\r\n        // name: clone @font.name\r\n        // 'OS/2': clone @font['OS/2']\r\n        // post: clone @font.post\r\n        // cmap: cmap\r\n      }\r\n    });\r\n  }\r\n}\r\n","import Subset from './Subset';\r\nimport CFFTop from '../cff/CFFTop';\r\nimport CFFPrivateDict from '../cff/CFFPrivateDict';\r\nimport standardStrings from '../cff/CFFStandardStrings';\r\n\r\nexport default class CFFSubset extends Subset {\r\n  constructor(font) {\r\n    super(font);\r\n\r\n    this.cff = this.font['CFF '];\r\n    if (!this.cff) {\r\n      throw new Error('Not a CFF Font');\r\n    }\r\n  }\r\n\r\n  subsetCharstrings() {\r\n    this.charstrings = [];\r\n    let gsubrs = {};\r\n\r\n    for (let gid of this.glyphs) {\r\n      this.charstrings.push(this.cff.getCharString(gid));\r\n\r\n      let glyph = this.font.getGlyph(gid);\r\n      let path = glyph.path; // this causes the glyph to be parsed\r\n\r\n      for (let subr in glyph._usedGsubrs) {\r\n        gsubrs[subr] = true;\r\n      }\r\n    }\r\n\r\n    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);\r\n  }\r\n\r\n  subsetSubrs(subrs, used) {\r\n    let res = [];\r\n    for (let i = 0; i < subrs.length; i++) {\r\n      let subr = subrs[i];\r\n      if (used[i]) {\r\n        this.cff.stream.pos = subr.offset;\r\n        res.push(this.cff.stream.readBuffer(subr.length));\r\n      } else {\r\n        res.push(Buffer.from([11])); // return\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  subsetFontdict(topDict) {\r\n    topDict.FDArray = [];\r\n    topDict.FDSelect = {\r\n      version: 0,\r\n      fds: []\r\n    };\r\n\r\n    let used_fds = {};\r\n    let used_subrs = [];\r\n    let fd_select = {};\r\n    for (let gid of this.glyphs) {\r\n      let fd = this.cff.fdForGlyph(gid);\r\n      if (fd == null) {\r\n        continue;\r\n      }\r\n\r\n      if (!used_fds[fd]) {\r\n        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));\r\n        used_subrs.push({});\r\n        fd_select[fd] = topDict.FDArray.length - 1;\r\n      }\r\n\r\n      used_fds[fd] = true;\r\n      topDict.FDSelect.fds.push(fd_select[fd]);\r\n\r\n      let glyph = this.font.getGlyph(gid);\r\n      let path = glyph.path; // this causes the glyph to be parsed\r\n      for (let subr in glyph._usedSubrs) {\r\n        used_subrs[fd_select[fd]][subr] = true;\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < topDict.FDArray.length; i++) {\r\n      let dict = topDict.FDArray[i];\r\n      delete dict.FontName;\r\n      if (dict.Private && dict.Private.Subrs) {\r\n        dict.Private = Object.assign({}, dict.Private);\r\n        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  createCIDFontdict(topDict) {\r\n    let used_subrs = {};\r\n    for (let gid of this.glyphs) {\r\n      let glyph = this.font.getGlyph(gid);\r\n      let path = glyph.path; // this causes the glyph to be parsed\r\n\r\n      for (let subr in glyph._usedSubrs) {\r\n        used_subrs[subr] = true;\r\n      }\r\n    }\r\n\r\n    let privateDict = Object.assign({}, this.cff.topDict.Private);\r\n    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) {\r\n      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);\r\n    }\r\n\r\n    topDict.FDArray = [{ Private: privateDict }];\r\n    return topDict.FDSelect = {\r\n      version: 3,\r\n      nRanges: 1,\r\n      ranges: [{ first: 0, fd: 0 }],\r\n      sentinel: this.charstrings.length\r\n    };\r\n  }\r\n\r\n  addString(string) {\r\n    if (!string) {\r\n      return null;\r\n    }\r\n\r\n    if (!this.strings) {\r\n      this.strings = [];\r\n    }\r\n\r\n    this.strings.push(string);\r\n    return standardStrings.length + this.strings.length - 1;\r\n  }\r\n\r\n  encode(stream) {\r\n    this.subsetCharstrings();\r\n\r\n    let charset = {\r\n      version: this.charstrings.length > 255 ? 2 : 1,\r\n      ranges: [{ first: 1, nLeft: this.charstrings.length - 2 }]\r\n    };\r\n\r\n    let topDict = Object.assign({}, this.cff.topDict);\r\n    topDict.Private = null;\r\n    topDict.charset = charset;\r\n    topDict.Encoding = null;\r\n    topDict.CharStrings = this.charstrings;\r\n\r\n    for (let key of ['version', 'Notice', 'Copyright', 'FullName', 'FamilyName', 'Weight', 'PostScript', 'BaseFontName', 'FontName']) {\r\n      topDict[key] = this.addString(this.cff.string(topDict[key]));\r\n    }\r\n\r\n    topDict.ROS = [this.addString('Adobe'), this.addString('Identity'), 0];\r\n    topDict.CIDCount = this.charstrings.length;\r\n\r\n    if (this.cff.isCIDFont) {\r\n      this.subsetFontdict(topDict);\r\n    } else {\r\n      this.createCIDFontdict(topDict);\r\n    }\r\n\r\n    let top = {\r\n      version: 1,\r\n      hdrSize: this.cff.hdrSize,\r\n      offSize: 4,\r\n      header: this.cff.header,\r\n      nameIndex: [this.cff.postscriptName],\r\n      topDictIndex: [topDict],\r\n      stringIndex: this.strings,\r\n      globalSubrIndex: this.gsubrs\r\n    };\r\n\r\n    CFFTop.encode(stream, top);\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\nimport { cache } from './decorators';\r\nimport fontkit from './base';\r\nimport Directory from './tables/directory';\r\nimport tables from './tables';\r\nimport CmapProcessor from './CmapProcessor';\r\nimport LayoutEngine from './layout/LayoutEngine';\r\nimport TTFGlyph from './glyph/TTFGlyph';\r\nimport CFFGlyph from './glyph/CFFGlyph';\r\nimport SBIXGlyph from './glyph/SBIXGlyph';\r\nimport COLRGlyph from './glyph/COLRGlyph';\r\nimport GlyphVariationProcessor from './glyph/GlyphVariationProcessor';\r\nimport TTFSubset from './subset/TTFSubset';\r\nimport CFFSubset from './subset/CFFSubset';\r\nimport BBox from './glyph/BBox';\r\n\r\n/**\r\n * This is the base class for all SFNT-based font formats in fontkit.\r\n * It supports TrueType, and PostScript glyphs, and several color glyph formats.\r\n */\r\nexport default class TTFFont {\r\n  static probe(buffer) {\r\n    let format = buffer.toString('ascii', 0, 4);\r\n    return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);\r\n  }\r\n\r\n  constructor(stream, variationCoords = null) {\r\n    this.defaultLanguage = null;\r\n    this.stream = stream;\r\n    this.variationCoords = variationCoords;\r\n\r\n    this._directoryPos = this.stream.pos;\r\n    this._tables = {};\r\n    this._glyphs = {};\r\n    this._decodeDirectory();\r\n\r\n    // define properties for each table to lazily parse\r\n    for (let tag in this.directory.tables) {\r\n      let table = this.directory.tables[tag];\r\n      if (tables[tag] && table.length > 0) {\r\n        Object.defineProperty(this, tag, {\r\n          get: this._getTable.bind(this, table)\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  setDefaultLanguage(lang = null) {\r\n    this.defaultLanguage = lang;\r\n  }\r\n\r\n  _getTable(table) {\r\n    if (!(table.tag in this._tables)) {\r\n      try {\r\n        this._tables[table.tag] = this._decodeTable(table);\r\n      } catch (e) {\r\n        if (fontkit.logErrors) {\r\n          console.error(`Error decoding table ${table.tag}`);\r\n          console.error(e.stack);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this._tables[table.tag];\r\n  }\r\n\r\n  _getTableStream(tag) {\r\n    let table = this.directory.tables[tag];\r\n    if (table) {\r\n      this.stream.pos = table.offset;\r\n      return this.stream;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _decodeDirectory() {\r\n    return this.directory = Directory.decode(this.stream, {_startOffset: 0});\r\n  }\r\n\r\n  _decodeTable(table) {\r\n    let pos = this.stream.pos;\r\n\r\n    let stream = this._getTableStream(table.tag);\r\n    let result = tables[table.tag].decode(stream, this, table.length);\r\n\r\n    this.stream.pos = pos;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets a string from the font's `name` table\r\n   * `lang` is a BCP-47 language code.\r\n   * @return {string}\r\n   */\r\n  getName(key, lang = this.defaultLanguage || fontkit.defaultLanguage) {\r\n    let record = this.name && this.name.records[key];\r\n    if (record) {\r\n      // Attempt to retrieve the entry, depending on which translation is available:\r\n      return (\r\n          record[lang]\r\n          || record[this.defaultLanguage]\r\n          || record[fontkit.defaultLanguage]\r\n          || record['en']\r\n          || record[Object.keys(record)[0]] // Seriously, ANY language would be fine\r\n          || null\r\n      );\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * The unique PostScript name for this font, e.g. \"Helvetica-Bold\"\r\n   * @type {string}\r\n   */\r\n  get postscriptName() {\r\n    return this.getName('postscriptName');\r\n  }\r\n\r\n  /**\r\n   * The font's full name, e.g. \"Helvetica Bold\"\r\n   * @type {string}\r\n   */\r\n  get fullName() {\r\n    return this.getName('fullName');\r\n  }\r\n\r\n  /**\r\n   * The font's family name, e.g. \"Helvetica\"\r\n   * @type {string}\r\n   */\r\n  get familyName() {\r\n    return this.getName('fontFamily');\r\n  }\r\n\r\n  /**\r\n   * The font's sub-family, e.g. \"Bold\".\r\n   * @type {string}\r\n   */\r\n  get subfamilyName() {\r\n    return this.getName('fontSubfamily');\r\n  }\r\n\r\n  /**\r\n   * The font's copyright information\r\n   * @type {string}\r\n   */\r\n  get copyright() {\r\n    return this.getName('copyright');\r\n  }\r\n\r\n  /**\r\n   * The font's version number\r\n   * @type {string}\r\n   */\r\n  get version() {\r\n    return this.getName('version');\r\n  }\r\n\r\n  /**\r\n   * The font’s [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))\r\n   * @type {number}\r\n   */\r\n  get ascent() {\r\n    return this.hhea.ascent;\r\n  }\r\n\r\n  /**\r\n   * The font’s [descender](https://en.wikipedia.org/wiki/Descender)\r\n   * @type {number}\r\n   */\r\n  get descent() {\r\n    return this.hhea.descent;\r\n  }\r\n\r\n  /**\r\n   * The amount of space that should be included between lines\r\n   * @type {number}\r\n   */\r\n  get lineGap() {\r\n    return this.hhea.lineGap;\r\n  }\r\n\r\n  /**\r\n   * The offset from the normal underline position that should be used\r\n   * @type {number}\r\n   */\r\n  get underlinePosition() {\r\n    return this.post.underlinePosition;\r\n  }\r\n\r\n  /**\r\n   * The weight of the underline that should be used\r\n   * @type {number}\r\n   */\r\n  get underlineThickness() {\r\n    return this.post.underlineThickness;\r\n  }\r\n\r\n  /**\r\n   * If this is an italic font, the angle the cursor should be drawn at to match the font design\r\n   * @type {number}\r\n   */\r\n  get italicAngle() {\r\n    return this.post.italicAngle;\r\n  }\r\n\r\n  /**\r\n   * The height of capital letters above the baseline.\r\n   * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.\r\n   * @type {number}\r\n   */\r\n  get capHeight() {\r\n    let os2 = this['OS/2'];\r\n    return os2 ? os2.capHeight : this.ascent;\r\n  }\r\n\r\n  /**\r\n   * The height of lower case letters in the font.\r\n   * See [here](https://en.wikipedia.org/wiki/X-height) for more details.\r\n   * @type {number}\r\n   */\r\n  get xHeight() {\r\n    let os2 = this['OS/2'];\r\n    return os2 ? os2.xHeight : 0;\r\n  }\r\n\r\n  /**\r\n   * The number of glyphs in the font.\r\n   * @type {number}\r\n   */\r\n  get numGlyphs() {\r\n    return this.maxp.numGlyphs;\r\n  }\r\n\r\n  /**\r\n   * The size of the font’s internal coordinate grid\r\n   * @type {number}\r\n   */\r\n  get unitsPerEm() {\r\n    return this.head.unitsPerEm;\r\n  }\r\n\r\n  /**\r\n   * The font’s bounding box, i.e. the box that encloses all glyphs in the font.\r\n   * @type {BBox}\r\n   */\r\n  @cache\r\n  get bbox() {\r\n    return Object.freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));\r\n  }\r\n\r\n  @cache\r\n  get _cmapProcessor() {\r\n    return new CmapProcessor(this.cmap);\r\n  }\r\n\r\n  /**\r\n   * An array of all of the unicode code points supported by the font.\r\n   * @type {number[]}\r\n   */\r\n  @cache\r\n  get characterSet() {\r\n    return this._cmapProcessor.getCharacterSet();\r\n  }\r\n\r\n  /**\r\n   * Returns whether there is glyph in the font for the given unicode code point.\r\n   *\r\n   * @param {number} codePoint\r\n   * @return {boolean}\r\n   */\r\n  hasGlyphForCodePoint(codePoint) {\r\n    return !!this._cmapProcessor.lookup(codePoint);\r\n  }\r\n\r\n  /**\r\n   * Maps a single unicode code point to a Glyph object.\r\n   * Does not perform any advanced substitutions (there is no context to do so).\r\n   *\r\n   * @param {number} codePoint\r\n   * @return {Glyph}\r\n   */\r\n  glyphForCodePoint(codePoint) {\r\n    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);\r\n  }\r\n\r\n  /**\r\n   * Returns an array of Glyph objects for the given string.\r\n   * This is only a one-to-one mapping from characters to glyphs.\r\n   * For most uses, you should use font.layout (described below), which\r\n   * provides a much more advanced mapping supporting AAT and OpenType shaping.\r\n   *\r\n   * @param {string} string\r\n   * @return {Glyph[]}\r\n   */\r\n  glyphsForString(string) {\r\n    let glyphs = [];\r\n    let len = string.length;\r\n    let idx = 0;\r\n    let last = -1;\r\n    let state = -1;\r\n\r\n    while (idx <= len) {\r\n      let code = 0;\r\n      let nextState = 0;\r\n\r\n      if (idx < len) {\r\n        // Decode the next codepoint from UTF 16\r\n        code = string.charCodeAt(idx++);\r\n        if (0xd800 <= code && code <= 0xdbff && idx < len) {\r\n          let next = string.charCodeAt(idx);\r\n          if (0xdc00 <= next && next <= 0xdfff) {\r\n            idx++;\r\n            code = ((code & 0x3ff) << 10) + (next & 0x3ff) + 0x10000;\r\n          }\r\n        }\r\n\r\n        // Compute the next state: 1 if the next codepoint is a variation selector, 0 otherwise.\r\n        nextState = ((0xfe00 <= code && code <= 0xfe0f) || (0xe0100 <= code && code <= 0xe01ef)) ? 1 : 0;\r\n      } else {\r\n        idx++;\r\n      }\r\n\r\n      if (state === 0 && nextState === 1) {\r\n        // Variation selector following normal codepoint.\r\n        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [last, code]));\r\n      } else if (state === 0 && nextState === 0) {\r\n        // Normal codepoint following normal codepoint.\r\n        glyphs.push(this.glyphForCodePoint(last));\r\n      }\r\n\r\n      last = code;\r\n      state = nextState;\r\n    }\r\n\r\n    return glyphs;\r\n  }\r\n\r\n  @cache\r\n  get _layoutEngine() {\r\n    return new LayoutEngine(this);\r\n  }\r\n\r\n  /**\r\n   * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.\r\n   *\r\n   * @param {string} string\r\n   * @param {string[]} [userFeatures]\r\n   * @param {string} [script]\r\n   * @param {string} [language]\r\n   * @param {string} [direction]\r\n   * @return {GlyphRun}\r\n   */\r\n  layout(string, userFeatures, script, language, direction) {\r\n    return this._layoutEngine.layout(string, userFeatures, script, language, direction);\r\n  }\r\n\r\n  /**\r\n   * Returns an array of strings that map to the given glyph id.\r\n   * @param {number} gid - glyph id\r\n   */\r\n  stringsForGlyph(gid) {\r\n    return this._layoutEngine.stringsForGlyph(gid);\r\n  }\r\n\r\n  /**\r\n   * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)\r\n   * (or mapped AAT tags) supported by the font.\r\n   * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.\r\n   * If this is an AAT font, the OpenType feature tags are mapped to AAT features.\r\n   *\r\n   * @type {string[]}\r\n   */\r\n  get availableFeatures() {\r\n    return this._layoutEngine.getAvailableFeatures();\r\n  }\r\n\r\n  getAvailableFeatures(script, language) {\r\n    return this._layoutEngine.getAvailableFeatures(script, language);\r\n  }\r\n\r\n  _getBaseGlyph(glyph, characters = []) {\r\n    if (!this._glyphs[glyph]) {\r\n      if (this.directory.tables.glyf) {\r\n        this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);\r\n\r\n      } else if (this.directory.tables['CFF '] || this.directory.tables.CFF2) {\r\n        this._glyphs[glyph] = new CFFGlyph(glyph, characters, this);\r\n      }\r\n    }\r\n\r\n    return this._glyphs[glyph] || null;\r\n  }\r\n\r\n  /**\r\n   * Returns a glyph object for the given glyph id.\r\n   * You can pass the array of code points this glyph represents for\r\n   * your use later, and it will be stored in the glyph object.\r\n   *\r\n   * @param {number} glyph\r\n   * @param {number[]} characters\r\n   * @return {Glyph}\r\n   */\r\n  getGlyph(glyph, characters = []) {\r\n    if (!this._glyphs[glyph]) {\r\n      if (this.directory.tables.sbix) {\r\n        this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this);\r\n\r\n      } else if ((this.directory.tables.COLR) && (this.directory.tables.CPAL)) {\r\n        this._glyphs[glyph] = new COLRGlyph(glyph, characters, this);\r\n\r\n      } else {\r\n        this._getBaseGlyph(glyph, characters);\r\n      }\r\n    }\r\n\r\n    return this._glyphs[glyph] || null;\r\n  }\r\n\r\n  /**\r\n   * Returns a Subset for this font.\r\n   * @return {Subset}\r\n   */\r\n  createSubset() {\r\n    if (this.directory.tables['CFF ']) {\r\n      return new CFFSubset(this);\r\n    }\r\n\r\n    return new TTFSubset(this);\r\n  }\r\n\r\n  /**\r\n   * Returns an object describing the available variation axes\r\n   * that this font supports. Keys are setting tags, and values\r\n   * contain the axis name, range, and default value.\r\n   *\r\n   * @type {object}\r\n   */\r\n  @cache\r\n  get variationAxes() {\r\n    let res = {};\r\n    if (!this.fvar) {\r\n      return res;\r\n    }\r\n\r\n    for (let axis of this.fvar.axis) {\r\n      res[axis.axisTag.trim()] = {\r\n        name: axis.name.en,\r\n        min: axis.minValue,\r\n        default: axis.defaultValue,\r\n        max: axis.maxValue\r\n      };\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Returns an object describing the named variation instances\r\n   * that the font designer has specified. Keys are variation names\r\n   * and values are the variation settings for this instance.\r\n   *\r\n   * @type {object}\r\n   */\r\n  @cache\r\n  get namedVariations() {\r\n    let res = {};\r\n    if (!this.fvar) {\r\n      return res;\r\n    }\r\n\r\n    for (let instance of this.fvar.instance) {\r\n      let settings = {};\r\n      for (let i = 0; i < this.fvar.axis.length; i++) {\r\n        let axis = this.fvar.axis[i];\r\n        settings[axis.axisTag.trim()] = instance.coord[i];\r\n      }\r\n\r\n      res[instance.name.en] = settings;\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Returns a new font with the given variation settings applied.\r\n   * Settings can either be an instance name, or an object containing\r\n   * variation tags as specified by the `variationAxes` property.\r\n   *\r\n   * @param {object} settings\r\n   * @return {TTFFont}\r\n   */\r\n  getVariation(settings) {\r\n    if (!(this.directory.tables.fvar && ((this.directory.tables.gvar && this.directory.tables.glyf) || this.directory.tables.CFF2))) {\r\n      throw new Error('Variations require a font with the fvar, gvar and glyf, or CFF2 tables.');\r\n    }\r\n\r\n    if (typeof settings === 'string') {\r\n      settings = this.namedVariations[settings];\r\n    }\r\n\r\n    if (typeof settings !== 'object') {\r\n      throw new Error('Variation settings must be either a variation name or settings object.');\r\n    }\r\n\r\n    // normalize the coordinates\r\n    let coords = this.fvar.axis.map((axis, i) => {\r\n      let axisTag = axis.axisTag.trim();\r\n      if (axisTag in settings) {\r\n        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));\r\n      } else {\r\n        return axis.defaultValue;\r\n      }\r\n    });\r\n\r\n    let stream = new r.DecodeStream(this.stream.buffer);\r\n    stream.pos = this._directoryPos;\r\n\r\n    let font = new TTFFont(stream, coords);\r\n    font._tables = this._tables;\r\n\r\n    return font;\r\n  }\r\n\r\n  @cache\r\n  get _variationProcessor() {\r\n    if (!this.fvar) {\r\n      return null;\r\n    }\r\n\r\n    let variationCoords = this.variationCoords;\r\n\r\n    // Ignore if no variation coords and not CFF2\r\n    if (!variationCoords && !this.CFF2) {\r\n      return null;\r\n    }\r\n\r\n    if (!variationCoords) {\r\n      variationCoords = this.fvar.axis.map(axis => axis.defaultValue);\r\n    }\r\n\r\n    return new GlyphVariationProcessor(this, variationCoords);\r\n  }\r\n\r\n  // Standardized format plugin API\r\n  getFont(name) {\r\n    return this.getVariation(name);\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\nimport tables from './';\r\n\r\nlet WOFFDirectoryEntry = new r.Struct({\r\n  tag:          new r.String(4),\r\n  offset:       new r.Pointer(r.uint32, 'void', {type: 'global'}),\r\n  compLength:   r.uint32,\r\n  length:       r.uint32,\r\n  origChecksum: r.uint32\r\n});\r\n\r\nlet WOFFDirectory = new r.Struct({\r\n  tag:            new r.String(4), // should be 'wOFF'\r\n  flavor:         r.uint32,\r\n  length:         r.uint32,\r\n  numTables:      r.uint16,\r\n  reserved:       new r.Reserved(r.uint16),\r\n  totalSfntSize:  r.uint32,\r\n  majorVersion:   r.uint16,\r\n  minorVersion:   r.uint16,\r\n  metaOffset:     r.uint32,\r\n  metaLength:     r.uint32,\r\n  metaOrigLength: r.uint32,\r\n  privOffset:     r.uint32,\r\n  privLength:     r.uint32,\r\n  tables:         new r.Array(WOFFDirectoryEntry, 'numTables')\r\n});\r\n\r\nWOFFDirectory.process = function() {\r\n  let tables = {};\r\n  for (let table of this.tables) {\r\n    tables[table.tag] = table;\r\n  }\r\n\r\n  this.tables = tables;\r\n};\r\n\r\nexport default WOFFDirectory;\r\n","import TTFFont from './TTFFont';\r\nimport WOFFDirectory from './tables/WOFFDirectory';\r\nimport tables from './tables';\r\nimport inflate from 'tiny-inflate';\r\nimport r from '@foliojs-fork/restructure';\r\n\r\nexport default class WOFFFont extends TTFFont {\r\n  static probe(buffer) {\r\n    return buffer.toString('ascii', 0, 4) === 'wOFF';\r\n  }\r\n\r\n  _decodeDirectory() {\r\n    this.directory = WOFFDirectory.decode(this.stream, { _startOffset: 0 });\r\n  }\r\n\r\n  _getTableStream(tag) {\r\n    let table = this.directory.tables[tag];\r\n    if (table) {\r\n      this.stream.pos = table.offset;\r\n\r\n      if (table.compLength < table.length) {\r\n        this.stream.pos += 2; // skip deflate header\r\n        let outBuffer = Buffer.alloc(table.length);\r\n        let buf = inflate(this.stream.readBuffer(table.compLength - 2), outBuffer);\r\n        return new r.DecodeStream(buf);\r\n      } else {\r\n        return this.stream;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n","import TTFGlyph from './TTFGlyph';\r\n\r\n/**\r\n * Represents a TrueType glyph in the WOFF2 format, which compresses glyphs differently.\r\n */\r\nexport default class WOFF2Glyph extends TTFGlyph {\r\n  _decode() {\r\n    // We have to decode in advance (in WOFF2Font), so just return the pre-decoded data.\r\n    return this._font._transformedGlyphs[this.id];\r\n  }\r\n\r\n  _getCBox() {\r\n    return this.path.bbox;\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nconst Base128 = {\r\n  decode(stream) {\r\n    let result = 0;\r\n    let iterable = [0, 1, 2, 3, 4];\r\n    for (let j = 0; j < iterable.length; j++) {\r\n      let i = iterable[j];\r\n      let code = stream.readUInt8();\r\n\r\n      // If any of the top seven bits are set then we're about to overflow.\r\n      if (result & 0xe0000000) {\r\n        throw new Error('Overflow');\r\n      }\r\n\r\n      result = (result << 7) | (code & 0x7f);\r\n      if ((code & 0x80) === 0) {\r\n        return result;\r\n      }\r\n    }\r\n\r\n    throw new Error('Bad base 128 number');\r\n  }\r\n};\r\n\r\nlet knownTags = [\r\n  'cmap', 'head', 'hhea', 'hmtx', 'maxp', 'name', 'OS/2', 'post', 'cvt ',\r\n  'fpgm', 'glyf', 'loca', 'prep', 'CFF ', 'VORG', 'EBDT', 'EBLC', 'gasp',\r\n  'hdmx', 'kern', 'LTSH', 'PCLT', 'VDMX', 'vhea', 'vmtx', 'BASE', 'GDEF',\r\n  'GPOS', 'GSUB', 'EBSC', 'JSTF', 'MATH', 'CBDT', 'CBLC', 'COLR', 'CPAL',\r\n  'SVG ', 'sbix', 'acnt', 'avar', 'bdat', 'bloc', 'bsln', 'cvar', 'fdsc',\r\n  'feat', 'fmtx', 'fvar', 'gvar', 'hsty', 'just', 'lcar', 'mort', 'morx',\r\n  'opbd', 'prop', 'trak', 'Zapf', 'Silf', 'Glat', 'Gloc', 'Feat', 'Sill'\r\n];\r\n\r\nlet WOFF2DirectoryEntry = new r.Struct({\r\n  flags: r.uint8,\r\n  customTag: new r.Optional(new r.String(4), t => (t.flags & 0x3f) === 0x3f),\r\n  tag: t => t.customTag || knownTags[t.flags & 0x3f],// || (() => { throw new Error(`Bad tag: ${flags & 0x3f}`); })(); },\r\n  length: Base128,\r\n  transformVersion: t => (t.flags >>> 6) & 0x03,\r\n  transformed: t => (t.tag === 'glyf' || t.tag === 'loca') ? t.transformVersion === 0 : t.transformVersion !== 0,\r\n  transformLength: new r.Optional(Base128, t => t.transformed)\r\n});\r\n\r\nlet WOFF2Directory = new r.Struct({\r\n  tag: new r.String(4), // should be 'wOF2'\r\n  flavor: r.uint32,\r\n  length: r.uint32,\r\n  numTables: r.uint16,\r\n  reserved: new r.Reserved(r.uint16),\r\n  totalSfntSize: r.uint32,\r\n  totalCompressedSize: r.uint32,\r\n  majorVersion: r.uint16,\r\n  minorVersion: r.uint16,\r\n  metaOffset: r.uint32,\r\n  metaLength: r.uint32,\r\n  metaOrigLength: r.uint32,\r\n  privOffset: r.uint32,\r\n  privLength: r.uint32,\r\n  tables: new r.Array(WOFF2DirectoryEntry, 'numTables')\r\n});\r\n\r\nWOFF2Directory.process = function() {\r\n  let tables = {};\r\n  for (let i = 0; i < this.tables.length; i++) {\r\n    let table = this.tables[i];\r\n    tables[table.tag] = table;\r\n  }\r\n\r\n  return this.tables = tables;\r\n};\r\n\r\nexport default WOFF2Directory;\r\n","import r from '@foliojs-fork/restructure';\r\nimport brotli from 'brotli/decompress';\r\nimport TTFFont from './TTFFont';\r\nimport TTFGlyph, { Point } from './glyph/TTFGlyph';\r\nimport WOFF2Glyph from './glyph/WOFF2Glyph';\r\nimport WOFF2Directory from './tables/WOFF2Directory';\r\n\r\n/**\r\n * Subclass of TTFFont that represents a TTF/OTF font compressed by WOFF2\r\n * See spec here: http://www.w3.org/TR/WOFF2/\r\n */\r\nexport default class WOFF2Font extends TTFFont {\r\n  static probe(buffer) {\r\n    return buffer.toString('ascii', 0, 4) === 'wOF2';\r\n  }\r\n\r\n  _decodeDirectory() {\r\n    this.directory = WOFF2Directory.decode(this.stream);\r\n    this._dataPos = this.stream.pos;\r\n  }\r\n\r\n  _decompress() {\r\n    // decompress data and setup table offsets if we haven't already\r\n    if (!this._decompressed) {\r\n      this.stream.pos = this._dataPos;\r\n      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);\r\n\r\n      let decompressedSize = 0;\r\n      for (let tag in this.directory.tables) {\r\n        let entry = this.directory.tables[tag];\r\n        entry.offset = decompressedSize;\r\n        decompressedSize += (entry.transformLength != null) ? entry.transformLength : entry.length;\r\n      }\r\n\r\n      let decompressed = brotli(buffer, decompressedSize);\r\n      if (!decompressed) {\r\n        throw new Error('Error decoding compressed data in WOFF2');\r\n      }\r\n\r\n      this.stream = new r.DecodeStream(Buffer.from(decompressed));\r\n      this._decompressed = true;\r\n    }\r\n  }\r\n\r\n  _decodeTable(table) {\r\n    this._decompress();\r\n    return super._decodeTable(table);\r\n  }\r\n\r\n  // Override this method to get a glyph and return our\r\n  // custom subclass if there is a glyf table.\r\n  _getBaseGlyph(glyph, characters = []) {\r\n    if (!this._glyphs[glyph]) {\r\n      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {\r\n        if (!this._transformedGlyphs) { this._transformGlyfTable(); }\r\n        return this._glyphs[glyph] = new WOFF2Glyph(glyph, characters, this);\r\n\r\n      } else {\r\n        return super._getBaseGlyph(glyph, characters);\r\n      }\r\n    }\r\n  }\r\n\r\n  _transformGlyfTable() {\r\n    this._decompress();\r\n    this.stream.pos = this.directory.tables.glyf.offset;\r\n    let table = GlyfTable.decode(this.stream);\r\n    let glyphs = [];\r\n\r\n    for (let index = 0; index < table.numGlyphs; index++) {\r\n      let glyph = {};\r\n      let nContours = table.nContours.readInt16BE();\r\n      glyph.numberOfContours = nContours;\r\n\r\n      if (nContours > 0) { // simple glyph\r\n        let nPoints = [];\r\n        let totalPoints = 0;\r\n\r\n        for (let i = 0; i < nContours; i++) {\r\n          let r = read255UInt16(table.nPoints);\r\n          totalPoints += r;\r\n          nPoints.push(totalPoints);\r\n        }\r\n\r\n        glyph.points = decodeTriplet(table.flags, table.glyphs, totalPoints);\r\n        for (let i = 0; i < nContours; i++) {\r\n          glyph.points[nPoints[i] - 1].endContour = true;\r\n        }\r\n\r\n        var instructionSize = read255UInt16(table.glyphs);\r\n\r\n      } else if (nContours < 0) { // composite glyph\r\n        let haveInstructions = TTFGlyph.prototype._decodeComposite.call({ _font: this }, glyph, table.composites);\r\n        if (haveInstructions) {\r\n          var instructionSize = read255UInt16(table.glyphs);\r\n        }\r\n      }\r\n\r\n      glyphs.push(glyph);\r\n    }\r\n\r\n    this._transformedGlyphs = glyphs;\r\n  }\r\n}\r\n\r\n// Special class that accepts a length and returns a sub-stream for that data\r\nclass Substream {\r\n  constructor(length) {\r\n    this.length = length;\r\n    this._buf = new r.Buffer(length);\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    return new r.DecodeStream(this._buf.decode(stream, parent));\r\n  }\r\n}\r\n\r\n// This struct represents the entire glyf table\r\nlet GlyfTable = new r.Struct({\r\n  version: r.uint32,\r\n  numGlyphs: r.uint16,\r\n  indexFormat: r.uint16,\r\n  nContourStreamSize: r.uint32,\r\n  nPointsStreamSize: r.uint32,\r\n  flagStreamSize: r.uint32,\r\n  glyphStreamSize: r.uint32,\r\n  compositeStreamSize: r.uint32,\r\n  bboxStreamSize: r.uint32,\r\n  instructionStreamSize: r.uint32,\r\n  nContours: new Substream('nContourStreamSize'),\r\n  nPoints: new Substream('nPointsStreamSize'),\r\n  flags: new Substream('flagStreamSize'),\r\n  glyphs: new Substream('glyphStreamSize'),\r\n  composites: new Substream('compositeStreamSize'),\r\n  bboxes: new Substream('bboxStreamSize'),\r\n  instructions: new Substream('instructionStreamSize')\r\n});\r\n\r\nconst WORD_CODE = 253;\r\nconst ONE_MORE_BYTE_CODE2 = 254;\r\nconst ONE_MORE_BYTE_CODE1 = 255;\r\nconst LOWEST_U_CODE = 253;\r\n\r\nfunction read255UInt16(stream) {\r\n  let code = stream.readUInt8();\r\n\r\n  if (code === WORD_CODE) {\r\n    return stream.readUInt16BE();\r\n  }\r\n\r\n  if (code === ONE_MORE_BYTE_CODE1) {\r\n    return stream.readUInt8() + LOWEST_U_CODE;\r\n  }\r\n\r\n  if (code === ONE_MORE_BYTE_CODE2) {\r\n    return stream.readUInt8() + LOWEST_U_CODE * 2;\r\n  }\r\n\r\n  return code;\r\n}\r\n\r\nfunction withSign(flag, baseval) {\r\n  return flag & 1 ? baseval : -baseval;\r\n}\r\n\r\nfunction decodeTriplet(flags, glyphs, nPoints) {\r\n  let y;\r\n  let x = y = 0;\r\n  let res = [];\r\n\r\n  for (let i = 0; i < nPoints; i++) {\r\n    let dx = 0, dy = 0;\r\n    let flag = flags.readUInt8();\r\n    let onCurve = !(flag >> 7);\r\n    flag &= 0x7f;\r\n\r\n    if (flag < 10) {\r\n      dx = 0;\r\n      dy = withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());\r\n\r\n    } else if (flag < 20) {\r\n      dx = withSign(flag, (((flag - 10) & 14) << 7) + glyphs.readUInt8());\r\n      dy = 0;\r\n\r\n    } else if (flag < 84) {\r\n      var b0 = flag - 20;\r\n      var b1 = glyphs.readUInt8();\r\n      dx = withSign(flag, 1 + (b0 & 0x30) + (b1 >> 4));\r\n      dy = withSign(flag >> 1, 1 + ((b0 & 0x0c) << 2) + (b1 & 0x0f));\r\n\r\n    } else if (flag < 120) {\r\n      var b0 = flag - 84;\r\n      dx = withSign(flag, 1 + ((b0 / 12) << 8) + glyphs.readUInt8());\r\n      dy = withSign(flag >> 1, 1 + (((b0 % 12) >> 2) << 8) + glyphs.readUInt8());\r\n\r\n    } else if (flag < 124) {\r\n      var b1 = glyphs.readUInt8();\r\n      let b2 = glyphs.readUInt8();\r\n      dx = withSign(flag, (b1 << 4) + (b2 >> 4));\r\n      dy = withSign(flag >> 1, ((b2 & 0x0f) << 8) + glyphs.readUInt8());\r\n\r\n    } else {\r\n      dx = withSign(flag, glyphs.readUInt16BE());\r\n      dy = withSign(flag >> 1, glyphs.readUInt16BE());\r\n    }\r\n\r\n    x += dx;\r\n    y += dy;\r\n    res.push(new Point(onCurve, false, x, y));\r\n  }\r\n\r\n  return res;\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\nimport TTFFont from './TTFFont';\r\nimport Directory from './tables/directory';\r\nimport tables from './tables';\r\n\r\nlet TTCHeader = new r.VersionedStruct(r.uint32, {\r\n  0x00010000: {\r\n    numFonts:   r.uint32,\r\n    offsets:    new r.Array(r.uint32, 'numFonts')\r\n  },\r\n  0x00020000: {\r\n    numFonts:   r.uint32,\r\n    offsets:    new r.Array(r.uint32, 'numFonts'),\r\n    dsigTag:    r.uint32,\r\n    dsigLength: r.uint32,\r\n    dsigOffset: r.uint32\r\n  }\r\n});\r\n\r\nexport default class TrueTypeCollection {\r\n  static probe(buffer) {\r\n    return buffer.toString('ascii', 0, 4) === 'ttcf';\r\n  }\r\n\r\n  constructor(stream) {\r\n    this.stream = stream;\r\n    if (stream.readString(4) !== 'ttcf') {\r\n      throw new Error('Not a TrueType collection');\r\n    }\r\n\r\n    this.header = TTCHeader.decode(stream);\r\n  }\r\n\r\n  getFont(name) {\r\n    for (let offset of this.header.offsets) {\r\n      let stream = new r.DecodeStream(this.stream.buffer);\r\n      stream.pos = offset;\r\n      let font = new TTFFont(stream);\r\n      if (font.postscriptName === name) {\r\n        return font;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  get fonts() {\r\n    let fonts = [];\r\n    for (let offset of this.header.offsets) {\r\n      let stream = new r.DecodeStream(this.stream.buffer);\r\n      stream.pos = offset;\r\n      fonts.push(new TTFFont(stream));\r\n    }\r\n\r\n    return fonts;\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\nimport TTFFont from './TTFFont';\r\n\r\nlet DFontName = new r.String(r.uint8);\r\nlet DFontData = new r.Struct({\r\n  len: r.uint32,\r\n  buf: new r.Buffer('len')\r\n});\r\n\r\nlet Ref = new r.Struct({\r\n  id: r.uint16,\r\n  nameOffset: r.int16,\r\n  attr: r.uint8,\r\n  dataOffset: r.uint24,\r\n  handle: r.uint32\r\n});\r\n\r\nlet Type = new r.Struct({\r\n  name: new r.String(4),\r\n  maxTypeIndex: r.uint16,\r\n  refList: new r.Pointer(r.uint16, new r.Array(Ref, t => t.maxTypeIndex + 1), { type: 'parent' })\r\n});\r\n\r\nlet TypeList = new r.Struct({\r\n  length: r.uint16,\r\n  types: new r.Array(Type, t => t.length + 1)\r\n});\r\n\r\nlet DFontMap = new r.Struct({\r\n  reserved: new r.Reserved(r.uint8, 24),\r\n  typeList: new r.Pointer(r.uint16, TypeList),\r\n  nameListOffset: new r.Pointer(r.uint16, 'void')\r\n});\r\n\r\nlet DFontHeader = new r.Struct({\r\n  dataOffset: r.uint32,\r\n  map: new r.Pointer(r.uint32, DFontMap),\r\n  dataLength: r.uint32,\r\n  mapLength: r.uint32\r\n});\r\n\r\nexport default class DFont {\r\n  static probe(buffer) {\r\n    let stream = new r.DecodeStream(buffer);\r\n\r\n    try {\r\n      var header = DFontHeader.decode(stream);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n\r\n    for (let type of header.map.typeList.types) {\r\n      if (type.name === 'sfnt') {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  constructor(stream) {\r\n    this.stream = stream;\r\n    this.header = DFontHeader.decode(this.stream);\r\n\r\n    for (let type of this.header.map.typeList.types) {\r\n      for (let ref of type.refList) {\r\n        if (ref.nameOffset >= 0) {\r\n          this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;\r\n          ref.name = DFontName.decode(this.stream);\r\n        } else {\r\n          ref.name = null;\r\n        }\r\n      }\r\n\r\n      if (type.name === 'sfnt') {\r\n        this.sfnt = type;\r\n      }\r\n    }\r\n  }\r\n\r\n  getFont(name) {\r\n    if (!this.sfnt) {\r\n      return null;\r\n    }\r\n\r\n    for (let ref of this.sfnt.refList) {\r\n      let pos = this.header.dataOffset + ref.dataOffset + 4;\r\n      let stream = new r.DecodeStream(this.stream.buffer.slice(pos));\r\n      let font = new TTFFont(stream);\r\n      if (font.postscriptName === name) {\r\n        return font;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  get fonts() {\r\n    let fonts = [];\r\n    for (let ref of this.sfnt.refList) {\r\n      let pos = this.header.dataOffset + ref.dataOffset + 4;\r\n      let stream = new r.DecodeStream(this.stream.buffer.slice(pos));\r\n      fonts.push(new TTFFont(stream));\r\n    }\r\n\r\n    return fonts;\r\n  }\r\n}\r\n","import fontkit from './base';\r\nimport TTFFont from './TTFFont';\r\nimport WOFFFont from './WOFFFont';\r\nimport WOFF2Font from './WOFF2Font';\r\nimport TrueTypeCollection from './TrueTypeCollection';\r\nimport DFont from './DFont';\r\n\r\n// Register font formats\r\nfontkit.registerFormat(TTFFont);\r\nfontkit.registerFormat(WOFFFont);\r\nfontkit.registerFormat(WOFF2Font);\r\nfontkit.registerFormat(TrueTypeCollection);\r\nfontkit.registerFormat(DFont);\r\n\r\nexport default fontkit;\r\n"],"names":["fs","require","fontkit","logErrors","formats","registerFormat","format","push","openSync","filename","postscriptName","buffer","readFileSync","create","open","callback","readFile","err","font","e","i","length","probe","r","DecodeStream","getFont","Error","defaultLanguage","setDefaultLanguage","lang","cache","target","key","descriptor","get","value","call","Object","defineProperty","fn","Map","memoized","args","has","result","apply","set","SubHeader","Struct","firstCode","uint16","entryCount","idDelta","int16","idRangeOffset","CmapGroup","startCharCode","uint32","endCharCode","glyphID","UnicodeValueRange","startUnicodeValue","uint24","additionalCount","uint8","UVSMapping","unicodeValue","DefaultUVS","Array","NonDefaultUVS","VarSelectorRecord","varSelector","defaultUVS","Pointer","type","nonDefaultUVS","CmapSubtable","VersionedStruct","language","codeMap","LazyArray","subHeaderKeys","subHeaderCount","t","Math","max","subHeaders","glyphIndexArray","segCountX2","segCount","searchRange","entrySelector","rangeShift","endCode","reservedPad","Reserved","startCode","_currentOffset","glyphIndices","reserved","is32","nGroups","groups","numRecords","varSelectors","CmapEntry","platformID","encodingID","table","lazy","version","numSubtables","tables","int32","revision","checkSumAdjustment","magicNumber","flags","unitsPerEm","created","modified","xMin","yMin","xMax","yMax","macStyle","Bitfield","lowestRecPPEM","fontDirectionHint","indexToLocFormat","glyphDataFormat","ascent","descent","lineGap","advanceWidthMax","minLeftSideBearing","minRightSideBearing","xMaxExtent","caretSlopeRise","caretSlopeRun","caretOffset","metricDataFormat","numberOfMetrics","HmtxEntry","advance","bearing","metrics","parent","hhea","bearings","maxp","numGlyphs","maxPoints","maxContours","maxComponentPoints","maxComponentContours","maxZones","maxTwilightPoints","maxStorage","maxFunctionDefs","maxInstructionDefs","maxStackElements","maxSizeOfInstructions","maxComponentElements","maxComponentDepth","getEncoding","languageID","MAC_LANGUAGE_ENCODINGS","ENCODINGS","LANGUAGES","NameRecord","nameID","string","String","relativeTo","ctx","stringOffset","allowNull","LangTagRecord","tag","NameTable","count","records","langTagCount","langTags","NAMES","process","stream","record","obj","preEncode","isArray","val","indexOf","Buffer","byteLength","en","size","OS2","header","xAvgCharWidth","usWeightClass","usWidthClass","fsType","ySubscriptXSize","ySubscriptYSize","ySubscriptXOffset","ySubscriptYOffset","ySuperscriptXSize","ySuperscriptYSize","ySuperscriptXOffset","ySuperscriptYOffset","yStrikeoutSize","yStrikeoutPosition","sFamilyClass","panose","ulCharRange","vendorID","fsSelection","usFirstCharIndex","usLastCharIndex","typoAscender","typoDescender","typoLineGap","winAscent","winDescent","codePageRange","xHeight","capHeight","defaultChar","breakChar","maxContent","usLowerOpticalPointSize","usUpperOpticalPointSize","versions","fixed32","italicAngle","underlinePosition","underlineThickness","isFixedPitch","minMemType42","maxMemType42","minMemType1","maxMemType1","numberOfGlyphs","glyphNameIndex","names","offsets","map","controlValues","instructions","loca","controlValueProgram","CFFIndex","hdrSize","getCFFVersion","readUInt32BE","readUInt16BE","offSize","readUInt8","offsetType","pos","ret","startPos","start","decode","end","offset","arr","item","writeUInt16BE","sizes","s","writeUInt8","encode","FLOAT_EOF","FLOAT_LOOKUP","FLOAT_ENCODE_LOOKUP","CFFOperand","readInt16BE","readInt32BE","str","b","n1","n2","parseFloat","forceLarge","ceil","Number","writeInt32BE","c1","c2","writeInt16BE","CFFDict","ops","fields","field","operands","op","decodeOperands","encodeOperands","defineProperties","_startOffset","PropertyDescriptor","dict","includePointers","pointerSize","startOffset","len","k","isEqual","pointers","pointerOffset","ptr","CFFPointer","options","Ptr","CFFBlendOp","numBlends","pop","StandardEncoding","ExpertEncoding","ISOAdobeCharset","ExpertCharset","ExpertSubsetCharset","LangSysTable","reqFeatureIndex","featureCount","featureIndexes","LangSysRecord","langSys","Script","defaultLangSys","langSysRecords","ScriptRecord","script","ScriptList","Feature","featureParams","lookupCount","lookupListIndexes","FeatureRecord","feature","FeatureList","LookupFlags","markAttachmentType","LookupList","SubTable","Lookup","lookupType","subTableCount","subTables","markFilteringSet","Optional","useMarkFilteringSet","RangeRecord","startCoverageIndex","Coverage","glyphCount","glyphs","rangeCount","rangeRecords","ClassRangeRecord","class","ClassDef","startGlyph","classValueArray","classRangeCount","classRangeRecord","Device","a","deltaFormat","LookupRecord","sequenceIndex","lookupListIndex","Rule","input","lookupRecords","RuleSet","ClassRule","classes","ClassSet","Context","coverage","ruleSetCount","ruleSets","classDef","classSetCnt","classSet","coverages","ChainRule","backtrackGlyphCount","backtrack","inputGlyphCount","lookaheadGlyphCount","lookahead","ChainRuleSet","ChainingContext","chainCount","chainRuleSets","backtrackClassDef","inputClassDef","lookaheadClassDef","chainClassSet","backtrackCoverage","inputCoverage","lookaheadCoverage","F2DOT14","Fixed","RegionAxisCoordinates","startCoord","peakCoord","endCoord","VariationRegionList","axisCount","regionCount","variationRegions","DeltaSet","shortDeltas","shortDeltaCount","regionDeltas","int8","regionIndexCount","deltas","concat","ItemVariationData","itemCount","regionIndexes","deltaSets","ItemVariationStore","variationRegionList","variationDataCount","itemVariationData","ConditionTable","axisIndex","ConditionSet","conditionCount","conditionTable","FeatureTableSubstitutionRecord","featureIndex","alternateFeatureTable","FeatureTableSubstitution","substitutionCount","substitutions","FeatureVariationRecord","conditionSet","featureTableSubstitution","FeatureVariations","majorVersion","minorVersion","featureVariationRecordCount","featureVariationRecords","PredefinedOp","predefinedOps","index","CFFEncodingVersion","Range1","first","nLeft","Range2","CFFCustomEncoding","nCodes","codes","nRanges","ranges","CFFEncoding","RangeArray","resolveLength","res","range","CFFCustomCharset","CharStrings","CFFCharset","FDRange3","fd","FDRange4","FDSelect","fds","sentinel","CFFPrivateDict","CFFPrivateOp","FontDict","CFFTopDict","VariationStore","itemVariationStore","CFF2TopDict","CFFTop","fixed16","nameIndex","topDictIndex","stringIndex","globalSubrIndex","topDict","CFFFont","top","isCIDFont","ROS","sid","standardStrings","FullName","FamilyName","glyph","readBuffer","gid","charset","low","high","mid","fdForGlyph","FDArray","Private","VerticalOrigin","glyphIndex","vertOriginY","defaultVertOriginY","numVertOriginYMetrics","BigMetrics","height","width","horiBearingX","horiBearingY","horiAdvance","vertBearingX","vertBearingY","vertAdvance","SmallMetrics","bearingX","bearingY","EBDTComponent","xOffset","yOffset","ByteAligned","BitAligned","data","pad","numComponents","components","dataLen","SBitLineMetrics","ascender","descender","widthMax","caretSlopeNumerator","caretSlopeDenominator","minOriginSB","minAdvanceSB","maxBeforeBL","minAfterBL","CodeOffsetPair","glyphCode","IndexSubtable","imageFormat","imageDataOffset","offsetArray","lastGlyphIndex","firstGlyphIndex","imageSize","bigMetrics","glyphArray","glyphCodeArray","IndexSubtableArray","subtable","BitmapSizeTable","indexSubTableArray","indexTablesSize","numberOfIndexSubTables","colorRef","hori","vert","startGlyphIndex","endGlyphIndex","ppemX","ppemY","bitDepth","numSizes","ImageTable","ppem","resolution","imageOffsets","numImgTables","imageTables","LayerRecord","paletteIndex","BaseGlyphRecord","firstLayerIndex","numLayers","numBaseGlyphRecords","baseGlyphRecord","layerRecords","numLayerRecords","ColorRecord","blue","green","red","alpha","numPaletteEntries","numPalettes","numColorRecords","colorRecords","colorRecordIndices","offsetPaletteTypeArray","offsetPaletteLabelArray","offsetPaletteEntryLabelArray","BaseCoord","coordinate","referenceGlyph","baseCoordPoint","deviceTable","BaseValues","defaultIndex","baseCoordCount","baseCoords","FeatMinMaxRecord","minCoord","maxCoord","MinMax","featMinMaxCount","featMinMaxRecords","BaseLangSysRecord","minMax","BaseScript","baseValues","defaultMinMax","baseLangSysCount","baseLangSysRecords","BaseScriptRecord","BaseScriptList","BaseTagList","Axis","baseTagList","baseScriptList","horizAxis","vertAxis","AttachPoint","AttachList","attachPoints","CaretValue","caretValuePoint","LigGlyph","LigCaretList","ligGlyphCount","ligGlyphs","MarkGlyphSetsDef","markSetTableFormat","markSetCount","glyphClassDef","attachList","ligCaretList","markAttachClassDef","markGlyphSetsDef","ValueFormat","types","xPlacement","yPlacement","xAdvance","yAdvance","xPlaDevice","rel","yPlaDevice","xAdvDevice","yAdvDevice","ValueRecord","struct","buildStruct","PairValueRecord","secondGlyph","value1","value2","PairSet","Class2Record","Anchor","xCoordinate","yCoordinate","anchorPoint","xDeviceTable","yDeviceTable","EntryExitRecord","entryAnchor","exitAnchor","MarkRecord","markAnchor","MarkArray","BaseRecord","classCount","BaseArray","ComponentRecord","LigatureAttach","LigatureArray","GPOSLookup","valueFormat","valueCount","values","valueFormat1","valueFormat2","pairSetCount","pairSets","classDef1","classDef2","class1Count","class2Count","classRecords","entryExitCount","entryExitRecords","markCoverage","baseCoverage","markArray","baseArray","ligatureCoverage","ligatureArray","mark1Coverage","mark2Coverage","mark1Array","mark2Array","posFormat","extension","scriptList","featureList","lookupList","featureVariations","Sequence","AlternateSet","Ligature","compCount","LigatureSet","GSUBLookup","deltaGlyphID","substitute","substFormat","sequences","alternateSet","ligatureSets","substitutes","JstfGSUBModList","JstfPriority","shrinkageEnableGSUB","shrinkageDisableGSUB","shrinkageEnableGPOS","shrinkageDisableGPOS","shrinkageJstfMax","extensionEnableGSUB","extensionDisableGSUB","extensionEnableGPOS","extensionDisableGPOS","extensionJstfMax","JstfLangSys","JstfLangSysRecord","jstfLangSys","JstfScript","extenderGlyphs","langSysCount","JstfScriptRecord","scriptCount","VariableSizeNumber","_size","readUInt24BE","MapDataEntry","entry","entryFormat","outerIndex","innerIndex","DeltaSetIndexMap","mapCount","mapData","advanceWidthMapping","LSBMapping","RSBMapping","Signature","SignatureBlock","cbSignature","signature","ulVersion","usNumSigs","usFlag","signatures","signatureBlocks","GaspRange","rangeMaxPPEM","rangeGaspBehavior","numRanges","gaspRanges","DeviceRecord","pixelSize","maximumWidth","widths","sizeDeviceRecord","KernPair","left","right","ClassTable","firstGlyph","nGlyphs","Kern2Array","off","leftTable","rowWidth","KernSubtable","nPairs","pairs","rightTable","array","kernValueCount","leftClassCount","rightClassCount","kernValue","leftClass","rightClass","kernIndex","KernTable","subVersion","padding","tupleIndex","nTables","yPels","fontNumber","pitch","style","typeFamily","symbolSet","typeface","characterComplement","fileName","strokeWeight","widthType","serifStyle","Ratio","bCharSet","xRatio","yStartRatio","yEndRatio","vTable","yPelHeight","VdmxGroup","recs","startsz","endsz","entries","numRecs","numRatios","ratioRanges","advanceHeightMax","minTopSideBearing","minBottomSideBearing","yMaxExtent","VmtxEntry","vhea","shortFrac","Correspondence","fromCoord","toCoord","Segment","pairCount","correspondence","segment","UnboundedArrayAccessor","base","_items","constructor","name","UnboundedArray","LookupTable","ValueType","Shadow","BinarySearchHeader","unitSize","nUnits","LookupSegmentSingle","lastGlyph","LookupSegmentArray","LookupSingle","binarySearchHeader","segments","StateTable","entryData","assign","newState","Entry","StateArray","nClasses","StateHeader","classTable","stateArray","entryTable","StateTable1","ClassLookupTable","newStateOffset","StateHeader1","BslnSubtable","mappingData","standardGlyph","controlPoints","defaultBaseline","Setting","setting","fontFeatures","FeatureName","nSettings","settingTable","featureFlags","defaultSetting","featureNameCount","reserved1","reserved2","featureNames","axisTag","minValue","defaultValue","maxValue","Instance","coord","postscriptNameID","instanceSize","offsetToData","countSizePairs","axisSize","instanceCount","axis","instance","Offset","gvar","globalCoordCount","globalCoords","subFeatureFlags","stateTable","WidthDeltaRecord","justClass","beforeGrowLimit","beforeShrinkLimit","afterGrowLimit","afterShrinkLimit","growFlags","shrinkFlags","WidthDeltaCluster","ActionData","lowerLimit","upperLimit","order","addGlyph","substThreshold","substGlyph","variationAxis","minimumLimit","noStretchValue","maximumLimit","Action","actionClass","actionType","actionLength","actionData","PostcompensationAction","PostCompensationTable","lookupTable","JustificationTable","wdcOffset","postCompensationTable","widthDeltaClusters","horizontal","vertical","LigatureData","action","ContextualData","markIndex","currentIndex","InsertionData","currentInsertIndex","markedInsertIndex","SubstitutionTable","items","SubtableData","substitutionTable","ligatureActions","ligatureList","insertionActions","Subtable","FeatureEntry","featureType","featureSetting","enableFlags","disableFlags","MorxChain","defaultFlags","chainLength","nFeatureEntries","nSubtables","features","subtables","unused","nChains","chains","OpticalBounds","bottom","cmap","head","hmtx","post","fpgm","prep","cvt","glyf","VORG","EBLC","CBLC","sbix","COLR","CPAL","BASE","GDEF","GPOS","GSUB","JSTF","HVAR","DSIG","gasp","hdmx","kern","LTSH","PCLT","VDMX","vmtx","avar","bsln","feat","fvar","just","morx","opbd","TableEntry","checkSum","Directory","numTables","VoidPointer","Tables","maxExponentFor2","floor","log","LN2","maxPowerOf2","pow","binarySearch","cmp","min","iconv","CmapProcessor","cmapTable","encoding","findSubtable","encodingExists","uvs","codepoint","variationSelector","buf","fromCodePoint","getVariationSelector","rangeOffset","group","selectors","toArray","x","sel","endCodes","tail","delta","c","g","KernProcessor","positions","id","getKerning","crossStream","variation","pairIdx","pair","leftOffset","rightOffset","override","UnicodeLayoutEngine","clusterStart","clusterEnd","isMark","positionCluster","baseBox","cbox","copy","codePoints","minX","yGap","mark","markBox","position","combiningClass","getCombiningClass","maxX","minY","maxY","codePoint","unicode","BBox","Infinity","y","abs","UNICODE_SCRIPTS","Caucasian_Albanian","Arabic","Imperial_Aramaic","Armenian","Avestan","Balinese","Bamum","Bassa_Vah","Batak","Bengali","Bopomofo","Brahmi","Braille","Buginese","Buhid","Chakma","Canadian_Aboriginal","Carian","Cham","Cherokee","Coptic","Cypriot","Cyrillic","Devanagari","Deseret","Duployan","Egyptian_Hieroglyphs","Elbasan","Ethiopic","Georgian","Glagolitic","Gothic","Grantha","Greek","Gujarati","Gurmukhi","Hangul","Han","Hanunoo","Hebrew","Hiragana","Pahawh_Hmong","Katakana_Or_Hiragana","Old_Italic","Javanese","Kayah_Li","Katakana","Kharoshthi","Khmer","Khojki","Kannada","Kaithi","Tai_Tham","Lao","Latin","Lepcha","Limbu","Linear_A","Linear_B","Lisu","Lycian","Lydian","Mahajani","Mandaic","Manichaean","Mende_Kikakui","Meroitic_Cursive","Meroitic_Hieroglyphs","Malayalam","Modi","Mongolian","Mro","Meetei_Mayek","Myanmar","Old_North_Arabian","Nabataean","Nko","Ogham","Ol_Chiki","Old_Turkic","Oriya","Osmanya","Palmyrene","Pau_Cin_Hau","Old_Permic","Phags_Pa","Inscriptional_Pahlavi","Psalter_Pahlavi","Phoenician","Miao","Inscriptional_Parthian","Rejang","Runic","Samaritan","Old_South_Arabian","Saurashtra","Shavian","Sharada","Siddham","Khudawadi","Sinhala","Sora_Sompeng","Sundanese","Syloti_Nagri","Syriac","Tagbanwa","Takri","Tai_Le","New_Tai_Lue","Tamil","Tai_Viet","Telugu","Tifinagh","Tagalog","Thaana","Thai","Tibetan","Tirhuta","Ugaritic","Vai","Warang_Citi","Old_Persian","Cuneiform","Yi","Inherited","Common","Unknown","OPENTYPE_SCRIPTS","fromOpenType","forString","idx","code","charCodeAt","next","getScript","forCodePoints","RTL","arab","hebr","syrc","thaa","cprt","khar","phnx","lydi","avst","armi","phli","prti","sarb","orkh","samr","mand","merc","mero","mani","mend","nbat","narb","palm","phlp","direction","GlyphRun","bbox","p","addPoint","GlyphPosition","allTypographicFeatures","exclusive","allTypeFeatures","ligatures","requiredLigatures","commonLigatures","rareLigatures","rebusPictures","diphthongLigatures","squaredLigatures","abbrevSquaredLigatures","symbolLigatures","contextualLigatures","historicalLigatures","cursiveConnection","unconnected","partiallyConnected","cursive","letterCase","verticalSubstitution","substituteVerticalForms","linguisticRearrangement","numberSpacing","monospacedNumbers","proportionalNumbers","thirdWidthNumbers","quarterWidthNumbers","smartSwash","wordInitialSwashes","wordFinalSwashes","nonFinalSwashes","diacritics","showDiacritics","hideDiacritics","decomposeDiacritics","verticalPosition","normalPosition","superiors","inferiors","ordinals","scientificInferiors","fractions","noFractions","verticalFractions","diagonalFractions","overlappingCharacters","preventOverlap","typographicExtras","slashedZero","mathematicalExtras","mathematicalGreek","ornamentSets","noOrnaments","dingbats","piCharacters","fleurons","decorativeBorders","internationalSymbols","mathSymbols","characterAlternatives","noAlternates","designComplexity","designLevel1","designLevel2","designLevel3","designLevel4","designLevel5","styleOptions","noStyleOptions","displayText","engravedText","illuminatedCaps","titlingCaps","tallCaps","characterShape","traditionalCharacters","simplifiedCharacters","JIS1978Characters","JIS1983Characters","JIS1990Characters","traditionalAltOne","traditionalAltTwo","traditionalAltThree","traditionalAltFour","traditionalAltFive","expertCharacters","JIS2004Characters","hojoCharacters","NLCCharacters","traditionalNamesCharacters","numberCase","lowerCaseNumbers","upperCaseNumbers","textSpacing","proportionalText","monospacedText","halfWidthText","thirdWidthText","quarterWidthText","altProportionalText","altHalfWidthText","transliteration","noTransliteration","annotation","noAnnotation","boxAnnotation","roundedBoxAnnotation","circleAnnotation","invertedCircleAnnotation","parenthesisAnnotation","periodAnnotation","romanNumeralAnnotation","diamondAnnotation","invertedBoxAnnotation","invertedRoundedBoxAnnotation","kanaSpacing","fullWidthKana","proportionalKana","ideographicSpacing","fullWidthIdeographs","proportionalIdeographs","halfWidthIdeographs","unicodeDecomposition","canonicalComposition","compatibilityComposition","transcodingComposition","rubyKana","CJKSymbolAlternatives","noCJKSymbolAlternatives","CJKSymbolAltOne","CJKSymbolAltTwo","CJKSymbolAltThree","CJKSymbolAltFour","CJKSymbolAltFive","ideographicAlternatives","noIdeographicAlternatives","ideographicAltOne","ideographicAltTwo","ideographicAltThree","ideographicAltFour","ideographicAltFive","CJKVerticalRomanPlacement","CJKVerticalRomanCentered","CJKVerticalRomanHBaseline","italicCJKRoman","CJKItalicRoman","caseSensitiveLayout","caseSensitiveSpacing","alternateKana","alternateHorizKana","alternateVertKana","stylisticAlternatives","noStylisticAlternates","stylisticAltOne","stylisticAltTwo","stylisticAltThree","stylisticAltFour","stylisticAltFive","stylisticAltSix","stylisticAltSeven","stylisticAltEight","stylisticAltNine","stylisticAltTen","stylisticAltEleven","stylisticAltTwelve","stylisticAltThirteen","stylisticAltFourteen","stylisticAltFifteen","stylisticAltSixteen","stylisticAltSeventeen","stylisticAltEighteen","stylisticAltNineteen","stylisticAltTwenty","contextualAlternates","swashAlternates","contextualSwashAlternates","lowerCase","defaultLowerCase","lowerCaseSmallCaps","lowerCasePetiteCaps","upperCase","defaultUpperCase","upperCaseSmallCaps","upperCasePetiteCaps","languageTag","CJKRomanSpacing","halfWidthCJKRoman","proportionalCJKRoman","defaultCJKRoman","fullWidthCJKRoman","selector","OTMapping","rlig","clig","dlig","hlig","liga","hist","smcp","pcap","frac","dnom","numr","afrc","case","ccmp","cpct","valt","swsh","cswh","curs","c2pc","c2sc","init","fin2","medi","med2","fin3","fina","pkna","half","halt","hkna","vkna","ital","lnum","onum","mgrk","calt","vrt2","tnum","pnum","sups","subs","ordn","pwid","hwid","qwid","twid","fwid","palt","trad","smpl","jp78","jp83","jp90","jp04","expt","hojo","nlck","tnam","ruby","titl","zero","ss01","ss02","ss03","ss04","ss05","ss06","ss07","ss08","ss09","ss10","ss11","ss12","ss13","ss14","ss15","ss16","ss17","ss18","ss19","ss20","slice","AATMapping","ot","aat","mapOTToAAT","mapFeatureStrings","f","isNaN","typeCode","settingCode","mapAATToOT","keys","AATLookupTable","getItem","seg","classValue","START_OF_TEXT_STATE","END_OF_TEXT_CLASS","OUT_OF_BOUNDS_CLASS","DELETED_GLYPH_CLASS","DONT_ADVANCE","AATStateMachine","reverse","processEntry","currentState","dir","classCode","shouldAdvance","lookup","row","entryIndex","opts","state","visited","Set","add","glyphsForValue","enter","traverse","exit","MARK_FIRST","MARK_LAST","VERB","SET_MARK","SET_COMPONENT","PERFORM_ACTION","LAST_MASK","STORE_MASK","OFFSET_MASK","REVERSE_DIRECTION","CURRENT_INSERT_BEFORE","MARKED_INSERT_BEFORE","CURRENT_INSERT_COUNT","MARKED_INSERT_COUNT","AATMorxProcessor","processIndicRearragement","bind","processContextualSubstitution","processLigature","processNoncontextualSubstitutions","processGlyphInsertion","inputCache","chain","processSubtable","splice","ligatureStack","markedGlyph","markedIndex","stateMachine","getStateMachine","getProcessor","reorderGlyphs","subsitutions","getGlyph","actions","actionIndex","last","ligatureIndex","ligatureGlyphs","componentGlyph","unshift","store","component","ligatureEntry","insertionActionIndex","isBefore","insertions","_insertGlyphs","generateInputCache","generateInputsForSubtable","stack","found","swap","rangeA","rangeB","reverseA","reverseB","verb","AATLayoutEngine","morxProcessor","fallbackPosition","glyphRun","AATFeatureMap","getSupportedFeatures","glyphStrings","generateInputs","_addStrings","strings","_cmapProcessor","codePointsForGlyph","ShapingPlan","stages","globalFeatures","allFeatures","global","stageIndex","stage","arg","_addFeatures","local","processor","applyFeatures","VARIATION_FEATURES","COMMON_FEATURES","FRACTIONAL_FEATURES","HORIZONTAL_FEATURES","DIRECTIONAL_FEATURES","ltr","rtl","DefaultShaper","plan","planPreprocessing","planFeatures","planPostprocessing","assignGlobalFeatures","assignFeatures","userFeatures","setFeatureOverrides","isDigit","trie","UnicodeTrie","__dirname","FEATURES","ShapingClasses","Non_Joining","Left_Joining","Right_Joining","Dual_Joining","Join_Causing","ALAPH","Transparent","ISOL","FINA","FIN2","FIN3","MEDI","MED2","INIT","NONE","STATE_TABLE","ArabicShaper","addStage","prev","curAction","prevAction","getShapingClass","category","getCategory","GlyphIterator","reset","ignoreMarks","ignoreBaseGlyphs","isBase","ignoreLigatures","isLigature","shouldIgnore","move","increment","DEFAULT_SCRIPTS","OTProcessor","scriptTag","lookups","variationsIndex","_variationProcessor","findVariationsIndex","normalizedCoords","selectScript","ligatureID","currentFeature","changed","findScript","repeat","substituteFeature","substituteFeatureForVariations","exclude","lookupIndex","sort","substitution","coords","variations","conditions","variationConditionsMatch","every","condition","filterRangeMinValue","filterRangeMaxValue","advances","lookupsForFeatures","applyLookups","glyphIterator","cur","applyLookup","lookupRecord","sequence","matched","match","coverageIndex","classID","getClassID","rule","sequenceMatches","applyLookupList","classSequenceMatches","coverageSequenceMatches","rules","GlyphInfo","_font","ligatureComponent","isLigated","cursiveAttachment","markAttachment","shaperInfo","substituted","isMultiplied","_id","prototype","HangulShaper","getType","DECOMPOSE","hasGlyphForCodePoint","decompose","COMPOSE","compose","TONE_MARK","reorderToneMark","INVALID","insertDottedCircle","HANGUL_BASE","HANGUL_END","HANGUL_COUNT","L_BASE","V_BASE","T_BASE","L_COUNT","V_COUNT","T_COUNT","L_END","V_END","T_END","DOTTED_CIRCLE","isL","isV","isT","isTone","isLVT","isLV","isCombiningL","isCombiningV","isCombiningT","X","L","V","T","LV","LVT","M","NO_ACTION","glyphForCodePoint","l","v","ljmo","vjmo","insert","tjmo","prevType","lv","del","getLength","advanceWidth","dottedCircle","CATEGORIES","C","N","H","ZWNJ","ZWJ","SM","VD","A","Placeholder","Dotted_Circle","RS","Coeng","Repha","Ra","CM","Symbol","POSITIONS","Start","Ra_To_Become_Reph","Pre_M","Pre_C","Base_C","After_Main","Above_C","Before_Sub","Below_C","After_Sub","Before_Post","Post_C","After_Post","Final_C","SMVD","End","CONSONANT_FLAGS","JOINER_FLAGS","HALANT_OR_COENG_FLAGS","INDIC_CONFIGS","Default","hasOldSpec","virama","basePos","rephPos","rephMode","blwfMode","INDIC_DECOMPOSITIONS","decompositions","useData","StateMachine","indicMachine","IndicShaper","setupSyllables","initialReordering","finalReordering","unicodeScript","indicConfig","isOldSpec","d","decomposed","indicCategory","indicPosition","IndicInfo","syllableType","syllable","tags","isConsonant","isJoiner","isHalantOrCoeng","wouldSubstitute","_layoutEngine","engine","GSUBProcessor","consonantPosition","consonant","info","nextSyllable","limit","hasReph","rphf","seenBelow","j","disallowDoubleHalants","lastPos","blwf","abvf","pstf","prefLen","pref","cfar","nonJoiner","tryPref","BASE_C","newPos","oldPos","tmp","newRephPos","reph","test","categories","UniversalShaper","clearSubstitutionFlags","recordRphf","recordPref","reorder","useCategory","USEInfo","isHalant","SHAPERS","mong","phag","hang","bng2","beng","dev2","deva","gjr2","gujr","guru","gur2","knda","knd2","mlm2","mlym","ory2","orya","taml","tml2","telu","tel2","khmr","bali","batk","brah","bugi","buhd","cakm","cham","dupl","egyp","gran","hano","java","kthi","kali","khoj","sind","lepc","limb","mahj","mtei","modi","hmng","rjng","saur","shrd","sidd","sinh","sund","sylo","tglg","tagb","tale","lana","tavt","takr","tibt","tfng","tirh","latn","DFLT","choose","shaper","curGlyph","replacement","undefined","USER_INDEX","ligature","sequenceMatchIndices","characters","ligatureGlyph","isMarkLigature","lastLigID","lastNumComps","curComps","matchIndex","applyContext","applyChainingContext","GPOSProcessor","peekIndex","variationProcessor","variationStore","getDelta","applyPositionValue","nextGlyph","peek","class1","class2","nextIndex","curRecord","nextRecord","getAnchor","rightToLeft","baseGlyphIndex","baseIndex","markRecord","baseAnchor","applyAnchor","ligIndex","ligAttach","markGlyph","ligGlyph","compIndex","mark1Index","prevIndex","good","mark2Index","markCoords","markPos","anchor","fixCursiveAttachment","fixMarkAttachment","OTLayoutEngine","glyphInfos","Shapers","glyphInfo","zeroMarkWidths","zeroMarkAdvances","LayoutEngine","unicodeLayoutEngine","kernProcessor","glyphsForString","setup","hideDefaultIgnorables","cleanup","positioned","positionGlyphs","space","isDefaultIgnorable","ch","plane","getAvailableFeatures","stringsForGlyph","from","SVG_COMMANDS","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","closePath","Path","commands","_bbox","_cbox","forEach","command","cmds","round","join","freeze","cx","cy","p0","p1","p2","p3","qp1x","qp1y","p3x","p3y","cp1x","cp1y","cp2x","cp2y","b2ac","t1","sqrt","t2","path","m0","m1","m2","m3","m4","m5","mapPoints","transform","angle","cos","sin","scaleX","scaleY","Glyph","metric","_metrics","_getTableMetrics","leftBearing","advanceHeight","topBearing","os2","getAdvanceAdjustment","_getCBox","_getBBox","_getPath","scale","_getMetrics","StandardNames","fromCharCode","_getName","save","toFunction","fill","restore","GlyfHeader","numberOfContours","ON_CURVE","X_SHORT_VECTOR","Y_SHORT_VECTOR","REPEAT","SAME_X","SAME_Y","ARG_1_AND_2_ARE_WORDS","WE_HAVE_A_SCALE","MORE_COMPONENTS","WE_HAVE_AN_X_AND_Y_SCALE","WE_HAVE_A_TWO_BY_TWO","WE_HAVE_INSTRUCTIONS","Point","onCurve","endContour","Component","dx","dy","scale01","scale10","TTFGlyph","internal","_getTableStream","short","same","glyfPos","nextPos","_decodeSimple","_decodeComposite","points","endPtsOfContours","numCoords","flag","point","px","_parseGlyphCoord","py","_getPhantomPoints","transformPoints","phantomPoints","haveInstructions","gPos","readInt8","_decode","contours","_getContours","contour","directory","firstPt","lastPt","curvePt","pt","prevPt","midX","midY","CFFGlyph","CFF2","getGlyphName","cff","trans","nStems","usedGsubrs","usedSubrs","_usedGsubrs","_usedSubrs","gsubrs","gsubrsBias","bias","privateDict","privateDictForGlyph","subrs","Subrs","subrsBias","vstore","vsindex","checkWidth","shift","nominalWidthX","parseStems","parse","phase","c1x","c1y","c2x","c2y","subr","blendVector","getBlendVector","numOperands","sum","s1","s2","v1","v2","random","n","c3x","c3y","c4x","c4y","c5x","c5y","c6x","c6y","pts","startx","starty","b1","SBIXImage","originX","originY","buflen","SBIXGlyph","img","getImageForSize","image","renderOutlines","COLRLayer","color","COLRGlyph","layers","layer","cpal","colr","rec","baseLayer","_getBaseGlyph","fillColor","render","TUPLES_SHARE_POINT_NUMBERS","TUPLE_COUNT_MASK","EMBEDDED_TUPLE_COORD","INTERMEDIATE_TUPLE","PRIVATE_POINT_NUMBERS","TUPLE_INDEX_MASK","POINTS_ARE_WORDS","POINT_RUN_COUNT_MASK","DELTAS_ARE_ZERO","DELTAS_ARE_WORDS","DELTA_RUN_COUNT_MASK","GlyphVariationProcessor","normalizeCoords","blendVectors","normalized","EPSILON","glyphPoints","tupleCount","here","sharedPoints","decodePoints","origPoints","tupleDataSize","tupleCoords","startCoords","endCoords","factor","tupleFactor","nPoints","xDeltas","decodeDeltas","yDeltas","outPoints","hasDelta","interpolateMissingDeltas","deltaX","deltaY","Uint16Array","run","runCount","readUInt16","Int16Array","inPoints","firstPoint","endPoint","firstDelta","curDelta","deltaInterpolate","deltaShift","ref1","ref2","iterable","in1","in2","out1","out2","out","ref","itemStore","varData","deltaSet","netAdjustment","master","scalar","regionIndex","axes","axisScalar","resolved","Promise","resolve","Subset","mapping","includeGlyph","EncodeStream","then","Glyf","xPoints","yPoints","TTFGlyphEncoder","lastX","lastY","lastFlag","pointCount","_encodePoint","shortFlag","sameFlag","diff","TTFSubset","glyphEncoder","curOffset","nextOffset","encodeSimple","_addGlyph","cloneDeep","CFFSubset","charstrings","getCharString","subsetSubrs","used","used_fds","used_subrs","fd_select","FontName","subsetCharstrings","Encoding","addString","CIDCount","subsetFontdict","createCIDFontdict","TTFFont","variationCoords","_directoryPos","_tables","_glyphs","_decodeDirectory","_getTable","_decodeTable","console","error","getName","getCharacterSet","nextState","layout","trim","default","settings","namedVariations","getVariation","toString","WOFFDirectoryEntry","compLength","origChecksum","WOFFDirectory","flavor","totalSfntSize","metaOffset","metaLength","metaOrigLength","privOffset","privLength","WOFFFont","outBuffer","alloc","inflate","WOFF2Glyph","_transformedGlyphs","Base128","knownTags","WOFF2DirectoryEntry","customTag","transformVersion","transformed","transformLength","WOFF2Directory","totalCompressedSize","WOFF2Font","_dataPos","_decompressed","decompressedSize","decompressed","brotli","_decompress","_transformGlyfTable","GlyfTable","nContours","totalPoints","read255UInt16","decodeTriplet","instructionSize","composites","Substream","_buf","indexFormat","nContourStreamSize","nPointsStreamSize","flagStreamSize","glyphStreamSize","compositeStreamSize","bboxStreamSize","instructionStreamSize","bboxes","WORD_CODE","ONE_MORE_BYTE_CODE2","ONE_MORE_BYTE_CODE1","LOWEST_U_CODE","withSign","baseval","b0","b2","TTCHeader","numFonts","dsigTag","dsigLength","dsigOffset","TrueTypeCollection","readString","fonts","DFontName","DFontData","Ref","nameOffset","attr","dataOffset","handle","Type","maxTypeIndex","refList","TypeList","DFontMap","typeList","nameListOffset","DFontHeader","dataLength","mapLength","DFont","sfnt"],"mappings":"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